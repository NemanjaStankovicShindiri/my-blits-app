import {
  __publicField
} from "./chunk-UVKRO5ER.js";

// node_modules/@lightningjs/blits/src/lib/symbols.js
var symbols_default = {
  cleanup: Symbol("cleanup"),
  currentView: Symbol("currentView"),
  cursorTagStart: Symbol("cursorTagStart"),
  computedKeys: Symbol("computedKeys"),
  destroy: Symbol("destroy"),
  rendererEventListeners: Symbol("rendererEventListeners"),
  getChildren: Symbol("getChildren"),
  holder: Symbol("holder"),
  id: Symbol("id"),
  identifier: Symbol("identifier"),
  index: Symbol("index"),
  init: Symbol("init"),
  inputEvents: Symbol("inputEvents"),
  internalEvent: Symbol("internalEvent"),
  intervals: Symbol("intervals"),
  isProxy: Symbol("isProxy"),
  launched: Symbol("launched"),
  level: Symbol("level"),
  methodKeys: Symbol("methodKeys"),
  originalState: Symbol("originalState"),
  propKeys: Symbol("propKeys"),
  raw: Symbol("raw"),
  ready: Symbol("ready"),
  renderer: Symbol("renderer"),
  routes: Symbol("routes"),
  routerHooks: Symbol("routerHooks"),
  settings: Symbol("settings"),
  state: Symbol("state"),
  stateKeys: Symbol("stateKeys"),
  textnode: Symbol("textnode"),
  timeouts: Symbol("timeouts"),
  type: Symbol("type"),
  watchers: Symbol("watchers"),
  watchKeys: Symbol("watchKeys"),
  wrapper: Symbol("wrapper"),
  /* Utilizing the global Symbol registry for the following purposes */
  // Symbol 'children' utilized within generated code
  children: Symbol.for("children"),
  // Symbol 'components' utilized within generated code
  components: Symbol.for("components"),
  // Symbol 'config' utilized within generated code
  config: Symbol.for("config"),
  // Symbol 'isSlot' utilized within generated code
  isSlot: Symbol.for("isSlot"),
  // Symbol 'props' utilized within generated code
  props: Symbol.for("props"),
  // Symbol 'slots' utilized within generated code
  slots: Symbol.for("slots"),
  // Symbol 'componentType' utilized within generated code
  componentType: Symbol.for("componentType"),
  // Symbol 'isComponent' utilized within generated code
  isComponent: Symbol.for("isComponent"),
  // Symbol 'effects' utilized within generated code
  effects: Symbol.for("effects"),
  // Symbol 'removeGlobalEffects' utilized within generated code
  removeGlobalEffects: Symbol.for("removeGlobalEffects")
};

// node_modules/@lightningjs/blits/src/settings.js
var settings = {
  [symbols_default.settings]: {},
  get(key, defaultValue = null) {
    if (key in this[symbols_default.settings]) {
      return this[symbols_default.settings][key];
    } else {
      return defaultValue;
    }
  },
  set(key, value) {
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        this.set(k, key[k]);
      });
    } else {
      this[symbols_default.settings][key] = value;
    }
  }
};
var settings_default = settings;

// node_modules/@lightningjs/blits/src/lib/log.js
var n = () => {
};
var pad = (n2) => String(n2).padStart(2, "0");
var time = () => {
  const now = /* @__PURE__ */ new Date();
  return pad(now.getHours()) + ":" + pad(now.getMinutes()) + ":" + pad(now.getSeconds());
};
var logger = (context) => {
  const level = settings_default.get("debugLevel");
  const log = {};
  Object.defineProperty(log, "info", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("info") > -1) && console.info.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #0284c7; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "warn", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("warn") > -1) && console.warn.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #fbbf24; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "error", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("error") > -1) && console.error.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #dc2626; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "debug", {
    get() {
      return (level >= 2 || Array.isArray(level) && level.indexOf("debug") > -1) && console.debug.bind(
        window.console,
        `%c ⚡️ ${context} %c (${(/* @__PURE__ */ new Date()).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        })})`,
        "background-color: #e2e8f0; color: #334155; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  return log;
};
var log_default = logger;
var Log;
var initLog = () => {
  Log = logger("Blits");
};

// node_modules/@lightningjs/blits/src/lib/colors/htmlColors.js
var htmlColors_default = {
  aliceblue: "0xf0f8ffff",
  antiquewhite: "0xfaebd7ff",
  aqua: "0xffffff00",
  aquamarine: "0x7fffd4ff",
  azure: "0xf0ffffff",
  beige: "0xf5f5dcff",
  bisque: "0xffe4c4ff",
  black: "0x000000ff",
  blanchedalmond: "0xffebcdff",
  blue: "0x0000ffff",
  blueviolet: "0x8a2be2ff",
  brown: "0xa52a2aff",
  burlywood: "0xdeb887ff",
  cadetblue: "0x5f9ea0ff",
  chartreuse: "0x7fff00ff",
  chocolate: "0xd2691eff",
  coral: "0xff7f50ff",
  cornflowerblue: "0x6495edff",
  cornsilk: "0xfff8dcff",
  crimson: "0xdc143cff",
  cyan: "0x00ffffff",
  darkblue: "0x00008bff",
  darkcyan: "0x008b8bff",
  darkgoldenrod: "0xb8860bff",
  darkgray: "0xa9a9a9ff",
  darkgreen: "0x006400ff",
  darkgrey: "0xa9a9a9ff",
  darkkhaki: "0xbdb76bff",
  darkmagenta: "0x8b008bff",
  darkolivegreen: "0x556b2fff",
  darkorange: "0xff8c00ff",
  darkorchid: "0x9932ccff",
  darkred: "0x8b0000ff",
  darksalmon: "0xe9967aff",
  darkseagreen: "0x8fbc8fff",
  darkslateblue: "0x483d8bff",
  darkslategray: "0x2f4f4fff",
  darkslategrey: "0x2f4f4fff",
  darkturquoise: "0x00ced1ff",
  darkviolet: "0x9400d3ff",
  deeppink: "0xff1493ff",
  deepskyblue: "0x00bfffff",
  dimgray: "0x696969ff",
  dimgrey: "0x696969ff",
  dodgerblue: "0x1e90ffff",
  firebrick: "0xb22222ff",
  floralwhite: "0xfffaf0ff",
  forestgreen: "0x228b22ff",
  fuchsia: "0xff00ffff",
  gainsboro: "0xdcdcdcff",
  ghostwhite: "0xf8f8ffff",
  gold: "0xffd700ff",
  goldenrod: "0xdaa520ff",
  gray: "0x808080ff",
  green: "0x008000ff",
  greenyellow: "0xadff2fff",
  grey: "0x808080ff",
  honeydew: "0xf0fff0ff",
  hotpink: "0xff69b4ff",
  indianred: "0xcd5c5cff",
  indigo: "0x4b0082ff",
  ivory: "0xfffff0ff",
  khaki: "0xf0e68cff",
  lavender: "0xe6e6faff",
  lavenderblush: "0xfff0f5ff",
  lawngreen: "0x7cfc00ff",
  lemonchiffon: "0xfffacdff",
  lightblue: "0xadd8e6ff",
  lightcoral: "0xf08080ff",
  lightcyan: "0xe0ffffff",
  lightgoldenrodyellow: "0xfafad2ff",
  lightgray: "0xd3d3d3ff",
  lightgreen: "0x90ee90ff",
  lightgrey: "0xd3d3d3ff",
  lightpink: "0xffb6c1ff",
  lightsalmon: "0xffa07aff",
  lightseagreen: "0x20b2aaff",
  lightskyblue: "0x87cefaff",
  lightslategray: "0x778899ff",
  lightslategrey: "0x778899ff",
  lightsteelblue: "0xb0c4deff",
  lightyellow: "0xffffe0ff",
  lime: "0x00ff00ff",
  limegreen: "0x32cd32ff",
  linen: "0xfaf0e6ff",
  magenta: "0xff00ffff",
  maroon: "0x800000ff",
  mediumaquamarine: "0x66cdaaff",
  mediumblue: "0x0000cdff",
  mediumorchid: "0xba55d3ff",
  mediumpurple: "0x9370dbff",
  mediumseagreen: "0x3cb371ff",
  mediumslateblue: "0x7b68eeff",
  mediumspringgreen: "0x00fa9aff",
  mediumturquoise: "0x48d1ccff",
  mediumvioletred: "0xc71585ff",
  midnightblue: "0x191970ff",
  mintcream: "0xf5fffaff",
  mistyrose: "0xffe4e1ff",
  moccasin: "0xffe4b5ff",
  navajowhite: "0xffdeadff",
  navy: "0x000080ff",
  oldlace: "0xfdf5e6ff",
  olive: "0x808000ff",
  olivedrab: "0x6b8e23ff",
  orange: "0xffa500ff",
  orangered: "0xff4500ff",
  orchid: "0xda70d6ff",
  palegoldenrod: "0xeee8aaff",
  palegreen: "0x98fb98ff",
  paleturquoise: "0xafeeeeff",
  palevioletred: "0xdb7093ff",
  papayawhip: "0xffefd5ff",
  peachpuff: "0xffdab9ff",
  peru: "0xcd853fff",
  pink: "0xffc0cbff",
  plum: "0xdda0ddff",
  powderblue: "0xb0e0e6ff",
  purple: "0x800080ff",
  rebeccapurple: "0x663399ff",
  red: "0xff0000ff",
  rosybrown: "0xbc8f8fff",
  royalblue: "0x4169e1ff",
  saddlebrown: "0x8b4513ff",
  salmon: "0xfa8072ff",
  sandybrown: "0xf4a460ff",
  seagreen: "0x2e8b57ff",
  seashell: "0xfff5eeff",
  sienna: "0xa0522dff",
  silver: "0xc0c0c0ff",
  skyblue: "0x87ceebff",
  slateblue: "0x6a5acdff",
  slategray: "0x708090ff",
  slategrey: "0x708090ff",
  snow: "0xfffafaff",
  springgreen: "0x00ff7fff",
  steelblue: "0x4682b4ff",
  tan: "0xd2b48cff",
  teal: "0x008080ff",
  thistle: "0xd8bfd8ff",
  tomato: "0xff6347ff",
  transparent: "0x00000000",
  turquoise: "0x40e0d0ff",
  violet: "0xee82eeff",
  wheat: "0xf5deb3ff",
  white: "0xffffffff",
  whitesmoke: "0xf5f5f5ff",
  yellow: "0xffff00ff",
  yellowgreen: "0x9acd32ff"
};

// node_modules/@lightningjs/blits/src/lib/colors/colors.js
var hex = /^#?([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var rgba = /^(rgba?)\((\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*),(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*),(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*)(,(\s*(-?\d+(?:\.\d+)?)\s*))?\)$/;
var hsla = /^(hsla?)\((\s*(360|3[0-5][0-9]|[12]?[0-9]{1,2})\s*),(\s*(100|[1-9]?[0-9])\s*)%,(\s*(100|[1-9]?[0-9])\s*)%(,(\s*(1|0(?:\.\d+)?)\s*))?\)$/;
var hexLookup = {};
var decimalToHex = (decimal) => {
  if (hexLookup[decimal] !== void 0) {
    return hexLookup[decimal];
  }
  const resp = parseInt(decimal).toString(16).padStart(2, "0");
  hexLookup[decimal] = resp;
  return resp;
};
var colors_default = {
  normalize: (color = "", defaultColor = "0xffffffff") => {
    color = color.toString();
    if (color.startsWith("0x") && color.length === 10) {
      return color;
    }
    if (htmlColors_default[color] !== void 0) {
      return htmlColors_default[color];
    }
    if (hex.test(color)) {
      color = color.replace("#", "").toLowerCase();
      if (color.length === 3) {
        color = color.split("").map((c) => c + c).join("");
      }
      const colorRGBA = "0x" + color.padEnd(8, "f");
      htmlColors_default[color] = colorRGBA;
      return colorRGBA;
    }
    const rgbaMatch = rgba.exec(color);
    if (rgbaMatch) {
      const r = decimalToHex(rgbaMatch[3]);
      const g = decimalToHex(rgbaMatch[5]);
      const b = decimalToHex(rgbaMatch[7]);
      let a = "ff";
      if (rgbaMatch[10] && rgbaMatch[1] === "rgba") {
        const alpha = Math.min(Math.max(Math.round(parseFloat(rgbaMatch[10]) * 255), 0), 255);
        a = decimalToHex(alpha);
      }
      const resp = "0x" + r + g + b + a;
      htmlColors_default[color] = resp;
      return resp;
    }
    if (hsla.test(color)) {
      console.warn("HSL(A) color format is not supported yet");
      return "0xffffffff";
    }
    return defaultColor;
  }
};

// node_modules/@lightningjs/blits/src/lib/templateparser/parser.js
var parser_default = (template = "", componentName, parentComponent, filePath = null) => {
  let cursor = 0;
  let prevCursor = 0;
  let tags = [];
  let currentTag = null;
  let currentLevel = 0;
  const tagStartRegex = /^<\/?([a-zA-Z0-9_\-.]+)\s*/;
  const tagEndRegex = /^\s*(\/?>)\s*/;
  const attrNameRegex = /^([A-Za-z0-9:.\-_@$]+)=\s*(["'])/;
  const emptyTagStartRegex = /^<>\s*/;
  const emptyTagEndRegex = /^\s*(<\/>)\s*/;
  const parse = () => {
    template = clean(template);
    try {
      parseLoop(parseEmptyTagStart);
      return format(tags);
    } catch (error) {
      if (error.name == "TemplateParseError" || error.name == "TemplateStructureError") {
        error.message = `${error.message}
${error.context}`;
      }
      throw error;
    }
  };
  const parseLoop = (next) => {
    if (cursor >= template.length) {
      return;
    }
    next();
  };
  const clean = (templateText) => {
    return templateText.replace(/<!--.*?-->/gms, "").replace(/\r?\n\s*\r\n/gm, " ").replace(/\r?\n\s*(\S)/gm, " $1").replace(/\r?\n/g, "").trim();
  };
  const moveCursorOnMatch = (regex) => {
    const match = template.slice(cursor).match(regex);
    if (match) {
      prevCursor = cursor;
      cursor += match[0].length;
    }
    return match;
  };
  const parseEmptyTagStart = () => {
    const match = moveCursorOnMatch(emptyTagStartRegex);
    if (match) {
      tags.push({
        [Symbol.for("componentType")]: null,
        [symbols_default.type]: "opening",
        [symbols_default.level]: currentLevel,
        [symbols_default.cursorTagStart]: prevCursor
      });
      currentLevel++;
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseEmptyTagEnd);
    }
  };
  const parseEmptyTagEnd = () => {
    const match = moveCursorOnMatch(emptyTagEndRegex);
    if (match) {
      currentLevel--;
      tags.push({
        [Symbol.for("componentType")]: null,
        [symbols_default.type]: "closing",
        [symbols_default.level]: currentLevel
      });
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseTag);
    }
  };
  const parseTag = () => {
    const match = moveCursorOnMatch(tagStartRegex);
    if (match) {
      currentTag = {
        [Symbol.for("componentType")]: match[1],
        [symbols_default.level]: currentLevel,
        [symbols_default.cursorTagStart]: prevCursor
      };
      if (match[0].startsWith("</")) {
        currentLevel--;
        currentTag[symbols_default.type] = "closing";
        currentTag[symbols_default.level] = currentLevel;
      } else {
        currentTag[symbols_default.type] = "opening";
        currentLevel++;
      }
      parseLoop(parseTagEnd);
    } else {
      throw TemplateParseError("InvalidTag");
    }
  };
  const parseTagEnd = () => {
    const match = moveCursorOnMatch(tagEndRegex);
    if (match) {
      if (match[1] === "/>") {
        if (currentTag[symbols_default.type] === "closing") {
          throw TemplateParseError("InvalidClosingTag");
        }
        currentTag[symbols_default.type] = "self-closing";
        currentLevel--;
      }
      if (currentTag[symbols_default.type] === "opening") {
        const tagContent = template.slice(cursor, template.indexOf("<", cursor));
        if (tagContent) {
          currentTag.content = tagContent;
          cursor += tagContent.length;
        }
      }
      tags.push(currentTag);
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseAttributes);
    }
  };
  const parseAttributes = () => {
    const attrNameMatch = moveCursorOnMatch(attrNameRegex);
    if (attrNameMatch) {
      if (currentTag[symbols_default.type] === "closing") {
        throw TemplateParseError("AttributesInClosingTag");
      }
      const delimiter = attrNameMatch[2];
      const attrValueRegex = new RegExp(`^(.*?)${delimiter}\\s*`);
      const attrValueMatch = moveCursorOnMatch(attrValueRegex);
      if (attrValueMatch) {
        const attr = formatAttribute(attrNameMatch[1], attrValueMatch[1]);
        currentTag[attr.name] = attr.value;
        parseLoop(parseTagEnd);
      } else {
        throw TemplateParseError("MissingOrInvalidAttributeValue");
      }
    } else {
      throw TemplateParseError("InvalidAttribute");
    }
  };
  const formatAttribute = (name, value) => {
    if (name.includes(".")) {
      const [objectName, attributeName] = name.split(".");
      return { name: objectName, value: `{${attributeName}: ${value}}` };
    }
    if (["color", ":color", ":effects", "effects"].includes(name)) {
      return processColors(name, value);
    }
    return { name, value };
  };
  const processColors = (name, value) => {
    let newValue = value;
    let normalized = colors_default.normalize(newValue, null);
    if (normalized === null) {
      const stringTokenRegex = /'([^']+)'/g;
      let match;
      let lastIndex = 0;
      let result = "";
      while ((match = stringTokenRegex.exec(value)) !== null) {
        const potentialColor = match[1];
        const matchIndex = match.index;
        const matchLength = match[0].length;
        result += value.slice(lastIndex, matchIndex);
        normalized = colors_default.normalize(potentialColor, null);
        if (normalized === null) {
          result += value.slice(matchIndex, matchIndex + matchLength);
        } else {
          result += `'${normalized}'`;
        }
        lastIndex = matchIndex + matchLength;
      }
      result += value.slice(lastIndex);
      newValue = result;
    } else {
      newValue = normalized;
    }
    return { name, value: newValue };
  };
  const format = (parsedData) => {
    let stack = [];
    let rootElementDefined = false;
    let output = { children: [] };
    let currentParent = output;
    for (let i = 0; i < parsedData.length; i++) {
      let element = parsedData[i];
      if (element[symbols_default.level] === 0 && element[symbols_default.type] !== "closing") {
        if (rootElementDefined) {
          throw TemplateStructureError("MultipleTopLevelTags", element);
        }
        if (element[":for"] !== void 0) {
          throw TemplateStructureError("ForAttributeOnRootElement", element);
        }
        rootElementDefined = true;
      }
      if (element[symbols_default.type] === "opening") {
        stack.push({
          [symbols_default.level]: element[symbols_default.level],
          [symbols_default.type]: element[symbols_default.type],
          [symbols_default.cursorTagStart]: element[symbols_default.cursorTagStart],
          [Symbol.for("componentType")]: element[Symbol.for("componentType")],
          parent: currentParent
          // helps getting the previous parent when closing tag is encountered
        });
      } else if (element[symbols_default.type] === "closing") {
        const isStackEmpty = stack.length === 0;
        let isLevelMismatch = false;
        let isTagMismatch = false;
        if (!isStackEmpty) {
          isLevelMismatch = stack[stack.length - 1][symbols_default.level] !== element[symbols_default.level];
          isTagMismatch = stack[stack.length - 1][Symbol.for("componentType")] !== element[Symbol.for("componentType")];
        }
        if (isStackEmpty || isLevelMismatch || isTagMismatch) {
          throw TemplateStructureError("MismatchedClosingTag", element);
        }
        const lastTag = stack.pop();
        currentParent = lastTag.parent;
      }
      const newItem = { ...element };
      delete newItem[symbols_default.type];
      delete newItem[symbols_default.level];
      delete newItem[symbols_default.cursorTagStart];
      if (element[symbols_default.type] === "opening") {
        if (i + 1 < parsedData.length && parsedData[i + 1][symbols_default.type] !== "closing") {
          newItem.children = [];
        }
        currentParent.children.push(newItem);
        currentParent = newItem;
      } else if (element[symbols_default.type] === "self-closing") {
        currentParent.children.push(newItem);
      }
    }
    if (stack.length > 0) {
      throw TemplateStructureError("UnclosedTags", stack);
    }
    return output;
  };
  const contextPaddingBefore = 10;
  const contextPaddingAfter = 50;
  const TemplateParseError = (message) => {
    const location = getErrorLocation();
    message = `${message} in ${location}`;
    const error = new Error(message);
    error.name = "TemplateParseError";
    const start = Math.max(0, prevCursor - contextPaddingBefore);
    const end = Math.min(template.length, cursor + contextPaddingAfter);
    const contextText = template.slice(start, end);
    const caretPosition = cursor - start;
    error.context = insertContextCaret(caretPosition, contextText);
    return error;
  };
  const TemplateStructureError = (message, context) => {
    const location = getErrorLocation();
    message = `${message} in ${location}`;
    const error = new Error(message);
    error.name = "TemplateStructureError";
    if (Array.isArray(context)) {
      error.context = context.map((tag) => generateContext(tag)).join("\n");
    } else {
      error.context = generateContext(context);
    }
    function generateContext(element) {
      const start = Math.max(0, element[symbols_default.cursorTagStart] - contextPaddingBefore);
      const contextText = template.slice(start, start + contextPaddingAfter);
      return insertContextCaret(contextPaddingBefore, contextText);
    }
    return error;
  };
  const insertContextCaret = (position, contextText) => {
    const caret = " ".repeat(position) + "^";
    return `
${contextText}
${caret}
`;
  };
  const getErrorLocation = () => {
    if (parentComponent) {
      let hierarchy = componentName || "";
      let currentParent = parentComponent;
      while (currentParent) {
        hierarchy = `${currentParent[Symbol.for("componentType")]}/${hierarchy}`;
        currentParent = currentParent.parent;
      }
      return hierarchy;
    }
    return filePath ? filePath : "Blits.Application";
  };
  return parse();
};

// node_modules/@lightningjs/blits/src/lib/codegenerator/generator.js
var counter;
var isDev;
function generator_default(templateObject = { children: [] }, devMode = false) {
  const ctx = {
    renderCode: [
      "const elms = []",
      "const elementConfigs = []",
      "const forloops = []",
      "const props = []",
      "const created = []",
      "const effects = {}",
      "const skips = []",
      "let componentType",
      "let rootComponent = component",
      "let propData",
      "let slotComponent",
      "let inSlot = false",
      "let slotChildCounter = 0",
      "let cmps = []"
    ],
    effectsCode: [],
    cleanupCode: [
      "rootComponent = null",
      "propData = null",
      "slotComponent = null",
      "parent = null"
    ],
    context: { props: [], components: this.components }
  };
  counter = -1;
  isDev = devMode;
  if (isDev === true) {
    ctx.renderCode.push(`
      function propInComponent(prop, kind="dynamic") {
        const property = prop.includes('.') ? prop.split('.')[0] : prop
        if (kind === 'reactive' || prop.includes('.') === false) {
          if (property in component === false) {
            Log.warn('Property ' +  property + ' was accessed during render but is not defined on instance')
          }
        } else {
          const nestedKeys = prop.split('.')
          let base = component
          for(let i =0; i<nestedKeys.length;i++){
            if (base[nestedKeys[i]] === undefined) {
              Log.warn('Property ' +  nestedKeys.slice(0,i+1).join('.') + ' was accessed during render but is not defined on instance')
            }
            base = base[nestedKeys[i]]
          }
        }
      }
    `);
  }
  generateCode.call(ctx, templateObject);
  ctx.renderCode.push(`
    return { elms, cleanup: () => {
      ${ctx.cleanupCode.join("\n")}
      component = null
      cmps.length = 0
      elms.length = 0
      components.length = 0
      elementConfigs.length = 0
      forloops.length = 0
      props.length = 0
      skips.length = 0
    }}
  `);
  return {
    render: new Function(
      "parent",
      "component",
      "context",
      "components",
      "effect",
      "getRaw",
      "Log",
      ctx.renderCode.join("\n")
    ),
    effects: ctx.effectsCode.map(
      (code) => new Function("component", "elms", "context", "components", "rootComponent", "effect", code)
    ),
    context: ctx.context
  };
}
var extractVariables = function(value) {
  const regEx = /\$\$?\w+(\.\w+)?/g;
  const matches = value.match(regEx);
  if (matches !== null) {
    const shaderRegex = /\$shader/;
    return matches.filter((match) => !shaderRegex.test(match));
  } else {
    return false;
  }
};
var verifyVariables = function(value, renderCode, type = "dynamic") {
  const variablesToBeVerified = extractVariables(value);
  if (variablesToBeVerified !== false) {
    for (let i = 0; i < variablesToBeVerified.length; i++) {
      let variable = variablesToBeVerified[i];
      if (type === "reactive" && variable.includes(".")) {
        variable = variable.split(".")[0];
      }
      renderCode.push(`propInComponent('${variable.replace("$", "")}', '${type}')`);
    }
  }
};
var generateElementCode = function(templateObject, parent = false, options = { key: false, component: "component.", forceEffect: false, forloop: false }) {
  const renderCode = options.forceEffect ? this.effectsCode : this.renderCode;
  if (parent) {
    renderCode.push(`parent = ${parent}`);
  }
  if ("key" in templateObject) options.key = interpolate(templateObject.key, options.component);
  const elm = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  if (options.key) {
    renderCode.push(`
      if(elms[${counter}] === undefined) {
        elms[${counter}] = {}
      }
    `);
  }
  renderCode.push(`elementConfigs[${counter}] = {}`);
  if (options.forloop) {
    renderCode.push(`if(${elm} === undefined) {`);
  }
  renderCode.push(`
    ${elm} = this.element({parent: parent || 'root'}, inSlot === true ? slotComponent : component)
  `);
  if (options.forloop) {
    renderCode.push("}");
  }
  const children = templateObject["children"];
  delete templateObject["children"];
  if (templateObject[Symbol.for("componentType")] === "Slot") {
    renderCode.push(`elementConfigs[${counter}][Symbol.for('isSlot')] = true`);
  }
  Object.keys(templateObject).forEach((key) => {
    if (key === "slot") {
      renderCode.push(`
        elementConfigs[${counter}]['parent'] = slotComponent[Symbol.for('slots')] !== undefined && Array.isArray(slotComponent[Symbol.for('slots')]) === true && slotComponent[Symbol.for('slots')].filter(slot => slot.ref === '${templateObject.slot}').shift() || parent
      `);
    }
    if (key === "key") return;
    if (key === "inspector-data" && !isDev) return;
    const value = templateObject[key];
    if (isReactiveKey(key)) {
      if (options.holder && key === ":color") return;
      if (options.holder) {
        this.effectsCode.push(`
        if(typeof skips === 'undefined' || (typeof skips[${counter}] === 'undefined' ||
          skips[${counter}].indexOf('${key.substring(1)}') === -1))
          ${elm}.set('${key.substring(1)}', ${interpolate(templateObject[key], options.component)})
        `);
      } else {
        this.effectsCode.push(`
            ${elm}.set('${key.substring(1)}', ${interpolate(
          templateObject[key],
          options.component
        )})
          `);
      }
      if (isDev === true && options.component !== "scope." && value.includes("$")) {
        verifyVariables(value, renderCode, "reactive");
      }
      renderCode.push(
        `elementConfigs[${counter}]['${key.substring(1)}'] = ${interpolate(
          value,
          options.component
        )}`
      );
    } else {
      if (isDev === true && options.component !== "scope." && value.includes("$")) {
        verifyVariables(value, renderCode);
      }
      renderCode.push(
        `elementConfigs[${counter}]['${key}'] = ${cast(value, key, options.component)}`
      );
    }
  });
  if (options.holder === true) {
    renderCode.push(`
    skips[${counter}] = []
    if(typeof cmps[${counter}] !== 'undefined') {
      for(let key in cmps[${counter}][Symbol.for('config')].props) {
        delete elementConfigs[${counter}][cmps[${counter}][Symbol.for('config')].props[key]]
        skips[${counter}].push(cmps[${counter}][Symbol.for('config')].props[key])
      }
    }
    `);
  }
  if (options.forloop) {
    renderCode.push(`if(${elm}.nodeId === undefined) {`);
  }
  renderCode.push(`${elm}.populate(elementConfigs[${counter}])`);
  renderCode.push(`
    if(inSlot === true) {
      slotChildCounter -= 1
    }
  `);
  if (options.forloop) {
    renderCode.push("}");
  }
  if (children) {
    generateCode.call(this, { children }, `${elm}`, options);
  }
};
var generateComponentCode = function(templateObject, parent = false, options = {
  key: false,
  component: "component.",
  forceEffect: false,
  holder: false,
  forloop: false
}) {
  const renderCode = options.forceEffect ? this.effectsCode : this.renderCode;
  renderCode.push(`
    cmps[${counter}] =
      (context.components && context.components['${templateObject[Symbol.for("componentType")]}']) || components['${templateObject[Symbol.for("componentType")]}']
  `);
  this.cleanupCode.push(`
    cmps[${counter}] = null
  `);
  if ("key" in templateObject) {
    options.key = interpolate(templateObject.key, options.component);
  }
  const children = templateObject.children;
  delete templateObject.children;
  generateElementCode.call(this, templateObject, parent, { ...options, ...{ holder: true } });
  parent = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  counter++;
  const elm = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  if (options.key) {
    renderCode.push(`
      if(elms[${counter}] === undefined) {
        elms[${counter}] = {}
      }
    `);
  }
  if (parent) {
    renderCode.push(`parent = ${parent};`);
  }
  renderCode.push(`props[${counter}] = {}`);
  this.cleanupCode.push(`props[${counter}] = null`);
  if (options.forloop) {
    renderCode.push(`if(${elm} === undefined) {`);
  }
  Object.keys(templateObject).forEach((key) => {
    if (isReactiveKey(key)) {
      this.effectsCode.push(`
        ${elm}[Symbol.for('props')]['${key.substring(1)}'] = ${interpolate(
        templateObject[key],
        options.component
      )}`);
      renderCode.push(`
        propData = ${interpolate(templateObject[key], options.component)}
        if (Array.isArray(propData) === true) {
          propData = getRaw(propData).slice(0)
        }
        props[${counter}]['${key.substring(1)}'] = propData`);
    } else {
      renderCode.push(
        `props[${counter}]['${key}'] = ${cast(templateObject[key], key, options.component)}`
      );
    }
  });
  renderCode.push(`
    componentType = props[${counter}]['is'] || '${templateObject[Symbol.for("componentType")]}'

    components[${counter}]
    if(typeof componentType === 'string') {
      components[${counter}] = context.components && context.components[componentType] || components[componentType]
      if(!components[${counter}]) {
        throw new Error('Component "${templateObject[Symbol.for("componentType")]}" not found')
      }
    } else if(typeof componentType === 'function' && componentType[Symbol.for('isComponent')] === true) {
      components[${counter}] = componentType
    }

    ${elm} = components[${counter}].call(null, {props: props[${counter}]}, ${parent}, component)

    if (${elm}[Symbol.for('slots')][0]) {
      parent = ${elm}[Symbol.for('slots')][0]
      slotComponent = ${elm}
      inSlot = true
    } else {
      parent = ${elm}[Symbol.for('children')][0]
    }
  `);
  this.cleanupCode.push(`components[${counter}] = null`);
  if (options.forloop) {
    renderCode.push("}");
  }
  if (children) {
    if (!options.forloop) {
      renderCode.push(`
        if(inSlot === true) {
          slotChildCounter = ${children.length}  + 1
        }
      `);
    }
    counter++;
    generateElementCode.call(this, { children }, false, { ...options });
  }
  if (!options.forloop) {
    renderCode.push(`
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false
      }
    `);
  }
};
var generateForLoopCode = function(templateObject, parent) {
  const forLoop = templateObject[":for"];
  delete templateObject[":for"];
  const range = templateObject["range"] || templateObject[":range"] || "{}";
  delete templateObject["range"];
  delete templateObject[":range"];
  const key = templateObject["key"];
  const forStartCounter = counter;
  const forKey = interpolate(key, "scope.");
  const shallow = !!!(templateObject["$shallow"] && templateObject["$shallow"].toLowerCase() === "false");
  delete templateObject["$shallow"];
  delete templateObject["key"];
  const regex = /(.+)\s+in\s+(.+)/gi;
  const result = regex.exec(forLoop);
  const [item, index] = result[1].replace("(", "").replace(")", "").split(/\s*,\s*/);
  const scopeRegex = new RegExp(`(scope\\.(?!${item}\\.|${index}|key)([\\w$]+))`, "gi");
  const ctx = {
    renderCode: [],
    effectsCode: [],
    cleanupCode: [],
    context: { props: [], components: this.components }
  };
  if (parent) {
    ctx.renderCode.push(`parent = ${parent}`);
  }
  if (index !== void 0) {
    const indexRegex = new RegExp(`\\$${index}(?!['\\w])`);
    const indexResult = indexRegex.exec(key);
    if (Array.isArray(indexResult)) {
      ctx.renderCode.push(
        `console.warn(" Using '${index}' in the key, like key=${key},  is not recommended")`
      );
    }
  }
  ctx.renderCode.push(`
    created[${forStartCounter}] = []
    effects[${forStartCounter}] = []

    let from${forStartCounter}
    let to${forStartCounter}

    forloops[${forStartCounter}] = (collection = [], elms, created) => {
      const rawCollection = getRaw(collection)
      const keys = new Set()
      let l = rawCollection.length

      const range = ${interpolate(range, "component?.")} || {}
      from${forStartCounter} = range['from'] || 0
      to${forStartCounter} = 'to' in range ? range['to'] : rawCollection.length

      while(l--) {
        const ${item} = rawCollection[l]
  `);
  ctx.cleanupCode.push(`
    created[${forStartCounter}].length = 0
  `);
  if (index !== void 0) {
    ctx.renderCode.push(`
        const ${index} = l
    `);
  }
  ctx.renderCode.push(`
        if(l < to${forStartCounter} && l >= from${forStartCounter}) {
          keys.add('' +  ${interpolate(key, "") || "l"})
        }
      }
  `);
  const indexToInjectDestroyCode = ctx.renderCode.length;
  ctx.renderCode.push(`
      created.length = 0
      const length = rawCollection.length

      component !== null && component[Symbol.for('removeGlobalEffects')](effects[${forStartCounter}])

      for(let i = 0; i < effects[${forStartCounter}].length; i++) {
        const value = effects[${forStartCounter}][i]
        const index = component[Symbol.for('effects')].indexOf(value)
        if (index > -1) component[Symbol.for('effects')].splice(index, 1)
      }

      effects[${forStartCounter}].length = 0
      for(let __index = 0; __index < length; __index++) {
        if(__index < from${forStartCounter} || __index >= to${forStartCounter}) continue
        let scope = Object.create(component)
        parent = ${parent}
        scope['${item}'] = rawCollection[__index]
  `);
  if (index !== "") {
    ctx.renderCode.push(`
        scope['${index}'] = __index
    `);
  }
  ctx.renderCode.push(`
        scope['key'] = '' + ${forKey || "__index"}
  `);
  if ("ref" in templateObject && templateObject.ref.indexOf("$") === -1) {
    ctx.renderCode.push(`
        scope['__ref'] = '${templateObject.ref}' + __index
    `);
    templateObject.ref = "$__ref";
  }
  ctx.renderCode.push(`
        created.push(scope.key)
  `);
  if (templateObject[Symbol.for("componentType")] === "Element" || templateObject[Symbol.for("componentType")] === "Slot" || templateObject[Symbol.for("componentType")] === "Text") {
    if (templateObject[Symbol.for("componentType")] === "Text") {
      templateObject.__textnode = "true";
    }
    generateElementCode.call(ctx, templateObject, parent, {
      key: "scope.key",
      component: "scope.",
      forceEffect: false,
      forloop: true
    });
  } else {
    generateComponentCode.call(ctx, templateObject, false, {
      key: "scope.key",
      component: "scope.",
      forceEffect: false,
      forloop: true
    });
  }
  const innerScopeEffects = ctx.effectsCode.filter(
    (effect2) => [...effect2.matchAll(scopeRegex)].length === 0
  );
  const outerScopeEffects = ctx.effectsCode.filter(
    (effect2) => [...effect2.matchAll(scopeRegex)].length !== 0
  );
  if (shallow === false) {
    ctx.renderCode.push(`
      scope = Object.assign(collection[__index], scope)
  `);
  }
  innerScopeEffects.forEach((effect2, index2) => {
    const key2 = effect2.indexOf(`scope.${index2}`) > -1 ? `'${interpolate(result[2], "")}'` : null;
    if (effect2.indexOf("Symbol.for('props')") === -1) {
      ctx.renderCode.push(`
        let eff${index2} = () => {
          ${effect2}
        }
        effect(eff${index2}, ${key2})
        effects[${forStartCounter}].push(eff${index2})
        component[Symbol.for('effects')].push(eff${index2})
      `);
    } else {
      ctx.renderCode.push(`
        ${effect2}
      `);
    }
  });
  ctx.renderCode.push(`
    }
    return effects
  }`);
  const destroyCode = [];
  destroyCode.push(`
      let i = created.length

      while (i--) {
        if (keys.has(created[i]) === false) {
          const key = created[i]
  `);
  const forEndCounter = counter;
  for (let i = forStartCounter; i <= forEndCounter; i++) {
    destroyCode.push(`
        elms[${i}][key] && elms[${i}][key].destroy()
        elms[${i}][key] = null
        delete elms[${i}][key]
    `);
  }
  destroyCode.push(`
      }
    }
  `);
  ctx.renderCode.splice(indexToInjectDestroyCode, 0, ...destroyCode);
  let effectKey = `${interpolate(result[2], "")}`;
  if (effectKey && effectKey.includes(".")) {
    effectKey = effectKey.match(/[^.]+$/)[0];
  }
  const effectKeysRegex = /\$([^,} ]+)/g;
  const effectKeys = [...range.matchAll(effectKeysRegex)].map((match) => `'${match[1]}'`);
  ctx.renderCode.push(`
    let eff${forStartCounter} = () => {
      forloops[${forStartCounter}](${cast(result[2], ":for")}, elms, created[${forStartCounter}])
    }

    component[Symbol.for('effects')].push(eff${forStartCounter})

    effect(eff${forStartCounter}, ['${effectKey}', ${effectKeys.join(",")}])
  `);
  ctx.cleanupCode.push(`
    eff${forStartCounter} = null
    // call loop with empty array
    forloops[${forStartCounter}]([], elms, created[${forStartCounter}])
    forloops[${forStartCounter}] = null
  `);
  outerScopeEffects.forEach((effect2, outerScopeEffectsIndex) => {
    const matches = [...effect2.matchAll(scopeRegex)];
    let l = matches.length;
    const refs = [];
    while (l--) {
      const match = matches[l];
      const ref = `component.${match[2]}`;
      refs.indexOf(ref) === -1 && refs.push(ref);
      if (match[2] !== item) {
        effect2 = effect2.substring(0, match.index) + ref + effect2.substring(match.index + match[1].length);
      }
    }
    ctx.renderCode.push(`
      let eff${forStartCounter}_${outerScopeEffectsIndex} = () => {
        void ${refs.join(", ")}
        for(let __index = 0; __index < ${interpolate(result[2])}.length; __index++) {
          if(__index < from${forStartCounter} || __index >= to${forStartCounter}) continue
          const scope = {}
          scope['${index}'] = __index
          scope['${item}'] = ${interpolate(result[2])}[__index]
          scope['key'] = ${forKey || "__index"}
    `);
    ctx.cleanupCode.push(`eff${forStartCounter}_${outerScopeEffectsIndex} = null`);
    ctx.renderCode.push(`
          ${effect2}
        }
      }
      component[Symbol.for('effects')].push(eff${forStartCounter}_${outerScopeEffectsIndex})
      effect(eff${forStartCounter}_${outerScopeEffectsIndex})
    `);
  });
  this.renderCode.push(ctx.renderCode.join("\n"));
  this.cleanupCode.push(ctx.cleanupCode.join("\n"));
};
var generateCode = function(templateObject, parent = false, options = {}) {
  templateObject.children && templateObject.children.forEach((childTemplateObject) => {
    counter++;
    if (Object.keys(childTemplateObject).indexOf(":for") > -1) {
      generateForLoopCode.call(this, childTemplateObject, parent);
    } else {
      if (childTemplateObject[Symbol.for("componentType")] === "Element" || childTemplateObject[Symbol.for("componentType")] === "Slot" || childTemplateObject[Symbol.for("componentType")] === "Text" || childTemplateObject[Symbol.for("componentType")] === "Layout") {
        if (childTemplateObject[Symbol.for("componentType")] === "Text") {
          childTemplateObject.__textnode = "true";
        }
        if (childTemplateObject[Symbol.for("componentType")] === "Layout") {
          childTemplateObject.__layout = "true";
        }
        generateElementCode.call(this, childTemplateObject, parent, options);
      } else {
        generateComponentCode.call(this, childTemplateObject, parent, options);
      }
    }
  });
};
var interpolate = (val, component = "component.") => {
  if (val === void 0) return val;
  const replaceString = /('.*?')+/gi;
  const replaceDollar = /\$(\$(?=\$)|\$?)/g;
  const matches = val.matchAll(replaceString);
  const restore = [];
  let i = 0;
  for (const match of matches) {
    restore.push(match[0]);
    val = val.replace(match[0], `[@@REPLACEMENT${i}@@]`);
    i++;
  }
  val = val.replace(replaceDollar, (match, group1) => {
    if (group1 === "") {
      return component;
    } else if (group1 === "$") {
      return component + "$";
    }
  });
  restore.forEach((el, idx) => {
    val = val.replace(`[@@REPLACEMENT${idx}@@]`, el);
  });
  return val;
};
var cast = (val = "", key = false, component = "component.") => {
  const dynamicArgumentRegex = /\$\w+/gi;
  let castedValue;
  if (key === "content") {
    if (val.startsWith("$")) {
      castedValue = `${component}${val.replace("$", "")}`;
    } else {
      const escapedVal = val.replace(/\\\\/g, "__DOUBLE_BACKSLASH__").replace(/(^|[^\\])'/g, "$1\\'").replace(/__DOUBLE_BACKSLASH__/g, "\\\\");
      castedValue = `'${parseInlineContent(escapedVal, component)}'`;
    }
  } else if (key !== "color" && /[^0-9%\s.eE]/.test(val) === false && !isNaN(parseFloat(val))) {
    castedValue = parseFloat(val);
    if (val.endsWith("%")) {
      const map = {
        w: "width",
        width: "width",
        x: "width",
        h: "height",
        height: "height",
        y: "height"
      };
      const base = map[key];
      if (base) {
        castedValue = `parent.node.${base} * (${castedValue} / 100)`;
      }
    }
  } else if (val.toLowerCase() === "true") {
    castedValue = true;
  } else if (val.toLowerCase() === "false") {
    castedValue = false;
  } else if (key.startsWith("@") && val) {
    const c = component.slice(0, -1);
    castedValue = `${c}['${val.replace("$", "")}'] && ${c}['${val.replace("$", "")}'].bind(${c})`;
  } else if (val.startsWith("$")) {
    castedValue = `${component}${val.replace("$", "")}`;
  } else if (dynamicArgumentRegex.exec(val)) {
    const rex = /\w+\s*:\s*(?:[^\s,}]+|".*?"|'.*?')/g;
    const results = val.match(rex);
    castedValue = {};
    if (results) {
      for (let i = 0; i < results.length; i++) {
        const members = results[i].split(/\s*:\s*/);
        if (members) {
          populateFields(members[0], members[1], component, castedValue);
        }
      }
    }
    return interpolateObject(castedValue);
  } else {
    castedValue = `"${val}"`;
  }
  return castedValue;
};
var isReactiveKey = (str) => str.startsWith(":");
var parseInlineContent = (val, component) => {
  const dynamicParts = /\{\{\s*(\$\S+)\s*\}\}/g;
  const matches = [...val.matchAll(dynamicParts)];
  if (matches.length) {
    for (let [match, arg] of matches) {
      val = val.replace(match, `${arg.replace("$", `'+${component}`)}+'`);
    }
  }
  return val;
};
var populateFields = (prop, val, component, target) => {
  if (val.startsWith("$")) {
    target[prop] = `${component}${val.replace("$", "")}`;
  } else {
    target[prop] = val;
  }
};
var interpolateObject = (input) => {
  const interpolatedResults = [];
  Object.keys(input).forEach((key) => {
    interpolatedResults.push(`${key}: ${input[key]}`);
  });
  return ` { ${interpolatedResults.join(", ")} }`;
};

// node_modules/@lightningjs/blits/src/lib/componentId.js
var counters = {};
var counter2 = 0;
var createHumanReadableId = (name) => {
  return `BlitsComponent::${name}_${counters[name] = (counters[name] || 0) + 1}`;
};
var createInternalId = () => {
  return ++counter2;
};

// node_modules/@lightningjs/blits/src/lib/hooks.js
var cbs = {};
var emit = (hook, identifier, scope, data = []) => {
  cbs[identifier] && cbs[identifier][hook] && cbs[identifier][hook].apply(scope, data);
};
var privateEmit = (hook, identifier, scope) => {
  const symHook = symbols_default[hook];
  cbs[identifier] && cbs[identifier][symHook] && cbs[identifier][symHook].apply(scope);
};
var registerHooks = (hooks = {}, identifier) => {
  cbs[identifier] = {};
  const hookKeys = [...Object.keys(hooks), ...Object.getOwnPropertySymbols(hooks)];
  hookKeys.forEach((hook) => {
    if (typeof hooks[hook] === "function") cbs[identifier][hook] = hooks[hook];
  });
};

// node_modules/@lightningjs/blits/src/lib/reactivity/effect.js
var currentEffect = null;
var currentKey = null;
var paused = false;
var pauseTracking = () => {
  paused = true;
};
var resumeTracking = () => {
  paused = false;
};
var objectMap = /* @__PURE__ */ new WeakMap();
var globalEffectsMap = /* @__PURE__ */ new Map();
var removeGlobalEffects = (effectsToRemove) => {
  if (globalEffectsMap.size === 0) return;
  for (const [effect2, target] of globalEffectsMap) {
    if (effectsToRemove.indexOf(effect2) === -1) continue;
    const effectsSet = objectMap.get(target);
    if (effectsSet === void 0) continue;
    for (const set of effectsSet.values()) {
      set.delete(effect2);
      globalEffectsMap.delete(effect2);
    }
  }
};
var track = (target, key, global = false) => {
  if (currentEffect !== null) {
    if (paused) {
      return;
    }
    if (Array.isArray(currentKey) === true) {
      if (currentKey.includes(key) === false) return;
    } else if (currentKey !== null && key !== currentKey) return;
    let effectsMap = objectMap.get(target);
    if (effectsMap === void 0) {
      effectsMap = /* @__PURE__ */ new Map();
      objectMap.set(target, effectsMap);
    }
    let effects = effectsMap.get(key);
    if (effects === void 0) {
      effects = /* @__PURE__ */ new Set();
      effectsMap.set(key, effects);
    }
    effects.add(currentEffect);
    if (global === true) globalEffectsMap.set(currentEffect, target);
  }
};
var trigger = (target, key, force = false) => {
  if (paused === true) return;
  const effectsMap = objectMap.get(target);
  if (effectsMap === void 0) {
    return;
  }
  const effects = effectsMap.get(key);
  if (effects !== void 0) {
    for (let effect2 of effects) {
      effect2(force);
    }
  }
};
var effect = (effect2, key = null) => {
  currentEffect = effect2;
  currentKey = key;
  currentEffect();
  currentEffect = null;
  currentKey = null;
};

// node_modules/@lightningjs/blits/src/helpers/deepEqualArray.js
var deepEqualArray = (array1, array2) => {
  if (array1 === array2) return true;
  if (array1.length !== array2.length) return false;
  let l = array1.length;
  while (l--) {
    const value1 = array1[l];
    const value2 = array2[l];
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (deepEqualArray(value1, value2) === false) return false;
    } else if (typeof value1 === "object" && value1 !== null && typeof value2 === "object" && value2 !== null) {
      if (deepEqualArray(Object.entries(value1), Object.entries(value2)) === false) return false;
    } else if (value1 !== value2) {
      return false;
    }
  }
  return true;
};
var deepEqualArray_default = deepEqualArray;

// node_modules/@lightningjs/blits/src/lib/reactivity/reactive.js
var arrayPatchMethods = ["push", "pop", "shift", "unshift", "splice", "sort"];
var proxyMap = /* @__PURE__ */ new WeakMap();
var getRaw = (value) => {
  const raw = value && value[symbols_default.raw];
  return raw ? getRaw(raw) : value;
};
var reactiveProxy = (original, _parent = null, _key, global) => {
  if (typeof original === "object" && Array.isArray(original) === false && Object.getPrototypeOf(original) !== Object.prototype) {
    return original;
  }
  const existingProxy = proxyMap.get(original);
  if (existingProxy !== void 0) {
    return existingProxy;
  }
  const handler = {
    get(target, key, receiver) {
      if (key === symbols_default.isProxy) {
        return true;
      }
      if (key === symbols_default.raw) {
        return original;
      }
      if (Array.isArray(target) === true) {
        if (typeof target[key] === "object" && target[key] !== null) {
          if (Array.isArray(target[key]) === true) {
            track(target, key, global);
          }
          return reactiveProxy(getRaw(target[key]), target, key, global);
        }
        if (arrayPatchMethods.indexOf(key) !== -1) {
          return function(...args) {
            pauseTracking();
            const result = target[key].apply(this, args);
            resumeTracking();
            trigger(_parent, _key);
            return result;
          };
        }
        if (key === "length") {
          return original.length;
        }
        return Reflect.get(target, key, receiver);
      }
      if (typeof target[key] === "object" && target[key] !== null) {
        if (Array.isArray(target[key]) === true) {
          track(target, key, global);
        }
        return reactiveProxy(getRaw(target[key]), target, key, global);
      }
      track(target, key, global);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      const oldRawValue = getRaw(target[key]);
      const rawValue = getRaw(value);
      let result = true;
      let isEqual = false;
      if (Array.isArray(rawValue) === true && Array.isArray(oldRawValue) === true) {
        isEqual = deepEqualArray_default(oldRawValue, rawValue);
      } else if (oldRawValue === rawValue) {
        isEqual = true;
      }
      if (isEqual === false) {
        if (typeof value === "object") {
          if (Array.isArray(value) === true) {
            value = getRaw(value).slice(0);
          } else if (value !== null && target[key] !== null && target[key] !== void 0 && Array.isArray(target) === false && Object.getPrototypeOf(value) === Object.prototype) {
            value = Object.assign(receiver[key], value);
          }
        }
        result = Reflect.set(target, key, value, receiver);
      }
      if (result === true && isEqual === false) {
        if (Array.isArray(target) === true && key in target === true) {
          trigger(_parent, _key, true);
        }
        trigger(target, key, true);
      }
      return result;
    }
  };
  const proxy = new Proxy(original, handler);
  proxyMap.set(original, proxy);
  return proxy;
};
var reactiveDefineProperty = (target, global) => {
  Object.keys(target).forEach((key) => {
    let internalValue = target[key];
    if (target[key] !== null && typeof target[key] === "object") {
      if (Object.getPrototypeOf(target[key]) === Object.prototype) {
        return reactiveDefineProperty(target[key]);
      } else if (Array.isArray(target[key]) === true) {
        for (let i = 0; i < arrayPatchMethods.length; i++) {
          target[key][arrayPatchMethods[i]] = function(v) {
            Array.prototype[arrayPatchMethods[i]].call(this, v);
            trigger(target, key);
          };
        }
      }
    }
    Object.defineProperty(target, key, {
      enumerable: true,
      configurable: true,
      get() {
        track(target, key, global);
        return internalValue;
      },
      set(newValue) {
        let oldValue = internalValue;
        if (oldValue !== newValue) {
          internalValue = newValue;
          trigger(target, key);
        }
      }
    });
  });
  return target;
};
var hasProxySupport = typeof Proxy !== "undefined";
var reactive = (target, mode = "Proxy", global = false) => {
  if (hasProxySupport === false) {
    mode = "defineProperty";
  }
  return mode === "defineProperty" ? reactiveDefineProperty(target, global) : reactiveProxy(target, void 0, void 0, global);
};

// node_modules/@lightningjs/blits/src/lib/lifecycle.js
var states = [
  "init",
  // fired upon component instantiation
  "ready",
  // fired when component instantiated, reactivity setup done and template spawned
  "focus",
  // fired when receiving focus (can occur multiple times)
  "unfocus",
  // fired when losing focus (can occur multiple times)
  "destroy",
  // fired when component is destroyed and removed
  "attach",
  // fired when entering the viewport margin and attached to the render tree
  "detach",
  // fired when leaving the viewport margin and detached from the render tree
  "enter",
  // fired when entering the visible viewport
  "exit"
  // fired when leaving the visible viewport
];
var lifecycle_default = {
  previous: null,
  current: null,
  /**
   * Gets the current lifecycle state.
   * @this {Lifecycle & {component: Object}}
   * @returns {string|null}
   */
  get state() {
    return this.current;
  },
  /**
   * Sets the lifecycle state and emits hooks if the state is valid and changed.
   * @this {Lifecycle & {component: Object}}
   * @param {string} v - The new lifecycle state.
   */
  set state(v) {
    if (states.indexOf(v) > -1 && v !== this.current || v === "refocus") {
      Log.debug(
        `Setting lifecycle state from ${this.current} to ${v} for ${this.component.componentId}`
      );
      this.previous = this.current;
      this.current = v;
      if (v === "refocus") return;
      privateEmit(v, this.component[symbols_default.identifier], this.component);
      emit(v, this.component[symbols_default.identifier], this.component);
      if (v === "focus") this.component[symbols_default.state].hasFocus = true;
      if (v === "unfocus") this.component[symbols_default.state].hasFocus = false;
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/utils.js
function createWebGLContext(canvas, forceWebGL2 = false, contextSpy) {
  const config = {
    alpha: true,
    antialias: false,
    depth: false,
    stencil: true,
    desynchronized: false,
    // Disabled because it prevents Visual Regression Tests from working
    // failIfMajorPerformanceCaveat: true,
    powerPreference: "high-performance",
    premultipliedAlpha: true,
    preserveDrawingBuffer: false
  };
  const gl = (
    // TODO: Remove this assertion once this issue is fixed in TypeScript
    // https://github.com/microsoft/TypeScript/issues/53614
    canvas.getContext(forceWebGL2 ? "webgl2" : "webgl", config) || canvas.getContext("experimental-webgl", config)
  );
  if (!gl) {
    throw new Error("Unable to create WebGL context");
  }
  if (contextSpy) {
    return new Proxy(gl, {
      get(target, prop) {
        const value = target[prop];
        if (typeof value === "function") {
          contextSpy.increment(String(prop));
          return value.bind(target);
        }
        return value;
      }
    });
  }
  return gl;
}
function assertTruthy(condition, message) {
  if (isProductionEnvironment)
    return;
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function mergeColorProgress(rgba1, rgba2, p) {
  const r1 = Math.trunc(rgba1 >>> 24);
  const g1 = Math.trunc(rgba1 >>> 16 & 255);
  const b1 = Math.trunc(rgba1 >>> 8 & 255);
  const a1 = Math.trunc(rgba1 & 255);
  const r2 = Math.trunc(rgba2 >>> 24);
  const g2 = Math.trunc(rgba2 >>> 16 & 255);
  const b2 = Math.trunc(rgba2 >>> 8 & 255);
  const a2 = Math.trunc(rgba2 & 255);
  const r = Math.round(r2 * p + r1 * (1 - p));
  const g = Math.round(g2 * p + g1 * (1 - p));
  const b = Math.round(b2 * p + b1 * (1 - p));
  const a = Math.round(a2 * p + a1 * (1 - p));
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
function mergeColorAlpha(rgba2, alpha) {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = Math.trunc((rgba2 & 255) * alpha);
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
var premultiplyRGB = true;
function setPremultiplyMode(mode) {
  premultiplyRGB = mode === "webgl";
}
function mergeColorAlphaPremultiplied(rgba2, alpha, flipEndianess = false) {
  const newAlpha = (rgba2 & 255) / 255 * alpha;
  const rgbAlpha = premultiplyRGB ? newAlpha : 1;
  const r = Math.trunc((rgba2 >>> 24) * rgbAlpha);
  const g = Math.trunc((rgba2 >>> 16 & 255) * rgbAlpha);
  const b = Math.trunc((rgba2 >>> 8 & 255) * rgbAlpha);
  const a = Math.trunc(newAlpha * 255);
  if (flipEndianess) {
    return (a << 24 | b << 16 | g << 8 | r) >>> 0;
  }
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isProductionEnvironment = typeof __DEV__ !== "undefined" ? !__DEV__ : true;
var nextId = 1;
function getNewId() {
  return nextId++;
}

// node_modules/@lightningjs/renderer/dist/src/common/EventEmitter.js
var EventEmitter = class {
  constructor() {
    __publicField(this, "eventListeners", {});
  }
  on(event, listener) {
    let listeners = this.eventListeners[event];
    if (!listeners) {
      listeners = [];
    }
    listeners.push(listener);
    this.eventListeners[event] = listeners;
  }
  off(event, listener) {
    const listeners = this.eventListeners[event];
    if (!listeners) {
      return;
    }
    if (!listener) {
      delete this.eventListeners[event];
      return;
    }
    const index = listeners.indexOf(listener);
    if (index >= 0) {
      listeners.splice(index, 1);
    }
  }
  once(event, listener) {
    const onceListener = (target, data) => {
      this.off(event, onceListener);
      listener(target, data);
    };
    this.on(event, onceListener);
  }
  emit(event, data) {
    const listeners = this.eventListeners[event];
    if (!listeners) {
      return;
    }
    [...listeners].forEach((listener) => {
      listener(this, data);
    });
  }
  removeAllListeners() {
    this.eventListeners = {};
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/textures/Texture.js
var TextureType;
(function(TextureType2) {
  TextureType2[TextureType2["generic"] = 0] = "generic";
  TextureType2[TextureType2["color"] = 1] = "color";
  TextureType2[TextureType2["image"] = 2] = "image";
  TextureType2[TextureType2["noise"] = 3] = "noise";
  TextureType2[TextureType2["renderToTexture"] = 4] = "renderToTexture";
  TextureType2[TextureType2["subTexture"] = 5] = "subTexture";
})(TextureType || (TextureType = {}));
var _Texture = class _Texture extends EventEmitter {
  // 2 seconds
  constructor(txManager) {
    super();
    __publicField(this, "txManager");
    /**
     * The dimensions of the texture
     *
     * @remarks
     * Until the texture data is loaded for the first time the value will be
     * `null`.
     */
    __publicField(this, "_dimensions", null);
    __publicField(this, "_error", null);
    // aggregate state
    __publicField(this, "state", "initial");
    __publicField(this, "renderableOwners", []);
    __publicField(this, "renderable", false);
    __publicField(this, "type", TextureType.generic);
    __publicField(this, "preventCleanup", false);
    __publicField(this, "ctxTexture");
    __publicField(this, "textureData", null);
    /**
     * Memory used by this texture in bytes
     *
     * @remarks
     * This is tracked by the TextureMemoryManager and updated when the texture
     * is loaded/freed. Set to 0 when texture is not loaded.
     */
    __publicField(this, "memUsed", 0);
    __publicField(this, "retryCount", 0);
    __publicField(this, "maxRetryCount");
    /**
     * Timestamp when texture was created (for startup grace period)
     */
    __publicField(this, "createdAt", Date.now());
    /**
     * Flag to track if grace period has expired to avoid repeated Date.now() calls
     */
    __publicField(this, "gracePeriodExpired", false);
    this.txManager = txManager;
    this.maxRetryCount = txManager.maxRetryCount;
  }
  get dimensions() {
    return this._dimensions;
  }
  get error() {
    return this._error;
  }
  /**
   * Checks if the texture is within the startup grace period.
   * During this period, textures are protected from cleanup to prevent
   * race conditions during app initialization.
   */
  isWithinStartupGracePeriod() {
    if (this.gracePeriodExpired) {
      return false;
    }
    const hasExpired = Date.now() - this.createdAt >= _Texture.STARTUP_GRACE_PERIOD;
    if (hasExpired) {
      this.gracePeriodExpired = true;
      return false;
    }
    return true;
  }
  /**
   * Checks if the texture can be safely cleaned up.
   * Considers the renderable state, startup grace period, and renderable owners.
   */
  canBeCleanedUp() {
    if (this.preventCleanup) {
      return false;
    }
    if (this.isWithinStartupGracePeriod()) {
      return false;
    }
    if (this.renderable === true) {
      return false;
    }
    if (this.renderableOwners.length > 0) {
      return false;
    }
    return true;
  }
  /**
   * Add/remove an owner to/from the Texture based on its renderability.
   *
   * @remarks
   * Any object can own a texture, be it a CoreNode or even the state object
   * from a Text Renderer.
   *
   * When the reference to the texture that an owner object holds is replaced
   * or cleared it must call this with `renderable=false` to release the owner
   * association.
   *
   * @param owner
   * @param renderable
   */
  setRenderableOwner(owner, renderable) {
    var _a2, _b;
    const oldSize = this.renderableOwners.length;
    const hasOwnerIndex = this.renderableOwners.indexOf(owner);
    if (renderable === true) {
      if (hasOwnerIndex === -1) {
        this.renderableOwners.push(owner);
      }
      const newSize = this.renderableOwners.length;
      if (oldSize !== newSize && newSize === 1) {
        this.renderable = true;
        (_a2 = this.onChangeIsRenderable) == null ? void 0 : _a2.call(this, true);
        this.load();
      }
    } else {
      if (hasOwnerIndex !== -1) {
        this.renderableOwners.splice(hasOwnerIndex, 1);
      }
      const newSize = this.renderableOwners.length;
      if (oldSize !== newSize && newSize === 0) {
        this.renderable = false;
        (_b = this.onChangeIsRenderable) == null ? void 0 : _b.call(this, false);
      }
    }
  }
  load() {
    if (this.retryCount > this.maxRetryCount) {
      return;
    }
    this.txManager.loadTexture(this);
  }
  /**
   * Load the core context texture for this Texture.
   * The ctxTexture is created by the renderer and lives on the GPU.
   *
   * @returns
   */
  loadCtxTexture() {
    if (this.ctxTexture === void 0) {
      this.ctxTexture = this.txManager.renderer.createCtxTexture(this);
    }
    return this.ctxTexture;
  }
  /**
   * Free the core context texture for this Texture.
   *
   * @remarks
   * The ctxTexture is created by the renderer and lives on the GPU.
   */
  free() {
    var _a2;
    (_a2 = this.ctxTexture) == null ? void 0 : _a2.free();
  }
  /**
   * Release the texture data and core context texture for this Texture without changing state.
   *
   * @remarks
   * The ctxTexture is created by the renderer and lives on the GPU.
   */
  release() {
    var _a2;
    (_a2 = this.ctxTexture) == null ? void 0 : _a2.release();
    this.ctxTexture = void 0;
    this.freeTextureData();
  }
  /**
   * Destroy the texture.
   *
   * @remarks
   * This method is called when the texture is no longer needed and should be
   * cleaned up.
   */
  destroy() {
    if (this.state === "loaded") {
      this.free();
    }
    this.freeTextureData();
  }
  /**
   * Free the source texture data for this Texture.
   *
   * @remarks
   * The texture data is the source data that is used to populate the CoreContextTexture.
   * e.g. ImageData that is downloaded from a URL.
   */
  freeTextureData() {
    queueMicrotask(() => {
      this.textureData = null;
    });
  }
  setState(state2, errorOrDimensions) {
    if (this.state === state2) {
      return;
    }
    let payload = null;
    if (state2 === "loaded") {
      this._error = null;
      if (errorOrDimensions !== void 0 && "width" in errorOrDimensions === true && "height" in errorOrDimensions === true && errorOrDimensions.width !== void 0 && errorOrDimensions.height !== void 0) {
        this._dimensions = errorOrDimensions;
      }
      payload = this._dimensions;
    } else if (state2 === "failed") {
      this._error = errorOrDimensions;
      payload = this._error;
      this.retryCount += 1;
      queueMicrotask(() => {
        this.release();
      });
    } else if (state2 === "loading") {
      this._error = null;
      this._dimensions = null;
    } else {
      this._error = null;
    }
    this.state = state2;
    this.emit(state2, payload);
  }
  /**
   * Get the texture data for this texture.
   *
   * @remarks
   * This method is called by the CoreContextTexture when the texture is loaded.
   * The texture data is then used to populate the CoreContextTexture.
   *
   * @returns
   * The texture data for this texture.
   */
  async getTextureData() {
    if (this.textureData === null) {
      this.textureData = await this.getTextureSource();
    }
    return this.textureData;
  }
  /**
   * Make a cache key for this texture.
   *
   * @remarks
   * Each concrete `Texture` subclass must implement this method to provide an
   * appropriate cache key for the texture type including the texture's
   * properties that uniquely identify a copy of the texture. If the texture
   * type does not support caching, then this method should return `false`.
   *
   * @param props
   * @returns
   * A cache key for this texture or `false` if the texture type does not
   * support caching.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static makeCacheKey(props) {
    return false;
  }
  /**
   * Resolve the default values for the texture's properties.
   *
   * @remarks
   * Each concrete `Texture` subclass must implement this method to provide
   * default values for the texture's optional properties.
   *
   * @param props
   * @returns
   * The default values for the texture's properties.
   */
  static resolveDefaults(props) {
    return {};
  }
  /**
   * Retry the texture by resetting retryCount and setting state to 'initial'.
   *
   * @remarks
   * This allows the texture to be loaded again.
   */
  retry() {
    this.release();
    this.retryCount = 0;
    this.load();
  }
};
/**
 * Grace period in milliseconds to prevent premature cleanup during app startup
 * This helps prevent race conditions when bounds calculation is delayed
 */
__publicField(_Texture, "STARTUP_GRACE_PERIOD", 2e3);
var Texture = _Texture;

// node_modules/@lightningjs/renderer/dist/src/core/lib/utils.js
var PROTOCOL_REGEX = /^(data|ftps?|https?):/;
var getNormalizedRgbaComponents = (rgba2) => {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = rgba2 & 255;
  return [r / 255, g / 255, b / 255, a / 255];
};
var getRgbaComponents = (rgba2) => {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = rgba2 & 255;
  return [r, g, b, a];
};
function getNormalizedAlphaComponent(rgba2) {
  return (rgba2 & 255) / 255;
}
function getRgbaString(color) {
  const r = Math.floor(color[0] * 255);
  const g = Math.floor(color[1] * 255);
  const b = Math.floor(color[2] * 255);
  const a = Math.floor(color[3] * 255);
  return `rgba(${r},${g},${b},${a.toFixed(4)})`;
}
function createBound(x1, y1, x2, y2, out) {
  if (out) {
    out.x1 = x1;
    out.y1 = y1;
    out.x2 = x2;
    out.y2 = y2;
    return out;
  }
  return {
    x1,
    y1,
    x2,
    y2
  };
}
function boundsOverlap(a, b) {
  return a.x1 < b.x2 && a.x2 > b.x1 && a.y1 < b.y2 && a.y2 > b.y1;
}
function convertBoundToRect(bound, out) {
  if (out) {
    out.x = bound.x1;
    out.y = bound.y1;
    out.width = bound.x2 - bound.x1;
    out.height = bound.y2 - bound.y1;
    return out;
  }
  return {
    x: bound.x1,
    y: bound.y1,
    width: bound.x2 - bound.x1,
    height: bound.y2 - bound.y1
  };
}
function intersectRect(a, b, out) {
  const x = Math.max(a.x, b.x);
  const y = Math.max(a.y, b.y);
  const width = Math.min(a.x + a.width, b.x + b.width) - x;
  const height = Math.min(a.y + a.height, b.y + b.height) - y;
  if (width > 0 && height > 0) {
    if (out) {
      out.x = x;
      out.y = y;
      out.width = width;
      out.height = height;
      return out;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
  if (out) {
    out.x = 0;
    out.y = 0;
    out.width = 0;
    out.height = 0;
    return out;
  }
  return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
}
function copyRect(a, out) {
  if (out) {
    out.x = a.x;
    out.y = a.y;
    out.width = a.width;
    out.height = a.height;
    return out;
  }
  return {
    x: a.x,
    y: a.y,
    width: a.width,
    height: a.height
  };
}
function compareRect(a, b) {
  if (a === b) {
    return true;
  }
  if (a === null || b === null) {
    return false;
  }
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function boundInsideBound(bound1, bound2) {
  return bound1.x1 <= bound2.x2 && bound1.y1 <= bound2.y2 && bound1.x2 >= bound2.x1 && bound1.y2 >= bound2.y1;
}
function boundLargeThanBound(bound1, bound2) {
  return bound1.x1 < bound2.x1 && bound1.x2 > bound2.x2 && bound1.y1 < bound2.y1 && bound1.y2 > bound2.y2;
}
function pointInBound(x, y, bound) {
  return !(x < bound.x1 || x > bound.x2 || y < bound.y1 || y > bound.y2);
}
function isBoundPositive(bound) {
  return bound.x1 < bound.x2 && bound.y1 < bound.y2;
}
function createPreloadBounds(strictBound, boundsMargin) {
  return createBound(strictBound.x1 - boundsMargin[3], strictBound.y1 - boundsMargin[0], strictBound.x2 + boundsMargin[1], strictBound.y2 + boundsMargin[2]);
}
function convertUrlToAbsolute(url) {
  if (self.location.protocol === "file:" && !PROTOCOL_REGEX.test(url)) {
    const path = self.location.pathname.split("/");
    path.pop();
    const basePath = path.join("/");
    const baseUrl = self.location.protocol + "//" + basePath;
    if (url.charAt(0) === ".") {
      url = url.slice(1);
    }
    if (url.charAt(0) === "/") {
      url = url.slice(1);
    }
    return baseUrl + "/" + url;
  }
  const absoluteUrl = new URL(url, self.location.href);
  return absoluteUrl.href;
}
function isBase64Image(src) {
  return src.startsWith("data:") === true;
}
function dataURIToBlob(dataURI) {
  var _a2, _b;
  dataURI = dataURI.replace(/^data:/, "");
  const type = ((_a2 = dataURI.match(/image\/[^;]+/)) == null ? void 0 : _a2[0]) || "";
  const base64 = dataURI.replace(/^[^,]+,/, "");
  const sliceSize = 1024;
  const byteCharacters = atob(base64);
  const bytesLength = byteCharacters.length;
  const slicesCount = Math.ceil(bytesLength / sliceSize);
  const byteArrays = new Array(slicesCount);
  for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
    const begin = sliceIndex * sliceSize;
    const end = Math.min(begin + sliceSize, bytesLength);
    const bytes = new Array(end - begin);
    for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
      bytes[i] = (_b = byteCharacters[offset]) == null ? void 0 : _b.charCodeAt(0);
    }
    byteArrays[sliceIndex] = new Uint8Array(bytes);
  }
  return new Blob(byteArrays, { type });
}

// node_modules/@lightningjs/renderer/dist/src/core/lib/Matrix3d.js
var Matrix3d = class _Matrix3d {
  /**
   * Creates a new 3x3 matrix.
   *
   * @param entries Row-major 3x3 matrix
   */
  constructor() {
    __publicField(this, "ta");
    __publicField(this, "tb");
    __publicField(this, "tx");
    __publicField(this, "tc");
    __publicField(this, "td");
    __publicField(this, "ty");
    __publicField(this, "_floatArr", null);
    /**
     * Potential Mutation Flag
     *
     * @remarks
     * This flag is set to true whenever the matrix is potentially modified.
     * We don't waste CPU trying to identify if each operation actually modifies
     * the matrix. Instead, we set this flag to true whenever we think the matrix
     * is modified. This signals that the `floatArr` should to be updated.
     */
    __publicField(this, "mutation");
    this.ta = 0;
    this.tb = 0;
    this.tx = 0;
    this.tc = 0;
    this.td = 0;
    this.ty = 0;
    this.mutation = true;
  }
  /**
   * Returns a temporary matrix that can be used for calculations.
   *
   * @remarks
   * This is useful for avoiding allocations in tight loops.
   *
   * The matrix is not guaranteed to be the same between calls.
   *
   * @returns
   */
  static get temp() {
    return tempMatrix;
  }
  static multiply(a, b, out) {
    const e0 = a.ta * b.ta + a.tb * b.tc;
    const e1 = a.ta * b.tb + a.tb * b.td;
    const e2 = a.ta * b.tx + a.tb * b.ty + a.tx;
    const e3 = a.tc * b.ta + a.td * b.tc;
    const e4 = a.tc * b.tb + a.td * b.td;
    const e5 = a.tc * b.tx + a.td * b.ty + a.ty;
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = e0;
    out.tb = e1;
    out.tx = e2;
    out.tc = e3;
    out.td = e4;
    out.ty = e5;
    out.mutation = true;
    return out;
  }
  static identity(out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = 1;
    out.tb = 0;
    out.tx = 0;
    out.tc = 0;
    out.td = 1;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static translate(x, y, out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = 1;
    out.tb = 0;
    out.tx = x;
    out.tc = 0;
    out.td = 1;
    out.ty = y;
    out.mutation = true;
    return out;
  }
  static scale(sx, sy, out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = sx;
    out.tb = 0;
    out.tx = 0;
    out.tc = 0;
    out.td = sy;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static rotate(angle, out) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = cos;
    out.tb = -sin;
    out.tx = 0;
    out.tc = sin;
    out.td = cos;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static copy(src, dst) {
    if (!dst) {
      dst = new _Matrix3d();
    }
    dst.ta = src.ta;
    dst.tc = src.tc;
    dst.tb = src.tb;
    dst.td = src.td;
    dst.tx = src.tx;
    dst.ty = src.ty;
    dst.mutation = true;
    return dst;
  }
  translate(x, y) {
    this.tx = this.ta * x + this.tb * y + this.tx;
    this.ty = this.tc * x + this.td * y + this.ty;
    this.mutation = true;
    return this;
  }
  scale(sx, sy) {
    this.ta = this.ta * sx;
    this.tb = this.tb * sy;
    this.tc = this.tc * sx;
    this.td = this.td * sy;
    this.mutation = true;
    return this;
  }
  rotate(angle) {
    if (angle === 0 || !(angle % Math.PI * 2)) {
      return this;
    }
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const e0 = this.ta * cos + this.tb * sin;
    const e1 = this.tb * cos - this.ta * sin;
    const e3 = this.tc * cos + this.td * sin;
    const e4 = this.td * cos - this.tc * sin;
    this.ta = e0;
    this.tb = e1;
    this.tc = e3;
    this.td = e4;
    this.mutation = true;
    return this;
  }
  multiply(other) {
    return _Matrix3d.multiply(this, other, this);
  }
  /**
   * Returns the matrix as a Float32Array in column-major order.
   *
   * @remarks
   * This method is optimized to avoid unnecessary allocations. The same array
   * is returned every time this method is called, and is updated in place.
   *
   * WARNING: Use the array only for passing directly to a WebGL shader uniform
   * during a frame render. Do not modify or hold onto the array for longer than
   * a frame.
   */
  getFloatArr() {
    if (!this._floatArr) {
      this._floatArr = new Float32Array(9);
    }
    if (this.mutation) {
      this._floatArr[0] = this.ta;
      this._floatArr[1] = this.tc;
      this._floatArr[2] = 0;
      this._floatArr[3] = this.tb;
      this._floatArr[4] = this.td;
      this._floatArr[5] = 0;
      this._floatArr[6] = this.tx;
      this._floatArr[7] = this.ty;
      this._floatArr[8] = 1;
      this.mutation = false;
    }
    return this._floatArr;
  }
};
var tempMatrix = new Matrix3d();

// node_modules/@lightningjs/renderer/dist/src/core/lib/RenderCoords.js
var rx1 = 0;
var rx2 = 2;
var rx3 = 4;
var rx4 = 6;
var ry1 = 1;
var ry2 = 3;
var ry3 = 5;
var ry4 = 7;
var RenderCoords = class _RenderCoords {
  constructor(entries) {
    __publicField(this, "data");
    this.data = new Float32Array(8);
    if (entries) {
      this.data[rx1] = entries[rx1];
      this.data[rx2] = entries[rx2];
      this.data[rx3] = entries[rx3];
      this.data[rx4] = entries[rx4];
      this.data[ry1] = entries[ry1];
      this.data[ry2] = entries[ry2];
      this.data[ry3] = entries[ry3];
      this.data[ry4] = entries[ry4];
    }
  }
  static translate(x1, y1, x2, y2, x3, y3, x4, y4, out) {
    if (!out) {
      out = new _RenderCoords();
    }
    out.data[rx1] = x1;
    out.data[rx2] = x2;
    out.data[rx3] = x3;
    out.data[rx4] = x4;
    out.data[ry1] = y1;
    out.data[ry2] = y2;
    out.data[ry3] = y3;
    out.data[ry4] = y4;
    return out;
  }
  get x1() {
    return this.data[rx1];
  }
  get x2() {
    return this.data[rx2];
  }
  get x3() {
    return this.data[rx3];
  }
  get x4() {
    return this.data[rx4];
  }
  get y1() {
    return this.data[ry1];
  }
  get y2() {
    return this.data[ry2];
  }
  get y3() {
    return this.data[ry3];
  }
  get y4() {
    return this.data[ry4];
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/utils.js
var degree = Math.PI / 180;
var getTimingBezier = (a, b, c, d) => {
  const xc = 3 * a;
  const xb = 3 * (c - a) - xc;
  const xa = 1 - xc - xb;
  const yc = 3 * b;
  const yb = 3 * (d - b) - yc;
  const ya = 1 - yc - yb;
  return function(time2) {
    if (time2 >= 1) {
      return 1;
    }
    if (time2 <= 0) {
      return 0;
    }
    let t = 0.5, cbx, cbxd, dx;
    for (let it = 0; it < 20; it++) {
      cbx = t * (t * (t * xa + xb) + xc);
      dx = time2 - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc);
      }
      cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
      if (cbxd > 1e-10 && cbxd < 1e-10) {
        break;
      }
      t += dx / cbxd;
    }
    let minT = 0;
    let maxT = 1;
    for (let it = 0; it < 20; it++) {
      t = 0.5 * (minT + maxT);
      cbx = t * (t * (t * xa + xb) + xc);
      dx = time2 - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc);
      }
      if (dx < 0) {
        maxT = t;
      } else {
        minT = t;
      }
    }
  };
};
var timingMapping = {};
var timingLookup = {
  ease: [0.25, 0.1, 0.25, 1],
  "ease-in": [0.42, 0, 1, 1],
  "ease-out": [0, 0, 0.58, 1],
  "ease-in-out": [0.42, 0, 0.58, 1],
  "ease-in-sine": [0.12, 0, 0.39, 0],
  "ease-out-sine": [0.12, 0, 0.39, 0],
  "ease-in-out-sine": [0.37, 0, 0.63, 1],
  "ease-in-cubic": [0.32, 0, 0.67, 0],
  "ease-out-cubic": [0.33, 1, 0.68, 1],
  "ease-in-out-cubic": [0.65, 0, 0.35, 1],
  "ease-in-circ": [0.55, 0, 1, 0.45],
  "ease-out-circ": [0, 0.55, 0.45, 1],
  "ease-in-out-circ": [0.85, 0, 0.15, 1],
  "ease-in-back": [0.36, 0, 0.66, -0.56],
  "ease-out-back": [0.34, 1.56, 0.64, 1],
  "ease-in-out-back": [0.68, -0.6, 0.32, 1.6]
};
var defaultTiming = (t) => t;
var parseCubicBezier = (str) => {
  const regex = /-?\d*\.?\d+/g;
  const match = str.match(regex);
  if (match) {
    const [num1, num2, num3, num4] = match;
    const a = parseFloat(num1 || "0.42");
    const b = parseFloat(num2 || "0");
    const c = parseFloat(num3 || "1");
    const d = parseFloat(num4 || "1");
    const timing = getTimingBezier(a, b, c, d);
    timingMapping[str] = timing;
    return timing;
  }
  console.warn("Unknown cubic-bezier timing: " + str);
  return defaultTiming;
};
var getTimingFunction = (str) => {
  if (str === "linear") {
    return defaultTiming;
  }
  if (timingMapping[str] !== void 0) {
    return timingMapping[str] || defaultTiming;
  }
  if (str === "step-start") {
    return () => {
      return 1;
    };
  }
  if (str === "step-end") {
    return (time2) => {
      return time2 === 1 ? 1 : 0;
    };
  }
  const lookup = timingLookup[str];
  if (lookup !== void 0) {
    const [a, b, c, d] = lookup;
    const timing = getTimingBezier(a, b, c, d);
    timingMapping[str] = timing;
    return timing;
  }
  if (str.startsWith("cubic-bezier")) {
    return parseCubicBezier(str);
  }
  console.warn("Unknown timing function: " + str);
  return defaultTiming;
};
function bytesToMb(bytes) {
  return (bytes / 1024 / 1024).toFixed(2);
}

// node_modules/@lightningjs/renderer/dist/src/core/animations/CoreAnimation.js
var CoreAnimation = class extends EventEmitter {
  constructor(node, props, settings2) {
    super();
    __publicField(this, "node");
    __publicField(this, "props");
    __publicField(this, "settings");
    __publicField(this, "progress", 0);
    __publicField(this, "delayFor", 0);
    __publicField(this, "delay", 0);
    __publicField(this, "timingFunction");
    __publicField(this, "propValuesMap", {});
    __publicField(this, "dynPropValuesMap");
    this.node = node;
    this.props = props;
    for (const key in props) {
      if (key !== "shaderProps") {
        if (this.propValuesMap["props"] === void 0) {
          this.propValuesMap["props"] = {};
        }
        this.propValuesMap["props"][key] = {
          start: node[key] || 0,
          target: props[key]
        };
      } else if (node.shader.type !== "DynamicShader") {
        this.propValuesMap["shaderProps"] = {};
        for (const key2 in props.shaderProps) {
          this.propValuesMap["shaderProps"][key2] = {
            start: node.shader.props[key2],
            target: props.shaderProps[key2]
          };
        }
      } else {
        const shaderPropKeys = Object.keys(props.shaderProps);
        const spLength = shaderPropKeys.length;
        this.dynPropValuesMap = {};
        for (let j = 0; j < spLength; j++) {
          const effectName = shaderPropKeys[j];
          const effect2 = props.shaderProps[effectName];
          this.dynPropValuesMap[effectName] = {};
          const effectProps = Object.entries(effect2);
          const eLength = effectProps.length;
          for (let k = 0; k < eLength; k++) {
            const [key2, value] = effectProps[k];
            this.dynPropValuesMap[effectName][key2] = {
              start: node.shader.props[effectName][key2],
              target: value
            };
          }
        }
      }
    }
    const easing = settings2.easing || "linear";
    const delay = settings2.delay ?? 0;
    this.settings = {
      duration: settings2.duration ?? 0,
      delay,
      easing,
      loop: settings2.loop ?? false,
      repeat: settings2.repeat ?? 0,
      repeatDelay: settings2.repeatDelay ?? 0,
      stopMethod: settings2.stopMethod ?? false
    };
    this.timingFunction = getTimingFunction(easing);
    this.delayFor = delay;
    this.delay = delay;
  }
  reset() {
    this.progress = 0;
    this.delayFor = this.settings.delay || 0;
    this.update(0);
  }
  restoreValues(target, valueMap) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      target[key] = value.start;
    }
  }
  restore() {
    this.reset();
    if (this.propValuesMap["props"] !== void 0) {
      this.restoreValues(this.node, this.propValuesMap["props"]);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.restoreValues(this.node.shader.props, this.propValuesMap["shaderProps"]);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.restoreValues(this.node.shader.props[key], this.dynPropValuesMap[key]);
        }
      }
    }
  }
  reverseValues(valueMap) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      valueMap[key] = {
        start: value.target,
        target: value.start
      };
    }
  }
  reverse() {
    this.progress = 0;
    if (this.propValuesMap["props"] !== void 0) {
      this.reverseValues(this.propValuesMap["props"]);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.reverseValues(this.propValuesMap["shaderProps"]);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.reverseValues(this.dynPropValuesMap[key]);
        }
      }
    }
    if (!this.settings.loop) {
      this.settings.stopMethod = false;
    }
  }
  applyEasing(p, s, e) {
    return (this.timingFunction(p) || p) * (e - s) + s;
  }
  updateValue(propName, propValue, startValue, easing) {
    if (this.progress === 1) {
      return propValue;
    }
    if (this.progress === 0) {
      return startValue;
    }
    const endValue = propValue;
    if (propName.indexOf("color") !== -1) {
      if (startValue === endValue) {
        return startValue;
      }
      if (easing) {
        const easingProgressValue = this.timingFunction(this.progress) || this.progress;
        return mergeColorProgress(startValue, endValue, easingProgressValue);
      }
      return mergeColorProgress(startValue, endValue, this.progress);
    }
    if (easing) {
      return this.applyEasing(this.progress, startValue, endValue);
    }
    return startValue + (endValue - startValue) * this.progress;
  }
  updateValues(target, valueMap, easing) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      target[key] = this.updateValue(key, value.target, value.start, easing);
    }
  }
  update(dt) {
    const { duration, loop, easing, stopMethod } = this.settings;
    const { delayFor } = this;
    if (this.node.destroyed) {
      this.emit("destroyed", {});
      return;
    }
    if (duration === 0 && delayFor === 0) {
      this.emit("finished", {});
      return;
    }
    if (this.delayFor > 0) {
      this.delayFor -= dt;
      if (this.delayFor >= 0) {
        return;
      } else {
        dt = -this.delayFor;
        this.delayFor = 0;
      }
    }
    if (duration === 0) {
      this.emit("finished", {});
      return;
    }
    if (this.progress === 0) {
      this.emit("animating", {});
    }
    this.progress += dt / duration;
    if (this.progress > 1) {
      this.progress = loop ? 0 : 1;
      this.delayFor = this.delay;
      if (stopMethod) {
        this.emit("finished", {});
        return;
      }
    }
    if (this.propValuesMap["props"] !== void 0) {
      this.updateValues(this.node, this.propValuesMap["props"], easing);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.updateValues(this.node.shader.props, this.propValuesMap["shaderProps"], easing);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.updateValues(this.node.shader.props[key], this.dynPropValuesMap[key], easing);
        }
      }
    }
    if (this.progress < 1) {
      this.emit("tick", { progress: this.progress });
    }
    if (this.progress === 1) {
      this.emit("finished", {});
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/animations/CoreAnimationController.js
var CoreAnimationController = class extends EventEmitter {
  constructor(manager, animation) {
    super();
    __publicField(this, "manager");
    __publicField(this, "animation");
    __publicField(this, "stoppedPromise");
    /**
     * If this is null, then the animation is in a finished / stopped state.
     */
    __publicField(this, "stoppedResolve", null);
    __publicField(this, "state");
    this.manager = manager;
    this.animation = animation;
    this.state = "stopped";
    this.stoppedPromise = Promise.resolve();
    this.onAnimating = this.onAnimating.bind(this);
    this.onFinished = this.onFinished.bind(this);
    this.onTick = this.onTick.bind(this);
    this.onDestroy = this.onDestroy.bind(this);
  }
  start() {
    if (this.state !== "running" && this.state !== "scheduled") {
      this.makeStoppedPromise();
      this.registerAnimation();
      this.state = "scheduled";
    }
    return this;
  }
  stop() {
    this.unregisterAnimation();
    if (this.stoppedResolve !== null) {
      this.stoppedResolve();
      this.stoppedResolve = null;
      this.emit("stopped", this);
    }
    this.animation.reset();
    this.state = "stopped";
    return this;
  }
  pause() {
    this.unregisterAnimation();
    this.state = "paused";
    return this;
  }
  restore() {
    this.stoppedResolve = null;
    this.animation.restore();
    return this;
  }
  waitUntilStopped() {
    return this.stoppedPromise;
  }
  registerAnimation() {
    this.animation.once("finished", this.onFinished);
    this.animation.on("animating", this.onAnimating);
    this.animation.on("tick", this.onTick);
    this.animation.on("destroyed", this.onDestroy);
    this.manager.registerAnimation(this.animation);
  }
  unregisterAnimation() {
    this.manager.unregisterAnimation(this.animation);
    this.animation.off("finished", this.onFinished);
    this.animation.off("animating", this.onAnimating);
    this.animation.off("tick", this.onTick);
    this.animation.off("destroy", this.onDestroy);
  }
  makeStoppedPromise() {
    if (this.stoppedResolve === null) {
      this.stoppedPromise = new Promise((resolve) => {
        this.stoppedResolve = resolve;
      });
    }
  }
  onDestroy() {
    this.unregisterAnimation();
    this.state = "stopped";
  }
  onFinished() {
    const { loop, stopMethod } = this.animation.settings;
    if (stopMethod === "reverse") {
      this.animation.once("finished", this.onFinished);
      this.animation.reverse();
      return;
    }
    if (loop) {
      return;
    }
    this.unregisterAnimation();
    if (this.stoppedResolve !== null) {
      this.stoppedResolve();
      this.stoppedResolve = null;
    }
    this.emit("stopped", this);
    this.state = "stopped";
  }
  onAnimating() {
    this.state = "running";
    this.emit("animating", this);
  }
  onTick(_animation, data) {
    this.emit("tick", data);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreNode.js
var CoreNodeRenderState;
(function(CoreNodeRenderState2) {
  CoreNodeRenderState2[CoreNodeRenderState2["Init"] = 0] = "Init";
  CoreNodeRenderState2[CoreNodeRenderState2["OutOfBounds"] = 2] = "OutOfBounds";
  CoreNodeRenderState2[CoreNodeRenderState2["InBounds"] = 4] = "InBounds";
  CoreNodeRenderState2[CoreNodeRenderState2["InViewport"] = 8] = "InViewport";
})(CoreNodeRenderState || (CoreNodeRenderState = {}));
var CoreNodeRenderStateMap = /* @__PURE__ */ new Map();
CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, "init");
CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, "outOfBounds");
CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, "inBounds");
CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, "inViewport");
var UpdateType;
(function(UpdateType2) {
  UpdateType2[UpdateType2["Children"] = 1] = "Children";
  UpdateType2[UpdateType2["ScaleRotate"] = 2] = "ScaleRotate";
  UpdateType2[UpdateType2["Local"] = 4] = "Local";
  UpdateType2[UpdateType2["Global"] = 8] = "Global";
  UpdateType2[UpdateType2["Clipping"] = 16] = "Clipping";
  UpdateType2[UpdateType2["CalculatedZIndex"] = 32] = "CalculatedZIndex";
  UpdateType2[UpdateType2["ZIndexSortedChildren"] = 64] = "ZIndexSortedChildren";
  UpdateType2[UpdateType2["PremultipliedColors"] = 128] = "PremultipliedColors";
  UpdateType2[UpdateType2["WorldAlpha"] = 256] = "WorldAlpha";
  UpdateType2[UpdateType2["RenderState"] = 512] = "RenderState";
  UpdateType2[UpdateType2["IsRenderable"] = 1024] = "IsRenderable";
  UpdateType2[UpdateType2["RenderTexture"] = 2048] = "RenderTexture";
  UpdateType2[UpdateType2["ParentRenderTexture"] = 4096] = "ParentRenderTexture";
  UpdateType2[UpdateType2["RenderBounds"] = 8192] = "RenderBounds";
  UpdateType2[UpdateType2["None"] = 0] = "None";
  UpdateType2[UpdateType2["All"] = 14335] = "All";
})(UpdateType || (UpdateType = {}));
var CoreNode = class extends EventEmitter {
  constructor(stage2, props) {
    super();
    __publicField(this, "stage");
    __publicField(this, "children", []);
    __publicField(this, "_id", getNewId());
    __publicField(this, "props");
    __publicField(this, "updateType", UpdateType.All);
    __publicField(this, "childUpdateType", UpdateType.None);
    __publicField(this, "globalTransform");
    __publicField(this, "scaleRotateTransform");
    __publicField(this, "localTransform");
    __publicField(this, "sceneGlobalTransform");
    __publicField(this, "renderCoords");
    __publicField(this, "sceneRenderCoords");
    __publicField(this, "renderBound");
    __publicField(this, "strictBound");
    __publicField(this, "preloadBound");
    __publicField(this, "clippingRect", {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      valid: false
    });
    __publicField(this, "isRenderable", false);
    __publicField(this, "renderState", CoreNodeRenderState.Init);
    __publicField(this, "worldAlpha", 1);
    __publicField(this, "premultipliedColorTl", 0);
    __publicField(this, "premultipliedColorTr", 0);
    __publicField(this, "premultipliedColorBl", 0);
    __publicField(this, "premultipliedColorBr", 0);
    __publicField(this, "calcZIndex", 0);
    __publicField(this, "hasRTTupdates", false);
    __publicField(this, "parentHasRenderTexture", false);
    __publicField(this, "rttParent", null);
    __publicField(this, "destroyed", false);
    __publicField(this, "onTextureLoaded", (_, dimensions) => {
      var _a2, _b;
      this.autosizeNode(dimensions);
      this.setUpdateType(UpdateType.IsRenderable);
      this.stage.requestRender();
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      if (dimensions.width > 1 && dimensions.height > 1) {
        this.emit("loaded", {
          type: "texture",
          dimensions
        });
      }
      if (((_b = (_a2 = this.props.textureOptions) == null ? void 0 : _a2.resizeMode) == null ? void 0 : _b.type) === "contain") {
        this.setUpdateType(UpdateType.Local);
      }
    });
    __publicField(this, "onTextureFailed", (_, error) => {
      this.isRenderable = false;
      this.updateTextureOwnership(false);
      this.setUpdateType(UpdateType.IsRenderable);
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      if (this.texture !== null && this.texture.retryCount > this.texture.maxRetryCount) {
        this.emit("failed", {
          type: "texture",
          error
        });
      }
    });
    __publicField(this, "onTextureFreed", () => {
      this.isRenderable = false;
      this.updateTextureOwnership(false);
      this.setUpdateType(UpdateType.IsRenderable);
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      this.emit("freed", {
        type: "texture"
      });
    });
    this.stage = stage2;
    this.props = {
      ...props,
      parent: null,
      texture: null,
      src: null,
      rtt: false
    };
    this.parent = props.parent;
    this.texture = props.texture;
    this.src = props.src;
    this.rtt = props.rtt;
    this.interactive = props.interactive;
    if (props.boundsMargin) {
      this.boundsMargin = Array.isArray(props.boundsMargin) ? props.boundsMargin : [
        props.boundsMargin,
        props.boundsMargin,
        props.boundsMargin,
        props.boundsMargin
      ];
    }
    this.setUpdateType(UpdateType.ScaleRotate | UpdateType.Local | UpdateType.RenderBounds | UpdateType.RenderState);
    if (isProductionEnvironment === false && props.preventCleanup === true) {
      console.warn("CoreNode.preventCleanup: Is deprecated and will be removed in upcoming release, please use textureOptions.preventCleanup instead");
    }
    if (this.stage.defaultTexture && this.stage.defaultTexture.state !== "loaded") {
      this.stage.defaultTexture.once("loaded", () => {
        this.setUpdateType(UpdateType.IsRenderable);
      });
    }
  }
  //#region Textures
  loadTexture() {
    const { texture } = this.props;
    assertTruthy(texture);
    queueMicrotask(() => {
      var _a2;
      if (this.textureOptions.preload === true) {
        this.stage.txManager.loadTexture(texture);
      }
      texture.preventCleanup = ((_a2 = this.props.textureOptions) == null ? void 0 : _a2.preventCleanup) ?? false;
      texture.on("loaded", this.onTextureLoaded);
      texture.on("failed", this.onTextureFailed);
      texture.on("freed", this.onTextureFreed);
      if (texture.state === "loaded") {
        assertTruthy(texture.dimensions);
        this.onTextureLoaded(texture, texture.dimensions);
      } else if (texture.state === "failed") {
        assertTruthy(texture.error);
        this.onTextureFailed(texture, texture.error);
      } else if (texture.state === "freed") {
        this.onTextureFreed(texture);
      }
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
        return;
      }
    });
  }
  unloadTexture() {
    if (this.texture !== null) {
      this.texture.off("loaded", this.onTextureLoaded);
      this.texture.off("failed", this.onTextureFailed);
      this.texture.off("freed", this.onTextureFreed);
      this.texture.setRenderableOwner(this._id, false);
    }
  }
  autosizeNode(dimensions) {
    if (this.autosize) {
      this.width = dimensions.width;
      this.height = dimensions.height;
    }
  }
  //#endregion Textures
  /**
   * Change types types is used to determine the scope of the changes being applied
   *
   * @remarks
   * See {@link UpdateType} for more information on each type
   *
   * @param type
   */
  setUpdateType(type) {
    this.updateType |= type;
    const parent = this.props.parent;
    if (!parent)
      return;
    if ((parent.updateType & UpdateType.Children) === 0) {
      parent.setUpdateType(UpdateType.Children);
    }
  }
  sortChildren() {
    this.children.sort((a, b) => a.calcZIndex - b.calcZIndex);
  }
  updateScaleRotateTransform() {
    const { rotation, scaleX, scaleY } = this.props;
    if (rotation === 0 && scaleX === 1 && scaleY === 1) {
      this.scaleRotateTransform = void 0;
      return;
    }
    this.scaleRotateTransform = Matrix3d.rotate(rotation, this.scaleRotateTransform).scale(scaleX, scaleY);
  }
  updateLocalTransform() {
    var _a2, _b;
    const { x, y, width, height } = this.props;
    const mountTranslateX = this.props.mountX * width;
    const mountTranslateY = this.props.mountY * height;
    if (this.scaleRotateTransform) {
      const pivotTranslateX = this.props.pivotX * width;
      const pivotTranslateY = this.props.pivotY * height;
      this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(this.scaleRotateTransform).translate(-pivotTranslateX, -pivotTranslateY);
    } else {
      this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
    }
    const texture = this.props.texture;
    if (texture && texture.dimensions && ((_b = (_a2 = this.props.textureOptions) == null ? void 0 : _a2.resizeMode) == null ? void 0 : _b.type) === "contain") {
      let resizeModeScaleX = 1;
      let resizeModeScaleY = 1;
      let extraX = 0;
      let extraY = 0;
      const { width: tw, height: th } = texture.dimensions;
      const txAspectRatio = tw / th;
      const nodeAspectRatio = width / height;
      if (txAspectRatio > nodeAspectRatio) {
        const scaleX = width / tw;
        const scaledTxHeight = th * scaleX;
        extraY = (height - scaledTxHeight) / 2;
        resizeModeScaleY = scaledTxHeight / height;
      } else {
        const scaleY = height / th;
        const scaledTxWidth = tw * scaleY;
        extraX = (width - scaledTxWidth) / 2;
        resizeModeScaleX = scaledTxWidth / width;
      }
      this.localTransform.translate(extraX, extraY).scale(resizeModeScaleX, resizeModeScaleY);
    }
    this.setUpdateType(UpdateType.Global);
  }
  /**
   * @todo: test for correct calculation flag
   * @param delta
   */
  update(delta, parentClippingRect) {
    if (this.updateType & UpdateType.ScaleRotate) {
      this.updateScaleRotateTransform();
      this.setUpdateType(UpdateType.Local);
    }
    if (this.updateType & UpdateType.Local) {
      this.updateLocalTransform();
      this.setUpdateType(UpdateType.Global);
    }
    const parent = this.props.parent;
    let renderState = null;
    if (this.updateType & UpdateType.RenderTexture && this.rtt) {
      this.hasRTTupdates = true;
    }
    if (this.updateType & UpdateType.Global) {
      assertTruthy(this.localTransform);
      if (this.parentHasRenderTexture === true && (parent == null ? void 0 : parent.rtt) === true) {
        this.globalTransform = Matrix3d.identity();
        this.sceneGlobalTransform = Matrix3d.copy((parent == null ? void 0 : parent.globalTransform) || Matrix3d.identity()).multiply(this.localTransform);
      } else if (this.parentHasRenderTexture === true && (parent == null ? void 0 : parent.rtt) === false) {
        this.sceneGlobalTransform = Matrix3d.copy((parent == null ? void 0 : parent.sceneGlobalTransform) || this.localTransform).multiply(this.localTransform);
        this.globalTransform = Matrix3d.copy((parent == null ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
      } else {
        this.globalTransform = Matrix3d.copy((parent == null ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
      }
      if (parent !== null) {
        this.globalTransform.multiply(this.localTransform);
      }
      this.calculateRenderCoords();
      this.updateBoundingRect();
      this.setUpdateType(UpdateType.RenderState | UpdateType.Children);
      this.childUpdateType |= UpdateType.Global;
      if (this.clipping === true) {
        this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds);
        this.childUpdateType |= UpdateType.RenderBounds;
      }
    }
    if (this.updateType & UpdateType.RenderBounds) {
      this.createRenderBounds();
      this.setUpdateType(UpdateType.RenderState);
      this.setUpdateType(UpdateType.Children);
      this.childUpdateType |= UpdateType.RenderBounds;
    }
    if (this.updateType & UpdateType.RenderState) {
      renderState = this.checkRenderBounds();
      this.setUpdateType(UpdateType.IsRenderable);
      if (renderState !== CoreNodeRenderState.OutOfBounds) {
        this.updateRenderState(renderState);
      }
    }
    if (this.updateType & UpdateType.WorldAlpha) {
      if (parent) {
        this.worldAlpha = parent.worldAlpha * this.props.alpha;
      } else {
        this.worldAlpha = this.props.alpha;
      }
      this.setUpdateType(UpdateType.Children | UpdateType.PremultipliedColors | UpdateType.IsRenderable);
      this.childUpdateType |= UpdateType.WorldAlpha;
    }
    if (this.updateType & UpdateType.IsRenderable) {
      this.updateIsRenderable();
    }
    if (this.updateType & UpdateType.Clipping) {
      this.calculateClippingRect(parentClippingRect);
      this.setUpdateType(UpdateType.Children);
      this.childUpdateType |= UpdateType.Clipping;
      this.childUpdateType |= UpdateType.RenderBounds;
    }
    if (this.updateType & UpdateType.PremultipliedColors) {
      this.premultipliedColorTl = mergeColorAlphaPremultiplied(this.props.colorTl, this.worldAlpha, true);
      if (this.props.colorTl === this.props.colorTr && this.props.colorBl === this.props.colorBr && this.props.colorTl === this.props.colorBl) {
        this.premultipliedColorTr = this.premultipliedColorBl = this.premultipliedColorBr = this.premultipliedColorTl;
      } else {
        this.premultipliedColorTr = mergeColorAlphaPremultiplied(this.props.colorTr, this.worldAlpha, true);
        this.premultipliedColorBl = mergeColorAlphaPremultiplied(this.props.colorBl, this.worldAlpha, true);
        this.premultipliedColorBr = mergeColorAlphaPremultiplied(this.props.colorBr, this.worldAlpha, true);
      }
    }
    if (parent !== null && this.updateType & UpdateType.CalculatedZIndex) {
      this.calculateZIndex();
      parent.setUpdateType(UpdateType.ZIndexSortedChildren);
    }
    if (this.props.strictBounds === true && this.renderState === CoreNodeRenderState.OutOfBounds) {
      this.updateType &= ~UpdateType.RenderBounds;
      return;
    }
    if (this.updateType & UpdateType.Children && this.children.length > 0) {
      for (let i = 0, length = this.children.length; i < length; i++) {
        const child = this.children[i];
        child.setUpdateType(this.childUpdateType);
        if (child.updateType === 0) {
          continue;
        }
        let childClippingRect = this.clippingRect;
        if (this.rtt === true) {
          childClippingRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            valid: false
          };
        }
        child.update(delta, childClippingRect);
      }
    }
    if (this.parentHasRenderTexture && this.updateType > 0) {
      this.notifyParentRTTOfUpdate();
    }
    if (this.updateType & UpdateType.ZIndexSortedChildren) {
      this.sortChildren();
    }
    if (renderState === CoreNodeRenderState.OutOfBounds) {
      this.updateRenderState(renderState);
      this.updateIsRenderable();
      if (this.rtt === true && renderState === CoreNodeRenderState.OutOfBounds) {
        this.notifyChildrenRTTOfUpdate(renderState);
      }
    }
    this.updateType = 0;
    this.childUpdateType = 0;
  }
  findParentRTTNode() {
    let rttNode = this.parent;
    while (rttNode && !rttNode.rtt) {
      rttNode = rttNode.parent;
    }
    return rttNode;
  }
  getRTTParentRenderState() {
    const rttNode = this.rttParent || this.findParentRTTNode();
    if (!rttNode) {
      return null;
    }
    return rttNode.renderState;
  }
  notifyChildrenRTTOfUpdate(renderState) {
    for (const child of this.children) {
      child.updateRenderState(renderState);
      child.updateIsRenderable();
      child.notifyChildrenRTTOfUpdate(renderState);
    }
  }
  notifyParentRTTOfUpdate() {
    if (this.parent === null) {
      return;
    }
    const rttNode = this.rttParent || this.findParentRTTNode();
    if (!rttNode) {
      return;
    }
    rttNode.hasRTTupdates = true;
    rttNode.setUpdateType(UpdateType.RenderTexture);
    if (rttNode.parentHasRenderTexture === true) {
      rttNode.notifyParentRTTOfUpdate();
    }
  }
  checkRenderBounds() {
    assertTruthy(this.renderBound);
    assertTruthy(this.strictBound);
    assertTruthy(this.preloadBound);
    if (boundInsideBound(this.renderBound, this.strictBound)) {
      return CoreNodeRenderState.InViewport;
    }
    if (boundInsideBound(this.renderBound, this.preloadBound)) {
      return CoreNodeRenderState.InBounds;
    }
    if (boundLargeThanBound(this.renderBound, this.strictBound)) {
      return CoreNodeRenderState.InViewport;
    }
    if (this.parent !== null && (this.props.width === 0 || this.props.height === 0)) {
      return this.parent.renderState;
    }
    return CoreNodeRenderState.OutOfBounds;
  }
  updateBoundingRect() {
    const transform = this.sceneGlobalTransform || this.globalTransform;
    const renderCoords = this.sceneRenderCoords || this.renderCoords;
    assertTruthy(transform);
    assertTruthy(renderCoords);
    const { tb, tc } = transform;
    const { x1, y1, x3, y3 } = renderCoords;
    if (tb === 0 || tc === 0) {
      this.renderBound = createBound(x1, y1, x3, y3, this.renderBound);
    } else {
      const { x2, x4, y2, y4 } = renderCoords;
      this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
    }
  }
  createRenderBounds() {
    assertTruthy(this.stage);
    if (this.parent !== null && this.parent.strictBound !== void 0) {
      const parentBound = this.parent.strictBound;
      this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
      this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
    } else {
      this.strictBound = this.stage.strictBound;
      this.preloadBound = this.stage.preloadBound;
    }
    if (this.props.clipping === false) {
      return;
    }
    if (this.renderBound === void 0) {
      return;
    }
    if (boundInsideBound(this.renderBound, this.strictBound) === false) {
      return;
    }
    const { x, y, width, height } = this.props;
    const { tx, ty } = this.sceneGlobalTransform || this.globalTransform || {};
    const _x = tx ?? x;
    const _y = ty ?? y;
    this.strictBound = createBound(_x, _y, _x + width, _y + height, this.strictBound);
    this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
  }
  updateRenderState(renderState) {
    if (renderState === this.renderState) {
      return;
    }
    const previous = this.renderState;
    this.renderState = renderState;
    const event = CoreNodeRenderStateMap.get(renderState);
    assertTruthy(event);
    this.emit(event, {
      previous,
      current: renderState
    });
  }
  /**
   * Updates the `isRenderable` property based on various conditions.
   */
  updateIsRenderable() {
    let newIsRenderable = false;
    let needsTextureOwnership = false;
    if (this.checkBasicRenderability() === false) {
      this.updateTextureOwnership(false);
      this.setRenderable(false);
      return;
    }
    if (this.texture !== null) {
      if (this.texture.retryCount > this.texture.maxRetryCount) {
        this.updateTextureOwnership(false);
        this.setRenderable(false);
        return;
      }
      needsTextureOwnership = true;
      newIsRenderable = this.texture.state === "loaded";
    } else if ((this.hasShader() || this.hasColorProperties() === true) && this.hasDimensions() === true) {
      if (this.stage.defaultTexture && this.stage.defaultTexture.state === "loaded") {
        newIsRenderable = true;
      }
    }
    this.updateTextureOwnership(needsTextureOwnership);
    this.setRenderable(newIsRenderable);
  }
  /**
   * Checks if the node is renderable based on world alpha, dimensions and out of bounds status.
   */
  checkBasicRenderability() {
    if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
      return false;
    } else {
      return true;
    }
  }
  /**
   * Sets the renderable state and triggers changes if necessary.
   * @param isRenderable - The new renderable state
   */
  setRenderable(isRenderable) {
    const previousIsRenderable = this.isRenderable;
    this.isRenderable = isRenderable;
    if (previousIsRenderable !== isRenderable) {
      this.emit("renderable", {
        type: "renderable",
        isRenderable
      });
    }
  }
  /**
   * Changes the renderable state of the node.
   */
  updateTextureOwnership(isRenderable) {
    var _a2;
    (_a2 = this.texture) == null ? void 0 : _a2.setRenderableOwner(this._id, isRenderable);
  }
  /**
   * Checks if the node is out of the viewport bounds.
   */
  isOutOfBounds() {
    return this.renderState <= CoreNodeRenderState.OutOfBounds;
  }
  /**
   * Checks if the node has dimensions (width/height)
   */
  hasDimensions() {
    return this.props.width !== 0 && this.props.height !== 0;
  }
  /**
   * Checks if the node has any color properties set.
   */
  hasColorProperties() {
    return this.props.color !== 0 || this.props.colorTop !== 0 || this.props.colorBottom !== 0 || this.props.colorLeft !== 0 || this.props.colorRight !== 0 || this.props.colorTl !== 0 || this.props.colorTr !== 0 || this.props.colorBl !== 0 || this.props.colorBr !== 0;
  }
  hasShader() {
    return this.props.shader !== null;
  }
  calculateRenderCoords() {
    const { width, height } = this;
    const { tx, ty, ta, tb, tc, td } = this.globalTransform;
    if (tb === 0 && tc === 0) {
      const minX = tx;
      const maxX = tx + width * ta;
      const minY = ty;
      const maxY = ty + height * td;
      this.renderCoords = RenderCoords.translate(
        //top-left
        minX,
        minY,
        //top-right
        maxX,
        minY,
        //bottom-right
        maxX,
        maxY,
        //bottom-left
        minX,
        maxY,
        this.renderCoords
      );
    } else {
      this.renderCoords = RenderCoords.translate(
        //top-left
        tx,
        ty,
        //top-right
        tx + width * ta,
        ty + width * tc,
        //bottom-right
        tx + width * ta + height * tb,
        ty + width * tc + height * td,
        //bottom-left
        tx + height * tb,
        ty + height * td,
        this.renderCoords
      );
    }
    if (this.sceneGlobalTransform === void 0) {
      return;
    }
    const { tx: stx, ty: sty, ta: sta, tb: stb, tc: stc, td: std } = this.sceneGlobalTransform;
    if (stb === 0 && stc === 0) {
      const minX = stx;
      const maxX = stx + width * sta;
      const minY = sty;
      const maxY = sty + height * std;
      this.sceneRenderCoords = RenderCoords.translate(
        //top-left
        minX,
        minY,
        //top-right
        maxX,
        minY,
        //bottom-right
        maxX,
        maxY,
        //bottom-left
        minX,
        maxY,
        this.sceneRenderCoords
      );
    } else {
      this.sceneRenderCoords = RenderCoords.translate(
        //top-left
        stx,
        sty,
        //top-right
        stx + width * sta,
        sty + width * stc,
        //bottom-right
        stx + width * sta + height * stb,
        sty + width * stc + height * std,
        //bottom-left
        stx + height * stb,
        sty + height * std,
        this.sceneRenderCoords
      );
    }
  }
  /**
   * This function calculates the clipping rectangle for a node.
   *
   * The function then checks if the node is rotated. If the node requires clipping and is not rotated, a new clipping rectangle is created based on the node's global transform and dimensions.
   * If a parent clipping rectangle exists, it is intersected with the node's clipping rectangle (if it exists), or replaces the node's clipping rectangle.
   *
   * Finally, the node's parentClippingRect and clippingRect properties are updated.
   */
  calculateClippingRect(parentClippingRect) {
    assertTruthy(this.globalTransform);
    const { clippingRect, props, globalTransform: gt } = this;
    const { clipping } = props;
    const isRotated = gt.tb !== 0 || gt.tc !== 0;
    if (clipping === true && isRotated === false) {
      clippingRect.x = gt.tx;
      clippingRect.y = gt.ty;
      clippingRect.width = this.width * gt.ta;
      clippingRect.height = this.height * gt.td;
      clippingRect.valid = true;
    } else {
      clippingRect.valid = false;
    }
    if (parentClippingRect.valid === true && clippingRect.valid === true) {
      intersectRect(parentClippingRect, clippingRect, clippingRect);
    } else if (parentClippingRect.valid === true) {
      copyRect(parentClippingRect, clippingRect);
      clippingRect.valid = true;
    }
  }
  calculateZIndex() {
    var _a2, _b;
    const props = this.props;
    const z = props.zIndex || 0;
    const p = ((_a2 = props.parent) == null ? void 0 : _a2.zIndex) || 0;
    let zIndex = z;
    if ((_b = props.parent) == null ? void 0 : _b.zIndexLocked) {
      zIndex = z < p ? z : p;
    }
    this.calcZIndex = zIndex;
  }
  /**
   * Destroy the node and cleanup all resources
   */
  destroy() {
    var _a2;
    if (this.destroyed === true) {
      return;
    }
    this.destroyed = true;
    this.unloadTexture();
    this.clippingRect.valid = false;
    this.isRenderable = false;
    this.renderCoords = void 0;
    this.renderBound = void 0;
    this.strictBound = void 0;
    this.preloadBound = void 0;
    this.globalTransform = void 0;
    this.scaleRotateTransform = void 0;
    this.localTransform = void 0;
    this.props.texture = null;
    this.props.shader = this.stage.defShaderCtr;
    while (this.children.length > 0) {
      (_a2 = this.children[0]) == null ? void 0 : _a2.destroy();
    }
    this.parent = null;
    if (this.rtt) {
      this.stage.renderer.removeRTTNode(this);
    }
    this.removeAllListeners();
  }
  renderQuads(renderer3) {
    if (this.parentHasRenderTexture) {
      if (!renderer3.renderToTextureActive) {
        return;
      }
      if (this.parentRenderTexture !== renderer3.activeRttNode) {
        return;
      }
    }
    assertTruthy(this.globalTransform);
    assertTruthy(this.renderCoords);
    renderer3.addQuad({
      width: this.props.width,
      height: this.props.height,
      colorTl: this.premultipliedColorTl,
      colorTr: this.premultipliedColorTr,
      colorBl: this.premultipliedColorBl,
      colorBr: this.premultipliedColorBr,
      // if we do not have a texture, use the default texture
      // this assumes any renderable node is either a distinct texture or a ColorTexture
      texture: this.texture || this.stage.defaultTexture,
      textureOptions: this.textureOptions,
      zIndex: this.zIndex,
      shader: this.shader.shader,
      shaderProps: this.shader.getResolvedProps(),
      alpha: this.worldAlpha,
      clippingRect: this.clippingRect,
      tx: this.globalTransform.tx,
      ty: this.globalTransform.ty,
      ta: this.globalTransform.ta,
      tb: this.globalTransform.tb,
      tc: this.globalTransform.tc,
      td: this.globalTransform.td,
      renderCoords: this.renderCoords,
      rtt: this.rtt,
      parentHasRenderTexture: this.parentHasRenderTexture,
      framebufferDimensions: this.framebufferDimensions
    });
  }
  //#region Properties
  get id() {
    return this._id;
  }
  get data() {
    return this.props.data;
  }
  set data(d) {
    this.props.data = d;
  }
  get x() {
    return this.props.x;
  }
  set x(value) {
    if (this.props.x !== value) {
      this.props.x = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get absX() {
    var _a2, _b, _c;
    return this.props.x + -this.props.width * this.props.mountX + (((_a2 = this.props.parent) == null ? void 0 : _a2.absX) || ((_c = (_b = this.props.parent) == null ? void 0 : _b.globalTransform) == null ? void 0 : _c.tx) || 0);
  }
  get absY() {
    var _a2;
    return this.props.y + -this.props.height * this.props.mountY + (((_a2 = this.props.parent) == null ? void 0 : _a2.absY) ?? 0);
  }
  get y() {
    return this.props.y;
  }
  set y(value) {
    if (this.props.y !== value) {
      this.props.y = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    if (this.props.width !== value) {
      this.props.width = value;
      this.setUpdateType(UpdateType.Local);
      if (this.props.rtt) {
        this.texture = this.stage.txManager.createTexture("RenderTexture", {
          width: this.width,
          height: this.height
        });
        this.setUpdateType(UpdateType.RenderTexture);
      }
    }
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    if (this.props.height !== value) {
      this.props.height = value;
      this.setUpdateType(UpdateType.Local);
      if (this.props.rtt) {
        this.texture = this.stage.txManager.createTexture("RenderTexture", {
          width: this.width,
          height: this.height
        });
        this.setUpdateType(UpdateType.RenderTexture);
      }
    }
  }
  get scale() {
    return this.scaleX;
  }
  set scale(value) {
    this.scaleX = value;
    this.scaleY = value;
  }
  get scaleX() {
    return this.props.scaleX;
  }
  set scaleX(value) {
    if (this.props.scaleX !== value) {
      this.props.scaleX = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get scaleY() {
    return this.props.scaleY;
  }
  set scaleY(value) {
    if (this.props.scaleY !== value) {
      this.props.scaleY = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get mount() {
    return this.props.mount;
  }
  set mount(value) {
    if (this.props.mountX !== value || this.props.mountY !== value) {
      this.props.mountX = value;
      this.props.mountY = value;
      this.props.mount = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get mountX() {
    return this.props.mountX;
  }
  set mountX(value) {
    if (this.props.mountX !== value) {
      this.props.mountX = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get mountY() {
    return this.props.mountY;
  }
  set mountY(value) {
    if (this.props.mountY !== value) {
      this.props.mountY = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivot() {
    return this.props.pivot;
  }
  set pivot(value) {
    if (this.props.pivotX !== value || this.props.pivotY !== value) {
      this.props.pivotX = value;
      this.props.pivotY = value;
      this.props.pivot = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivotX() {
    return this.props.pivotX;
  }
  set pivotX(value) {
    if (this.props.pivotX !== value) {
      this.props.pivotX = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivotY() {
    return this.props.pivotY;
  }
  set pivotY(value) {
    if (this.props.pivotY !== value) {
      this.props.pivotY = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get rotation() {
    return this.props.rotation;
  }
  set rotation(value) {
    if (this.props.rotation !== value) {
      this.props.rotation = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get alpha() {
    return this.props.alpha;
  }
  set alpha(value) {
    this.props.alpha = value;
    this.setUpdateType(UpdateType.PremultipliedColors | UpdateType.WorldAlpha | UpdateType.Children | UpdateType.IsRenderable);
    this.childUpdateType |= UpdateType.WorldAlpha;
  }
  get autosize() {
    return this.props.autosize;
  }
  set autosize(value) {
    this.props.autosize = value;
  }
  get boundsMargin() {
    var _a2;
    return this.props.boundsMargin ?? ((_a2 = this.parent) == null ? void 0 : _a2.boundsMargin) ?? this.stage.boundsMargin;
  }
  set boundsMargin(value) {
    if (value === this.props.boundsMargin) {
      return;
    }
    if (value === null) {
      this.props.boundsMargin = value;
    } else {
      const bm = Array.isArray(value) ? value : [value, value, value, value];
      this.props.boundsMargin = bm;
    }
    this.setUpdateType(UpdateType.RenderBounds);
  }
  get clipping() {
    return this.props.clipping;
  }
  set clipping(value) {
    this.props.clipping = value;
    this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
    this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
  }
  get color() {
    return this.props.color;
  }
  set color(value) {
    this.colorTop = value;
    this.colorBottom = value;
    this.colorLeft = value;
    this.colorRight = value;
    this.props.color = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTop() {
    return this.props.colorTop;
  }
  set colorTop(value) {
    if (this.props.colorTl !== value || this.props.colorTr !== value) {
      this.colorTl = value;
      this.colorTr = value;
    }
    this.props.colorTop = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBottom() {
    return this.props.colorBottom;
  }
  set colorBottom(value) {
    if (this.props.colorBl !== value || this.props.colorBr !== value) {
      this.colorBl = value;
      this.colorBr = value;
    }
    this.props.colorBottom = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorLeft() {
    return this.props.colorLeft;
  }
  set colorLeft(value) {
    if (this.props.colorTl !== value || this.props.colorBl !== value) {
      this.colorTl = value;
      this.colorBl = value;
    }
    this.props.colorLeft = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorRight() {
    return this.props.colorRight;
  }
  set colorRight(value) {
    if (this.props.colorTr !== value || this.props.colorBr !== value) {
      this.colorTr = value;
      this.colorBr = value;
    }
    this.props.colorRight = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTl() {
    return this.props.colorTl;
  }
  set colorTl(value) {
    this.props.colorTl = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTr() {
    return this.props.colorTr;
  }
  set colorTr(value) {
    this.props.colorTr = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBl() {
    return this.props.colorBl;
  }
  set colorBl(value) {
    this.props.colorBl = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBr() {
    return this.props.colorBr;
  }
  set colorBr(value) {
    this.props.colorBr = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  // we're only interested in parent zIndex to test
  // if we should use node zIndex is higher then parent zIndex
  get zIndexLocked() {
    return this.props.zIndexLocked || 0;
  }
  set zIndexLocked(value) {
    this.props.zIndexLocked = value;
    this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
    for (let i = 0, length = this.children.length; i < length; i++) {
      this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
    }
  }
  get zIndex() {
    return this.props.zIndex;
  }
  set zIndex(value) {
    this.props.zIndex = value;
    this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
    for (let i = 0, length = this.children.length; i < length; i++) {
      this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
    }
  }
  get parent() {
    return this.props.parent;
  }
  set parent(newParent) {
    const oldParent = this.props.parent;
    if (oldParent === newParent) {
      return;
    }
    this.props.parent = newParent;
    if (oldParent) {
      const index = oldParent.children.indexOf(this);
      assertTruthy(index !== -1, "CoreNode.parent: Node not found in old parent's children!");
      oldParent.children.splice(index, 1);
      oldParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
    }
    if (newParent) {
      newParent.children.push(this);
      this.setUpdateType(UpdateType.All);
      newParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
      if (newParent.rtt || newParent.parentHasRenderTexture) {
        this.applyRTTInheritance(newParent);
      }
    }
    this.updateScaleRotateTransform();
    this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
  }
  get preventCleanup() {
    return this.props.textureOptions.preventCleanup || false;
  }
  set preventCleanup(value) {
    if (isProductionEnvironment === false) {
      console.warn("CoreNode.preventCleanup: Is deprecated and will be removed in upcoming release, please use textureOptions.preventCleanup instead");
    }
    this.props.textureOptions.preventCleanup = value;
  }
  get rtt() {
    return this.props.rtt;
  }
  set rtt(value) {
    if (this.props.rtt === value) {
      return;
    }
    this.props.rtt = value;
    if (value === true) {
      this.initRenderTexture();
      this.markChildrenWithRTT();
    } else {
      this.cleanupRenderTexture();
    }
    this.setUpdateType(UpdateType.RenderTexture);
    if (this.parentHasRenderTexture === true) {
      this.notifyParentRTTOfUpdate();
    }
  }
  initRenderTexture() {
    this.texture = this.stage.txManager.createTexture("RenderTexture", {
      width: this.width,
      height: this.height
    });
    this.stage.renderer.renderToTexture(this);
  }
  cleanupRenderTexture() {
    this.unloadTexture();
    this.clearRTTInheritance();
    this.hasRTTupdates = false;
    this.texture = null;
  }
  markChildrenWithRTT(node = null) {
    const parent = node || this;
    for (const child of parent.children) {
      child.setUpdateType(UpdateType.All);
      child.parentHasRenderTexture = true;
      child.markChildrenWithRTT();
    }
  }
  // Apply RTT inheritance when a node has an RTT-enabled parent
  applyRTTInheritance(parent) {
    if (parent.rtt) {
      parent.setUpdateType(UpdateType.RenderTexture);
    }
    this.markChildrenWithRTT(parent);
  }
  // Clear RTT inheritance when detaching from an RTT chain
  clearRTTInheritance() {
    if (this.rtt) {
      return;
    }
    for (const child of this.children) {
      child.parentHasRenderTexture = false;
      child.rttParent = null;
      child.setUpdateType(UpdateType.All);
      child.clearRTTInheritance();
    }
  }
  get shader() {
    return this.props.shader;
  }
  set shader(value) {
    if (this.props.shader === value) {
      return;
    }
    this.props.shader = value;
    this.setUpdateType(UpdateType.IsRenderable);
  }
  get src() {
    return this.props.src;
  }
  set src(imageUrl) {
    if (this.props.src === imageUrl) {
      return;
    }
    this.props.src = imageUrl;
    if (!imageUrl) {
      this.texture = null;
      return;
    }
    this.texture = this.stage.txManager.createTexture("ImageTexture", {
      src: imageUrl,
      width: this.props.width,
      height: this.props.height,
      type: this.props.imageType,
      sx: this.props.srcX,
      sy: this.props.srcY,
      sw: this.props.srcWidth,
      sh: this.props.srcHeight,
      maxRetryCount: this.props.textureOptions.maxRetryCount
    });
  }
  set imageType(type) {
    if (this.props.imageType === type) {
      return;
    }
    this.props.imageType = type;
  }
  get imageType() {
    return this.props.imageType || null;
  }
  get srcHeight() {
    return this.props.srcHeight;
  }
  set srcHeight(value) {
    this.props.srcHeight = value;
  }
  get srcWidth() {
    return this.props.srcWidth;
  }
  set srcWidth(value) {
    this.props.srcWidth = value;
  }
  get srcX() {
    return this.props.srcX;
  }
  set srcX(value) {
    this.props.srcX = value;
  }
  get srcY() {
    return this.props.srcY;
  }
  set srcY(value) {
    this.props.srcY = value;
  }
  /**
   * Returns the framebuffer dimensions of the node.
   * If the node has a render texture, the dimensions are the same as the node's dimensions.
   * If the node does not have a render texture, the dimensions are inherited from the parent.
   * If the node parent has a render texture and the node is a render texture, the nodes dimensions are used.
   */
  get framebufferDimensions() {
    if (this.parentHasRenderTexture && !this.rtt && this.parent) {
      return this.parent.framebufferDimensions;
    }
    return { width: this.width, height: this.height };
  }
  /**
   * Returns the parent render texture node if it exists.
   */
  get parentRenderTexture() {
    let parent = this.parent;
    while (parent) {
      if (parent.rtt) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  get texture() {
    return this.props.texture;
  }
  set texture(value) {
    if (this.props.texture === value) {
      return;
    }
    const oldTexture = this.props.texture;
    if (oldTexture) {
      this.unloadTexture();
    }
    this.props.texture = value;
    if (value !== null) {
      value.setRenderableOwner(this._id, this.isRenderable);
      this.loadTexture();
    }
    this.setUpdateType(UpdateType.IsRenderable);
  }
  set textureOptions(value) {
    this.props.textureOptions = value;
  }
  get textureOptions() {
    return this.props.textureOptions;
  }
  get strictBounds() {
    return this.props.strictBounds;
  }
  set strictBounds(v) {
    if (v === this.props.strictBounds) {
      return;
    }
    this.props.strictBounds = v;
    this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
    this.childUpdateType |= UpdateType.RenderBounds | UpdateType.Children;
  }
  set interactive(value) {
    this.props.interactive = value;
    if (value === true) {
      this.stage.interactiveNodes.add(this);
    }
  }
  get interactive() {
    return this.props.interactive;
  }
  animate(props, settings2) {
    const animation = new CoreAnimation(this, props, settings2);
    const controller = new CoreAnimationController(this.stage.animationManager, animation);
    return controller;
  }
  flush() {
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/platform.js
var startLoop = (stage2) => {
  let isIdle = false;
  let lastFrameTime = 0;
  const runLoop = (currentTime = 0) => {
    const targetFrameTime = stage2.targetFrameTime;
    if (targetFrameTime > 0 && currentTime - lastFrameTime < targetFrameTime) {
      const delay = targetFrameTime - (currentTime - lastFrameTime);
      setTimeout(() => requestAnimationFrame(runLoop), delay);
      return;
    }
    lastFrameTime = currentTime;
    stage2.updateFrameTime();
    stage2.updateAnimations();
    if (!stage2.hasSceneUpdates()) {
      stage2.calculateFps();
      if (targetFrameTime > 0) {
        setTimeout(() => requestAnimationFrame(runLoop), Math.max(targetFrameTime, 16.666666666666668));
      } else {
        setTimeout(() => requestAnimationFrame(runLoop), 16.666666666666668);
      }
      if (!isIdle) {
        stage2.eventBus.emit("idle");
        isIdle = true;
      }
      if (stage2.txMemManager.checkCleanup() === true) {
        stage2.txMemManager.cleanup();
      }
      stage2.flushFrameEvents();
      return;
    }
    isIdle = false;
    stage2.drawFrame();
    stage2.flushFrameEvents();
    if (targetFrameTime > 0) {
      const nextFrameDelay = Math.max(0, targetFrameTime - (performance.now() - currentTime));
      setTimeout(() => requestAnimationFrame(runLoop), nextFrameDelay);
    } else {
      requestAnimationFrame(runLoop);
    }
  };
  requestAnimationFrame(runLoop);
};
var getTimeStamp = () => {
  return performance ? performance.now() : Date.now();
};

// node_modules/@lightningjs/renderer/dist/src/core/animations/AnimationManager.js
var AnimationManager = class {
  constructor() {
    __publicField(this, "activeAnimations", /* @__PURE__ */ new Set());
  }
  registerAnimation(animation) {
    this.activeAnimations.add(animation);
  }
  unregisterAnimation(animation) {
    this.activeAnimations.delete(animation);
  }
  update(dt) {
    this.activeAnimations.forEach((animation) => {
      animation.update(dt);
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/ImageWorker.js
function createImageWorker() {
  function hasAlphaChannel(mimeType) {
    return mimeType.indexOf("image/png") !== -1;
  }
  function getImage(src, premultiplyAlpha, x, y, width, height, options) {
    return new Promise(function(resolve, reject) {
      var supportsOptionsCreateImageBitmap = options.supportsOptionsCreateImageBitmap;
      var supportsFullCreateImageBitmap = options.supportsFullCreateImageBitmap;
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, true);
      xhr.responseType = "blob";
      xhr.onload = function() {
        if (xhr.status !== 200 && xhr.status !== 0) {
          return reject(new Error("Failed to load image: " + xhr.statusText));
        }
        var blob = xhr.response;
        var withAlphaChannel = premultiplyAlpha !== void 0 ? premultiplyAlpha : hasAlphaChannel(blob.type);
        if (supportsFullCreateImageBitmap === true && width !== null && height !== null) {
          createImageBitmap(blob, x || 0, y || 0, width, height, {
            premultiplyAlpha: withAlphaChannel ? "premultiply" : "none",
            colorSpaceConversion: "none",
            imageOrientation: "none"
          }).then(function(data) {
            resolve({ data, premultiplyAlpha });
          }).catch(function(error) {
            reject(error);
          });
          return;
        } else if (supportsOptionsCreateImageBitmap === false && supportsOptionsCreateImageBitmap === false) {
          createImageBitmap(blob).then(function(data) {
            resolve({ data, premultiplyAlpha });
          }).catch(function(error) {
            reject(error);
          });
        } else {
          createImageBitmap(blob, {
            premultiplyAlpha: withAlphaChannel ? "premultiply" : "none",
            colorSpaceConversion: "none",
            imageOrientation: "none"
          }).then(function(data) {
            resolve({ data, premultiplyAlpha });
          }).catch(function(error) {
            reject(error);
          });
        }
      };
      xhr.onerror = function() {
        reject(new Error("Network error occurred while trying to fetch the image."));
      };
      xhr.send();
    });
  }
  self.onmessage = (event) => {
    var src = event.data.src;
    var id = event.data.id;
    var premultiplyAlpha = event.data.premultiplyAlpha;
    var x = event.data.sx;
    var y = event.data.sy;
    var width = event.data.sw;
    var height = event.data.sh;
    var supportsOptionsCreateImageBitmap = false;
    var supportsFullCreateImageBitmap = false;
    getImage(src, premultiplyAlpha, x, y, width, height, {
      supportsOptionsCreateImageBitmap,
      supportsFullCreateImageBitmap
    }).then(function(data) {
      self.postMessage({ id, src, data }, [data.data]);
    }).catch(function(error) {
      self.postMessage({ id, src, error: error.message });
    });
  };
}
var ImageWorkerManager = class {
  constructor(numImageWorkers, createImageBitmapSupport) {
    __publicField(this, "imageWorkersEnabled", true);
    __publicField(this, "messageManager", {});
    __publicField(this, "workers", []);
    __publicField(this, "workerIndex", 0);
    __publicField(this, "nextId", 0);
    this.workers = this.createWorkers(numImageWorkers, createImageBitmapSupport);
    this.workers.forEach((worker) => {
      worker.onmessage = this.handleMessage.bind(this);
    });
  }
  handleMessage(event) {
    const { id, data, error } = event.data;
    const msg = this.messageManager[id];
    if (msg) {
      const [resolve, reject] = msg;
      delete this.messageManager[id];
      if (error) {
        reject(new Error(error));
      } else {
        resolve(data);
      }
    }
  }
  createWorkers(numWorkers = 1, createImageBitmapSupport) {
    let workerCode = `(${createImageWorker.toString()})()`;
    if (createImageBitmapSupport.options === true) {
      workerCode = workerCode.replace("var supportsOptionsCreateImageBitmap = false;", "var supportsOptionsCreateImageBitmap = true;");
    }
    if (createImageBitmapSupport.full === true) {
      workerCode = workerCode.replace("var supportsOptionsCreateImageBitmap = false;", "var supportsOptionsCreateImageBitmap = true;");
      workerCode = workerCode.replace("var supportsFullCreateImageBitmap = false;", "var supportsFullCreateImageBitmap = true;");
    }
    workerCode = workerCode.replace('"use strict";', "");
    const blob = new Blob([workerCode], {
      type: "application/javascript"
    });
    const blobURL = (self.URL ? URL : webkitURL).createObjectURL(blob);
    const workers = [];
    for (let i = 0; i < numWorkers; i++) {
      workers.push(new Worker(blobURL));
    }
    return workers;
  }
  getNextWorker() {
    const worker = this.workers[this.workerIndex];
    this.workerIndex = (this.workerIndex + 1) % this.workers.length;
    return worker;
  }
  getImage(src, premultiplyAlpha, sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      try {
        if (this.workers) {
          const id = this.nextId++;
          this.messageManager[id] = [resolve, reject];
          const nextWorker = this.getNextWorker();
          if (nextWorker) {
            nextWorker.postMessage({
              id,
              src,
              premultiplyAlpha,
              sx,
              sy,
              sw,
              sh
            });
          }
        }
      } catch (error) {
        reject(error);
      }
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/textures/ColorTexture.js
var _ColorTexture = class _ColorTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "type", TextureType.color);
    __publicField(this, "props");
    this.props = _ColorTexture.resolveDefaults(props);
  }
  get color() {
    return this.props.color;
  }
  set color(color) {
    this.props.color = color;
  }
  async getTextureSource() {
    const pixelData = new Uint8Array(4);
    if (this.color === 4294967295) {
      pixelData[0] = 255;
      pixelData[1] = 255;
      pixelData[2] = 255;
      pixelData[3] = 255;
    } else {
      pixelData[0] = this.color >> 16 & 255;
      pixelData[1] = this.color >> 8 & 255;
      pixelData[2] = this.color & 255;
      pixelData[3] = this.color >>> 24 & 255;
    }
    return {
      data: pixelData,
      premultiplyAlpha: true
    };
  }
  static makeCacheKey(props) {
    const resolvedProps = _ColorTexture.resolveDefaults(props);
    return `ColorTexture,${resolvedProps.color}`;
  }
  static resolveDefaults(props) {
    return {
      color: props.color || 4294967295
    };
  }
};
__publicField(_ColorTexture, "z$__type__Props");
var ColorTexture = _ColorTexture;

// node_modules/@lightningjs/renderer/dist/src/core/lib/textureCompression.js
function isCompressedTextureContainer(src) {
  return /\.(ktx|pvr)$/.test(src);
}
var PVR_MAGIC = 55727696;
var PVR_TO_GL_INTERNAL_FORMAT = {
  0: 35841,
  1: 35843,
  2: 35840,
  3: 35842,
  // PVRTC1
  6: 36196,
  // ETC1
  7: 33776,
  8: 33778,
  9: 33778,
  10: 33779,
  11: 33779
  // DXT variants
};
var ASTC_MAGIC = 1554098963;
var ASTC_TO_GL_INTERNAL_FORMAT = {
  "4x4": 37808,
  // COMPRESSED_RGBA_ASTC_4x4_KHR
  "5x5": 37809,
  // COMPRESSED_RGBA_ASTC_5x5_KHR
  "6x6": 37810,
  // COMPRESSED_RGBA_ASTC_6x6_KHR
  "8x8": 37811,
  // COMPRESSED_RGBA_ASTC_8x8_KHR
  "10x10": 37812,
  // COMPRESSED_RGBA_ASTC_10x10_KHR
  "12x12": 37813
  // COMPRESSED_RGBA_ASTC_12x12_KHR
};
var KTX_IDENTIFIER = [
  171,
  75,
  84,
  88,
  32,
  49,
  49,
  187,
  13,
  10,
  26,
  10
];
var loadCompressedTexture = async (url) => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch compressed texture: ${response.status} ${response.statusText}`);
    }
    const arrayBuffer = await response.arrayBuffer();
    if (arrayBuffer.byteLength < 16) {
      throw new Error(`File too small to be a valid compressed texture (${arrayBuffer.byteLength} bytes). Expected at least 16 bytes for header inspection.`);
    }
    const view = new DataView(arrayBuffer);
    const magic = view.getUint32(0, true);
    if (magic === PVR_MAGIC) {
      return loadPVR(view);
    }
    if (magic === ASTC_MAGIC) {
      return loadASTC(view);
    }
    let isKTX = true;
    for (let i = 0; i < KTX_IDENTIFIER.length; i++) {
      if (view.getUint8(i) !== KTX_IDENTIFIER[i]) {
        isKTX = false;
        break;
      }
    }
    if (isKTX === true) {
      return loadKTX(view);
    } else {
      throw new Error("Unrecognized compressed texture format");
    }
  } catch (error) {
    throw new Error(`Failed to load compressed texture from ${url}: ${error}`);
  }
};
function readUint24(view, offset) {
  return view.getUint8(offset) + (view.getUint8(offset + 1) << 8) + (view.getUint8(offset + 2) << 16);
}
var loadASTC = async function(view) {
  const blockX = view.getUint8(4);
  const blockY = view.getUint8(5);
  const sizeX = readUint24(view, 7);
  const sizeY = readUint24(view, 10);
  if (sizeX === 0 || sizeY === 0) {
    throw new Error(`Invalid ASTC texture dimensions: ${sizeX}x${sizeY}`);
  }
  const expected = Math.ceil(sizeX / blockX) * Math.ceil(sizeY / blockY) * 16;
  const dataSize = view.byteLength - 16;
  if (expected !== dataSize) {
    throw new Error(`Invalid ASTC texture data size: expected ${expected}, got ${dataSize}`);
  }
  const internalFormat = ASTC_TO_GL_INTERNAL_FORMAT[`${blockX}x${blockY}`];
  if (internalFormat === void 0) {
    throw new Error(`Unsupported ASTC block size: ${blockX}x${blockY}`);
  }
  const buffer = view.buffer;
  const mipmaps = [];
  mipmaps.push(buffer.slice(16));
  return {
    data: {
      blockInfo: blockInfoMap[internalFormat],
      glInternalFormat: internalFormat,
      mipmaps,
      width: sizeX,
      height: sizeY,
      type: "astc"
    },
    premultiplyAlpha: false
  };
};
var uploadASTC = function(glw, texture, data) {
  if (glw.getExtension("WEBGL_compressed_texture_astc") === null) {
    throw new Error("ASTC compressed textures not supported by this device");
  }
  glw.bindTexture(texture);
  const { glInternalFormat, mipmaps, width, height } = data;
  const view = new Uint8Array(mipmaps[0]);
  glw.compressedTexImage2D(0, glInternalFormat, width, height, 0, view);
  glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
  glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
};
var loadKTX = async function(view) {
  const endianness = view.getUint32(12, true);
  const littleEndian = endianness === 67305985;
  if (littleEndian === false && endianness !== 16909060) {
    throw new Error("Invalid KTX endianness value");
  }
  const glType = view.getUint32(16, littleEndian);
  const glFormat = view.getUint32(24, littleEndian);
  if (glType !== 0 || glFormat !== 0) {
    throw new Error(`KTX texture is not compressed (glType: ${glType}, glFormat: ${glFormat})`);
  }
  const glInternalFormat = view.getUint32(28, littleEndian);
  if (blockInfoMap[glInternalFormat] === void 0) {
    throw new Error(`Unsupported KTX compressed texture format: 0x${glInternalFormat.toString(16)}`);
  }
  const width = view.getUint32(36, littleEndian);
  const height = view.getUint32(40, littleEndian);
  if (width === 0 || height === 0) {
    throw new Error(`Invalid KTX texture dimensions: ${width}x${height}`);
  }
  const mipmapLevels = view.getUint32(56, littleEndian);
  if (mipmapLevels === 0) {
    throw new Error("KTX texture has no mipmap levels");
  }
  const bytesOfKeyValueData = view.getUint32(60, littleEndian);
  const mipmaps = [];
  const buffer = view.buffer;
  let offset = 64 + bytesOfKeyValueData;
  if (offset > view.byteLength) {
    throw new Error("Invalid KTX file: key/value data exceeds file size");
  }
  for (let i = 0; i < mipmapLevels; i++) {
    const imageSize = view.getUint32(offset, littleEndian);
    offset += 4;
    const end = offset + imageSize;
    mipmaps.push(buffer.slice(offset, end));
    offset = end;
    if (offset % 4 !== 0) {
      offset += 4 - offset % 4;
    }
  }
  return {
    data: {
      blockInfo: blockInfoMap[glInternalFormat],
      glInternalFormat,
      mipmaps,
      width,
      height,
      type: "ktx"
    },
    premultiplyAlpha: false
  };
};
var uploadKTX = function(glw, texture, data) {
  const { glInternalFormat, mipmaps, width, height, blockInfo } = data;
  glw.bindTexture(texture);
  const blockWidth = blockInfo.width;
  const blockHeight = blockInfo.height;
  let w = width;
  let h = height;
  for (let i = 0; i < mipmaps.length; i++) {
    let view = new Uint8Array(mipmaps[i]);
    const uploadW = Math.ceil(w / blockWidth) * blockWidth;
    const uploadH = Math.ceil(h / blockHeight) * blockHeight;
    const expectedBytes = Math.ceil(w / blockWidth) * Math.ceil(h / blockHeight) * blockInfo.bytes;
    if (view.byteLength < expectedBytes) {
      const padded = new Uint8Array(expectedBytes);
      padded.set(view);
      view = padded;
    }
    glw.compressedTexImage2D(i, glInternalFormat, uploadW, uploadH, 0, view);
    w = Math.max(1, w >> 1);
    h = Math.max(1, h >> 1);
  }
  glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
  glw.texParameteri(glw.TEXTURE_MIN_FILTER, mipmaps.length > 1 ? glw.LINEAR_MIPMAP_LINEAR : glw.LINEAR);
};
function pvrtcMipSize(width, height, bpp) {
  const minW = bpp === 2 ? 16 : 8;
  const minH = 8;
  const w = Math.max(width, minW);
  const h = Math.max(height, minH);
  return w * h * bpp / 8;
}
var loadPVR = async function(view) {
  const pixelFormatLow = view.getUint32(8, true);
  const internalFormat = PVR_TO_GL_INTERNAL_FORMAT[pixelFormatLow];
  if (internalFormat === void 0) {
    throw new Error(`Unsupported PVR pixel format: 0x${pixelFormatLow.toString(16)}`);
  }
  const height = view.getInt32(24, true);
  const width = view.getInt32(28, true);
  if (width === 0 || height === 0) {
    throw new Error(`Invalid PVR texture dimensions: ${width}x${height}`);
  }
  const mipmapLevels = view.getInt32(44, true);
  const metadataSize = view.getUint32(48, true);
  const buffer = view.buffer;
  let offset = 52 + metadataSize;
  if (offset > buffer.byteLength) {
    throw new Error("Invalid PVR file: metadata exceeds file size");
  }
  const mipmaps = [];
  const block = blockInfoMap[internalFormat];
  for (let i = 0; i < mipmapLevels; i++) {
    const declaredSize = view.getUint32(offset, true);
    const max = buffer.byteLength - (offset + 4);
    if (declaredSize > 0 && declaredSize <= max) {
      offset += 4;
      const start = offset;
      const end = offset + declaredSize;
      mipmaps.push(buffer.slice(start, end));
      offset = end;
      offset = offset + 3 & ~3;
      continue;
    }
    if (pixelFormatLow === 0 || pixelFormatLow === 1 || pixelFormatLow === 2 || pixelFormatLow === 3) {
      const bpp = pixelFormatLow === 0 || pixelFormatLow === 1 ? 2 : 4;
      const computed = pvrtcMipSize(width >> i, height >> i, bpp);
      mipmaps.push(buffer.slice(offset, offset + computed));
      offset += computed;
      offset = offset + 3 & ~3;
      continue;
    }
    if (block !== void 0) {
      const blockW = Math.ceil((width >> i) / block.width);
      const blockH = Math.ceil((height >> i) / block.height);
      const computed = blockW * blockH * block.bytes;
      mipmaps.push(buffer.slice(offset, offset + computed));
      offset += computed;
      offset = offset + 3 & ~3;
    }
  }
  return {
    data: {
      blockInfo: blockInfoMap[internalFormat],
      glInternalFormat: internalFormat,
      mipmaps,
      width,
      height,
      type: "pvr"
    },
    premultiplyAlpha: false
  };
};
var uploadPVR = function(glw, texture, data) {
  const { glInternalFormat, mipmaps, width, height } = data;
  glw.bindTexture(texture);
  let w = width;
  let h = height;
  for (let i = 0; i < mipmaps.length; i++) {
    glw.compressedTexImage2D(i, glInternalFormat, w, h, 0, new Uint8Array(mipmaps[i]));
    w = Math.max(1, w >> 1);
    h = Math.max(1, h >> 1);
  }
  glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
  glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
  glw.texParameteri(glw.TEXTURE_MIN_FILTER, mipmaps.length > 1 ? glw.LINEAR_MIPMAP_LINEAR : glw.LINEAR);
};
var BLOCK_4x4x8 = { width: 4, height: 4, bytes: 8 };
var BLOCK_4x4x16 = { width: 4, height: 4, bytes: 16 };
var BLOCK_5x5x16 = { width: 5, height: 5, bytes: 16 };
var BLOCK_6x6x16 = { width: 6, height: 6, bytes: 16 };
var BLOCK_8x4x8 = { width: 8, height: 4, bytes: 8 };
var BLOCK_8x8x16 = { width: 8, height: 8, bytes: 16 };
var BLOCK_10x10x16 = { width: 10, height: 10, bytes: 16 };
var BLOCK_12x12x16 = { width: 12, height: 12, bytes: 16 };
var blockInfoMap = {
  // S3TC / DXTn (WEBGL_compressed_texture_s3tc, sRGB variants)
  33776: BLOCK_4x4x8,
  // COMPRESSED_RGB_S3TC_DXT1_EXT
  33777: BLOCK_4x4x8,
  // COMPRESSED_RGBA_S3TC_DXT1_EXT
  33778: BLOCK_4x4x16,
  // COMPRESSED_RGBA_S3TC_DXT3_EXT
  33779: BLOCK_4x4x16,
  // COMPRESSED_RGBA_S3TC_DXT5_EXT
  // ETC1 / ETC2 / EAC
  36196: BLOCK_4x4x8,
  // COMPRESSED_RGB_ETC1_WEBGL
  37492: BLOCK_4x4x8,
  // COMPRESSED_RGB8_ETC2
  37493: BLOCK_4x4x8,
  // COMPRESSED_SRGB8_ETC2
  37496: BLOCK_4x4x16,
  // COMPRESSED_RGBA8_ETC2_EAC
  37497: BLOCK_4x4x16,
  // COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
  // PVRTC (WEBGL_compressed_texture_pvrtc)
  35840: BLOCK_4x4x8,
  // COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  35842: BLOCK_4x4x8,
  // COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  35841: BLOCK_8x4x8,
  // COMPRESSED_RGB_PVRTC_2BPPV1_IMG
  35843: BLOCK_8x4x8,
  // ASTC (WEBGL_compressed_texture_astc)
  37808: BLOCK_4x4x16,
  // COMPRESSED_RGBA_ASTC_4x4_KHR
  37840: BLOCK_4x4x16,
  // COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
  37809: BLOCK_5x5x16,
  // 5x5
  37841: BLOCK_5x5x16,
  37810: BLOCK_6x6x16,
  // 6x6
  37842: BLOCK_6x6x16,
  37811: BLOCK_8x8x16,
  // 8x8
  37843: BLOCK_8x8x16,
  37812: BLOCK_10x10x16,
  // 10x10
  37844: BLOCK_10x10x16,
  37813: BLOCK_12x12x16,
  // 12x12
  37845: BLOCK_12x12x16
};
var uploadCompressedTexture = {
  ktx: uploadKTX,
  pvr: uploadPVR,
  astc: uploadASTC
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/textureSvg.js
function isSvgImage(url) {
  return /\.(svg)(\?.*)?$/.test(url);
}
var loadSvg = (url, width, height, sx, sy, sw, sh) => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    assertTruthy(ctx);
    ctx.imageSmoothingEnabled = true;
    const img = new Image();
    img.onload = () => {
      const x = sx ?? 0;
      const y = sy ?? 0;
      const w = width || img.width;
      const h = height || img.height;
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(img, 0, 0, w, h);
      resolve({
        data: ctx.getImageData(x, y, sw ?? w, sh ?? h),
        premultiplyAlpha: false
      });
    };
    img.onerror = (err) => {
      reject(err);
    };
    img.src = url;
  });
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/utils.js
function fetchJson(url, responseType = "") {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.responseType = responseType;
    xhr.onreadystatechange = function() {
      if (xhr.readyState == XMLHttpRequest.DONE) {
        if (xhr.status === 0 || xhr.status === 200) {
          resolve(xhr.response);
        } else {
          reject(xhr.statusText);
        }
      }
    };
    xhr.open("GET", url, true);
    xhr.send(null);
  });
}

// node_modules/@lightningjs/renderer/dist/src/core/textures/ImageTexture.js
var _ImageTexture = class _ImageTexture extends Texture {
  constructor(txManager, props) {
    const resolvedProps = _ImageTexture.resolveDefaults(props);
    super(txManager);
    __publicField(this, "type", TextureType.image);
    __publicField(this, "props");
    this.props = resolvedProps;
    this.maxRetryCount = resolvedProps.maxRetryCount ?? this.txManager.maxRetryCount;
  }
  hasAlphaChannel(mimeType) {
    return mimeType.indexOf("image/png") !== -1;
  }
  async loadImageFallback(src, hasAlpha) {
    const img = new Image();
    if (typeof src === "string" && isBase64Image(src) === false) {
      img.crossOrigin = "anonymous";
    }
    return new Promise((resolve, reject) => {
      img.onload = () => {
        resolve({ data: img, premultiplyAlpha: hasAlpha });
      };
      img.onerror = (err) => {
        const errorMessage = err instanceof Error ? err.message : err instanceof Event ? `Image loading failed for ${img.src}` : "Unknown image loading error";
        reject(new Error(`Image loading failed: ${errorMessage}`));
      };
      if (src instanceof Blob) {
        img.src = URL.createObjectURL(src);
      } else {
        img.src = src;
      }
    });
  }
  async createImageBitmap(blob, premultiplyAlpha, sx, sy, sw, sh) {
    const hasAlphaChannel = premultiplyAlpha ?? blob.type.includes("image/png");
    const imageBitmapSupported = this.txManager.imageBitmapSupported;
    if (imageBitmapSupported.full === true && sw !== null && sh !== null) {
      try {
        const bitmap = await createImageBitmap(blob, sx || 0, sy || 0, sw, sh, {
          premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
          colorSpaceConversion: "none",
          imageOrientation: "none"
        });
        return { data: bitmap, premultiplyAlpha: hasAlphaChannel };
      } catch (error) {
        throw new Error(`Failed to create image bitmap with crop: ${error}`);
      }
    } else if (imageBitmapSupported.basic === true) {
      try {
        return {
          data: await createImageBitmap(blob),
          premultiplyAlpha: hasAlphaChannel
        };
      } catch (error) {
        throw new Error(`Failed to create basic image bitmap: ${error}`);
      }
    }
    try {
      const bitmap = await createImageBitmap(blob, {
        premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
        colorSpaceConversion: "none",
        imageOrientation: "none"
      });
      return { data: bitmap, premultiplyAlpha: hasAlphaChannel };
    } catch (error) {
      throw new Error(`Failed to create image bitmap with options: ${error}`);
    }
  }
  async loadImage(src) {
    const { premultiplyAlpha, sx, sy, sw, sh } = this.props;
    if (this.txManager.hasCreateImageBitmap === true) {
      if (isBase64Image(src) === false && this.txManager.hasWorker === true && this.txManager.imageWorkerManager !== null) {
        try {
          return this.txManager.imageWorkerManager.getImage(src, premultiplyAlpha, sx, sy, sw, sh);
        } catch (error) {
          throw new Error(`Failed to load image via worker: ${error}`);
        }
      }
      let blob;
      if (isBase64Image(src) === true) {
        blob = dataURIToBlob(src);
      } else {
        try {
          blob = await fetchJson(src, "blob");
        } catch (error) {
          throw new Error(`Failed to fetch image blob from ${src}: ${error}`);
        }
      }
      return this.createImageBitmap(blob, premultiplyAlpha, sx, sy, sw, sh);
    }
    return this.loadImageFallback(src, premultiplyAlpha ?? true);
  }
  async getTextureSource() {
    let resp;
    try {
      resp = await this.determineImageTypeAndLoadImage();
    } catch (e) {
      this.setState("failed", e);
      return {
        data: null
      };
    }
    if (resp.data === null) {
      this.setState("failed", Error("ImageTexture: No image data"));
      return {
        data: null
      };
    }
    return {
      data: resp.data,
      premultiplyAlpha: this.props.premultiplyAlpha ?? true
    };
  }
  determineImageTypeAndLoadImage() {
    const { src, premultiplyAlpha, type } = this.props;
    if (src === null) {
      return {
        data: null
      };
    }
    if (typeof src !== "string") {
      if (src instanceof Blob) {
        if (this.txManager.hasCreateImageBitmap === true) {
          const { sx, sy, sw, sh } = this.props;
          return this.createImageBitmap(src, premultiplyAlpha, sx, sy, sw, sh);
        } else {
          return this.loadImageFallback(src, premultiplyAlpha ?? true);
        }
      }
      if (src instanceof ImageData) {
        return {
          data: src,
          premultiplyAlpha
        };
      }
      return {
        data: src(),
        premultiplyAlpha
      };
    }
    const absoluteSrc = convertUrlToAbsolute(src);
    if (type === "regular") {
      return this.loadImage(absoluteSrc);
    }
    if (type === "svg") {
      return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
    }
    if (isSvgImage(src) === true) {
      return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
    }
    if (type === "compressed") {
      return loadCompressedTexture(absoluteSrc);
    }
    if (isCompressedTextureContainer(src) === true) {
      return loadCompressedTexture(absoluteSrc);
    }
    return this.loadImage(absoluteSrc);
  }
  /**
   * Generates a cache key for the ImageTexture based on the provided props.
   * @param props - The props used to generate the cache key.
   * @returns The cache key as a string, or `false` if the key cannot be generated.
   */
  static makeCacheKey(props) {
    const resolvedProps = _ImageTexture.resolveDefaults(props);
    const key = resolvedProps.key || resolvedProps.src;
    if (typeof key !== "string") {
      return false;
    }
    let dimensionProps = "";
    if (resolvedProps.sh !== null && resolvedProps.sw !== null) {
      dimensionProps += ",";
      dimensionProps += resolvedProps.sx ?? "";
      dimensionProps += resolvedProps.sy ?? "";
      dimensionProps += resolvedProps.sw || "";
      dimensionProps += resolvedProps.sh || "";
    }
    return `ImageTexture,${key},${resolvedProps.premultiplyAlpha ?? "true"}${dimensionProps}`;
  }
  static resolveDefaults(props) {
    return {
      src: props.src ?? "",
      premultiplyAlpha: props.premultiplyAlpha ?? true,
      // null,
      key: props.key ?? null,
      type: props.type ?? null,
      width: props.width ?? null,
      height: props.height ?? null,
      sx: props.sx ?? null,
      sy: props.sy ?? null,
      sw: props.sw ?? null,
      sh: props.sh ?? null,
      maxRetryCount: props.maxRetryCount ?? null
    };
  }
};
__publicField(_ImageTexture, "z$__type__Props");
var ImageTexture = _ImageTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/NoiseTexture.js
var _NoiseTexture = class _NoiseTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "type", TextureType.noise);
    this.props = _NoiseTexture.resolveDefaults(props);
  }
  async getTextureSource() {
    const { width, height } = this.props;
    const size = width * height * 4;
    const pixelData8 = new Uint8ClampedArray(size);
    for (let i = 0; i < size; i += 4) {
      const v = Math.floor(Math.random() * 256);
      pixelData8[i] = v;
      pixelData8[i + 1] = v;
      pixelData8[i + 2] = v;
      pixelData8[i + 3] = 255;
    }
    return {
      data: new ImageData(pixelData8, width, height)
    };
  }
  static makeCacheKey(props) {
    if (props.cacheId === void 0) {
      return false;
    }
    const resolvedProps = _NoiseTexture.resolveDefaults(props);
    return `NoiseTexture,${resolvedProps.width},${resolvedProps.height},${resolvedProps.cacheId}`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 128,
      height: props.height ?? 128,
      cacheId: props.cacheId ?? 0
    };
  }
};
__publicField(_NoiseTexture, "z$__type__Props");
var NoiseTexture = _NoiseTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/SubTexture.js
var subTextureId = 0;
var _SubTexture = class _SubTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "parentTexture");
    __publicField(this, "type", TextureType.subTexture);
    __publicField(this, "subtextureId", `subtexture-${subTextureId++}`);
    __publicField(this, "onParentTxLoaded", () => {
      this.forwardParentTxState("loaded", {
        width: this.props.width,
        height: this.props.height
      });
    });
    __publicField(this, "onParentTxFailed", (target, error) => {
      this.retryCount = this.parentTexture.retryCount - 1;
      this.forwardParentTxState("failed", error);
    });
    __publicField(this, "onParentTxLoading", () => {
      this.forwardParentTxState("loading");
    });
    __publicField(this, "onParentTxFreed", () => {
      this.forwardParentTxState("freed");
    });
    this.props = _SubTexture.resolveDefaults(props || {});
    assertTruthy(this.props.texture, "SubTexture requires a parent texture");
    assertTruthy(this.props.texture instanceof ImageTexture, "SubTexture requires an ImageTexture parent");
    this.parentTexture = txManager.resolveParentTexture(this.props.texture);
    if (this.renderableOwners.length > 0) {
      this.parentTexture.setRenderableOwner(this.subtextureId, true);
    }
    queueMicrotask(() => {
      const parentTx = this.parentTexture;
      if (parentTx.state === "loaded" && parentTx.dimensions) {
        this.onParentTxLoaded(parentTx, parentTx.dimensions);
      } else if (parentTx.state === "loading") {
        this.onParentTxLoading();
      } else if (parentTx.state === "failed" && parentTx.error) {
        this.onParentTxFailed(parentTx, parentTx.error);
      } else if (parentTx.state === "freed") {
        this.onParentTxFreed();
      }
      parentTx.on("loading", this.onParentTxLoading);
      parentTx.on("loaded", this.onParentTxLoaded);
      parentTx.on("failed", this.onParentTxFailed);
      parentTx.on("freed", this.onParentTxFreed);
    });
  }
  forwardParentTxState(state2, errorOrDimensions) {
    this.setState(state2, errorOrDimensions);
  }
  onChangeIsRenderable(isRenderable) {
    this.parentTexture.setRenderableOwner(this.subtextureId, isRenderable);
  }
  async getTextureSource() {
    return {
      data: this.props
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static makeCacheKey(props) {
    return false;
  }
  static resolveDefaults(props) {
    return {
      texture: props.texture,
      x: props.x || 0,
      y: props.y || 0,
      width: props.width || 0,
      height: props.height || 0
    };
  }
};
__publicField(_SubTexture, "z$__type__Props");
var SubTexture = _SubTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/RenderTexture.js
var _RenderTexture = class _RenderTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "type", TextureType.renderToTexture);
    this.props = _RenderTexture.resolveDefaults(props || {});
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    this.props.width = value;
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    this.props.height = value;
  }
  async getTextureSource() {
    return {
      data: null,
      premultiplyAlpha: null
    };
  }
  static resolveDefaults(props) {
    return {
      width: props.width || 256,
      height: props.height || 256
    };
  }
};
__publicField(_RenderTexture, "z$__type__Props");
var RenderTexture = _RenderTexture;

// node_modules/@lightningjs/renderer/dist/src/core/lib/validateImageBitmap.js
async function validateCreateImageBitmap() {
  var _a2, _b, _c;
  const pngBinaryData = new Uint8Array([
    137,
    80,
    78,
    71,
    13,
    10,
    26,
    10,
    // PNG signature
    0,
    0,
    0,
    13,
    // IHDR chunk length
    73,
    72,
    68,
    82,
    // "IHDR" chunk type
    0,
    0,
    0,
    1,
    // Width: 1
    0,
    0,
    0,
    1,
    // Height: 1
    1,
    // Bit depth: 1
    3,
    // Color type: Indexed
    0,
    // Compression method: Deflate
    0,
    // Filter method: None
    0,
    // Interlace method: None
    37,
    219,
    86,
    202,
    // CRC for IHDR
    0,
    0,
    0,
    3,
    // PLTE chunk length
    80,
    76,
    84,
    69,
    // "PLTE" chunk type
    0,
    0,
    0,
    // Palette entry: Black
    167,
    122,
    61,
    218,
    // CRC for PLTE
    0,
    0,
    0,
    1,
    // tRNS chunk length
    116,
    82,
    78,
    83,
    // "tRNS" chunk type
    0,
    // Transparency for black: Fully transparent
    64,
    230,
    216,
    102,
    // CRC for tRNS
    0,
    0,
    0,
    10,
    // IDAT chunk length
    73,
    68,
    65,
    84,
    // "IDAT" chunk type
    8,
    215,
    // Deflate header
    99,
    96,
    0,
    0,
    0,
    2,
    0,
    1,
    // Zlib-compressed data
    226,
    33,
    188,
    51,
    // CRC for IDAT
    0,
    0,
    0,
    0,
    // IEND chunk length
    73,
    69,
    78,
    68,
    // "IEND" chunk type
    174,
    66,
    96,
    130
    // CRC for IEND
  ]);
  const support = {
    basic: false,
    options: false,
    full: false
  };
  const blob = new Blob([pngBinaryData], { type: "image/png" });
  const bitmap = await createImageBitmap(blob);
  (_a2 = bitmap.close) == null ? void 0 : _a2.call(bitmap);
  support.basic = true;
  try {
    const options = { premultiplyAlpha: "none" };
    const bitmapWithOptions = await createImageBitmap(blob, options);
    (_b = bitmapWithOptions.close) == null ? void 0 : _b.call(bitmapWithOptions);
    support.options = true;
  } catch (e) {
  }
  try {
    const bitmapWithFullOptions = await createImageBitmap(blob, 0, 0, 1, 1, {
      premultiplyAlpha: "none"
    });
    (_c = bitmapWithFullOptions.close) == null ? void 0 : _c.call(bitmapWithFullOptions);
    support.full = true;
  } catch (e) {
  }
  return support;
}

// node_modules/@lightningjs/renderer/dist/src/core/TextureError.js
var TextureErrorCode;
(function(TextureErrorCode2) {
  TextureErrorCode2["MEMORY_THRESHOLD_EXCEEDED"] = "MEMORY_THRESHOLD_EXCEEDED";
  TextureErrorCode2["TEXTURE_DATA_NULL"] = "TEXTURE_DATA_NULL";
  TextureErrorCode2["TEXTURE_TYPE_NOT_REGISTERED"] = "TEXTURE_TYPE_NOT_REGISTERED";
})(TextureErrorCode || (TextureErrorCode = {}));
var defaultMessages = {
  [TextureErrorCode.MEMORY_THRESHOLD_EXCEEDED]: "Memory threshold exceeded",
  [TextureErrorCode.TEXTURE_DATA_NULL]: "Texture data is null",
  [TextureErrorCode.TEXTURE_TYPE_NOT_REGISTERED]: "Texture type is not registered"
};
var TextureError = class extends Error {
  constructor(codeOrMessage, maybeMessage) {
    const isCode = Object.values(TextureErrorCode).includes(codeOrMessage);
    const code = isCode ? codeOrMessage : void 0;
    let message;
    if (isCode && code) {
      message = maybeMessage ?? defaultMessages[code];
    } else {
      message = String(codeOrMessage);
    }
    super(message);
    __publicField(this, "code");
    this.name = new.target.name;
    if (code)
      this.code = code;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreTextureManager.js
var CoreTextureManager = class extends EventEmitter {
  constructor(stage2, settings2) {
    super();
    /**
     * Map of textures by cache key
     */
    __publicField(this, "keyCache", /* @__PURE__ */ new Map());
    /**
     * Map of cache keys by texture
     */
    __publicField(this, "inverseKeyCache", /* @__PURE__ */ new WeakMap());
    /**
     * Map of texture constructors by their type name
     */
    __publicField(this, "txConstructors", {});
    __publicField(this, "maxRetryCount");
    __publicField(this, "priorityQueue", []);
    __publicField(this, "uploadTextureQueue", []);
    __publicField(this, "initialized", false);
    __publicField(this, "stage");
    __publicField(this, "numImageWorkers");
    __publicField(this, "imageWorkerManager", null);
    __publicField(this, "hasCreateImageBitmap", !!self.createImageBitmap);
    __publicField(this, "imageBitmapSupported", {
      basic: false,
      options: false,
      full: false
    });
    __publicField(this, "hasWorker", !!self.Worker);
    /**
     * Renderer that this texture manager is associated with
     *
     * @remarks
     * This MUST be set before the texture manager is used. Otherwise errors
     * will occur when using the texture manager.
     */
    __publicField(this, "renderer");
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to populate the `lastRenderableChangeTime` property of
     * {@link Texture} instances when their renderable state changes.
     *
     * Set by stage via `updateFrameTime` method.
     */
    __publicField(this, "frameTime", 0);
    const { numImageWorkers, createImageBitmapSupport, maxRetryCount } = settings2;
    this.stage = stage2;
    this.numImageWorkers = numImageWorkers;
    this.maxRetryCount = maxRetryCount;
    if (createImageBitmapSupport === "auto") {
      validateCreateImageBitmap().then((result) => {
        this.initialize(result);
      }).catch(() => {
        console.warn("[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.");
        this.initialized = true;
        this.emit("initialized");
      });
    } else {
      this.initialize({
        basic: createImageBitmapSupport === "basic",
        options: createImageBitmapSupport === "options",
        full: createImageBitmapSupport === "full"
      });
    }
    this.registerTextureType("ImageTexture", ImageTexture);
    this.registerTextureType("ColorTexture", ColorTexture);
    this.registerTextureType("NoiseTexture", NoiseTexture);
    this.registerTextureType("SubTexture", SubTexture);
    this.registerTextureType("RenderTexture", RenderTexture);
  }
  registerTextureType(textureType, textureClass) {
    this.txConstructors[textureType] = textureClass;
  }
  initialize(support) {
    this.hasCreateImageBitmap = support.basic || support.options || support.full;
    this.imageBitmapSupported = support;
    if (!this.hasCreateImageBitmap) {
      console.warn("[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.");
    }
    if (this.hasCreateImageBitmap && this.hasWorker && this.numImageWorkers > 0) {
      this.imageWorkerManager = new ImageWorkerManager(this.numImageWorkers, support);
    } else {
      console.warn("[Lightning] Imageworker is 0 or not supported on this browser. Image loading will be slower.");
    }
    this.initialized = true;
    this.emit("initialized");
  }
  /**
   * Enqueue a texture for uploading to the GPU.
   *
   * @param texture - The texture to upload
   */
  enqueueUploadTexture(texture) {
    if (this.uploadTextureQueue.includes(texture) === false) {
      this.uploadTextureQueue.push(texture);
    }
  }
  /**
   * Create a texture
   *
   * @param textureType - The type of texture to create
   * @param props - The properties to use for the texture
   */
  createTexture(textureType, props) {
    let texture;
    const TextureClass = this.txConstructors[textureType];
    if (!TextureClass) {
      throw new TextureError(TextureErrorCode.TEXTURE_TYPE_NOT_REGISTERED, `Texture type "${textureType}" is not registered`);
    }
    const cacheKey = TextureClass.makeCacheKey(props);
    if (cacheKey && this.keyCache.has(cacheKey)) {
      texture = this.keyCache.get(cacheKey);
    } else {
      texture = new TextureClass(this, props);
      if (cacheKey) {
        this.initTextureToCache(texture, cacheKey);
      }
    }
    return texture;
  }
  /**
   * Override loadTexture to use the batched approach.
   *
   * @param texture - The texture to load
   * @param immediate - Whether to prioritize the texture for immediate loading
   */
  async loadTexture(texture, priority) {
    if (texture.type === TextureType.subTexture) {
      return;
    }
    if (texture.state === "loaded") {
      return;
    }
    if (texture.state === "loading") {
      return;
    }
    if (this.initialized === false) {
      this.priorityQueue.push(texture);
      return;
    }
    texture.setState("loading");
    const textureDataResult = await texture.getTextureData().catch((err) => {
      console.error(err);
      texture.setState("failed");
      return null;
    });
    if (textureDataResult === null || texture.state === "failed") {
      return;
    }
    const shouldUploadImmediately = texture.type !== TextureType.image || priority === true;
    if (shouldUploadImmediately === true) {
      await this.uploadTexture(texture).catch((err) => {
        console.error(`Failed to upload texture:`, err);
        texture.setState("failed");
      });
      return;
    }
    this.enqueueUploadTexture(texture);
  }
  /**
   * Upload a texture to the GPU
   *
   * @param texture Texture to upload
   * @returns Promise that resolves when the texture is fully loaded
   */
  async uploadTexture(texture) {
    if (this.stage.txMemManager.doNotExceedCriticalThreshold === true && this.stage.txMemManager.criticalCleanupRequested === true) {
      texture.setState("failed", new TextureError(TextureErrorCode.MEMORY_THRESHOLD_EXCEEDED));
      return;
    }
    if (texture.state === "failed" || texture.state === "freed") {
      return;
    }
    if (texture.state === "loaded") {
      return;
    }
    if (texture.textureData === null) {
      texture.setState("failed", new TextureError(TextureErrorCode.TEXTURE_DATA_NULL, "Texture data is null, cannot upload texture"));
      return;
    }
    const coreContext = texture.loadCtxTexture();
    if (coreContext !== null && coreContext.state === "loaded") {
      texture.setState("loaded");
      return;
    }
    await coreContext.load();
  }
  /**
   * Check if a texture is being processed
   */
  isProcessingTexture(texture) {
    return this.uploadTextureQueue.includes(texture) === true;
  }
  /**
   * Process a limited number of uploads.
   *
   * @param maxProcessingTime - The maximum processing time in milliseconds
   */
  async processSome(maxProcessingTime) {
    if (this.initialized === false) {
      return;
    }
    const startTime = getTimeStamp();
    while (this.priorityQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime) {
      const texture = this.priorityQueue.pop();
      try {
        await texture.getTextureData();
        await this.uploadTexture(texture);
      } catch (error) {
        console.error("Failed to process priority texture:", error);
      }
    }
    while (this.uploadTextureQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime) {
      const texture = this.uploadTextureQueue.shift();
      try {
        await this.uploadTexture(texture);
      } catch (error) {
        console.error("Failed to upload texture:", error);
      }
    }
  }
  hasUpdates() {
    return this.uploadTextureQueue.length > 0;
  }
  /**
   * Initialize a texture to the cache
   *
   * @param texture Texture to cache
   * @param cacheKey Cache key for the texture
   */
  initTextureToCache(texture, cacheKey) {
    const { keyCache, inverseKeyCache } = this;
    keyCache.set(cacheKey, texture);
    inverseKeyCache.set(texture, cacheKey);
  }
  /**
   * Get a texture from the cache
   *
   * @param cacheKey
   */
  getTextureFromCache(cacheKey) {
    return this.keyCache.get(cacheKey);
  }
  /**
   * Remove a texture from the cache
   *
   * @remarks
   * Called by Texture Cleanup when a texture is freed.
   *
   * @param texture
   */
  removeTextureFromCache(texture) {
    const { inverseKeyCache, keyCache } = this;
    const cacheKey = inverseKeyCache.get(texture);
    if (cacheKey) {
      keyCache.delete(cacheKey);
    }
  }
  /**
   * Resolve a parent texture from the cache or fallback to the provided texture.
   *
   * @param texture - The provided texture to resolve.
   * @returns The cached or provided texture.
   */
  resolveParentTexture(texture) {
    if (!(texture == null ? void 0 : texture.props)) {
      return texture;
    }
    const cacheKey = ImageTexture.makeCacheKey(texture.props);
    const cachedTexture = cacheKey ? this.getTextureFromCache(cacheKey) : void 0;
    return cachedTexture ?? texture;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TrFontManager.js
var weightConversions = {
  normal: 400,
  bold: 700,
  bolder: 900,
  lighter: 100
};
var fontWeightToNumber = (weight) => {
  if (typeof weight === "number") {
    return weight;
  }
  return weightConversions[weight] || 400;
};
function resolveFontToUse(familyMapsByPriority, family, weightIn, style, stretch) {
  let weight = fontWeightToNumber(weightIn);
  for (const fontFamiles of familyMapsByPriority) {
    const fontFaces = fontFamiles[family];
    if (!fontFaces) {
      continue;
    }
    if (fontFaces.size === 1) {
      console.warn(`TrFontManager: Only one font face found for family: '${family}' - will be used for all weights and styles`);
      return fontFaces.values().next().value;
    }
    const weightMap = /* @__PURE__ */ new Map();
    for (const fontFace of fontFaces) {
      const fontFamilyWeight = fontWeightToNumber(fontFace.descriptors.weight);
      if (fontFamilyWeight === weight && fontFace.descriptors.style === style && fontFace.descriptors.stretch === stretch) {
        return fontFace;
      }
      weightMap.set(fontFamilyWeight, fontFace);
    }
    const msg = `TrFontManager: No exact match: '${family} Weight: ${weight} Style: ${style} Stretch: ${stretch}'`;
    console.error(msg);
    if (weight === 400 && weightMap.has(500)) {
      return weightMap.get(500);
    }
    if (weight === 500 && weightMap.has(400)) {
      return weightMap.get(400);
    }
    if (weight < 400) {
      while (weight > 0) {
        if (weightMap.has(weight)) {
          return weightMap.get(weight);
        }
        weight -= 100;
      }
      weight = 600;
    }
    while (weight < 1e3) {
      if (weightMap.has(weight)) {
        return weightMap.get(weight);
      }
      weight += 100;
    }
    weight = 500;
    while (weight > 0) {
      if (weightMap.has(weight)) {
        return weightMap.get(weight);
      }
      weight -= 100;
    }
  }
  return;
}
var TrFontManager = class {
  constructor(textRenderers) {
    __publicField(this, "textRenderers");
    __publicField(this, "fontCache", /* @__PURE__ */ new Map());
    this.textRenderers = textRenderers;
  }
  addFontFace(font) {
    for (const trId in this.textRenderers) {
      const tr = this.textRenderers[trId];
      if (tr && tr.isFontFaceSupported(font)) {
        tr.addFontFace(font);
      }
    }
  }
  /**
   * Utility method to resolve a single font face from a list of prioritized family maps based on
   * a set of font properties.
   *
   * @remarks
   * These are to be used by a text renderer to resolve a font face if needed.
   *
   * @param familyMapsByPriority
   * @param props
   * @returns
   */
  resolveFontFace(familyMapsByPriority, props, rendererType) {
    const { fontFamily, fontWeight, fontStyle, fontStretch } = props;
    const fontCacheString = `${rendererType}_${fontFamily}_${fontStyle}_${fontWeight}_${fontStretch}`;
    if (this.fontCache.has(fontCacheString) === true) {
      return this.fontCache.get(fontCacheString);
    }
    const resolvedFont = resolveFontToUse(familyMapsByPriority, fontFamily, fontWeight, fontStyle, fontStretch);
    if (resolvedFont !== void 0) {
      this.fontCache.set(fontCacheString, resolvedFont);
    }
    return resolvedFont;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreShader.js
var CoreShader = class {
  // abstract draw(): void;
  static makeCacheKey(props) {
    return false;
  }
  static resolveDefaults(props) {
    return {};
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/ShaderUtils.js
function createShader(glw, type, source) {
  const shader = glw.createShader(type);
  if (!shader) {
    const glError = glw.getError();
    throw new Error(`Unable to create the shader: ${type === glw.VERTEX_SHADER ? "VERTEX_SHADER" : "FRAGMENT_SHADER"}.${glError ? ` WebGlContext Error: ${glError}` : ""}`);
  }
  glw.shaderSource(shader, source);
  glw.compileShader(shader);
  const success = !!glw.getShaderParameter(shader, glw.COMPILE_STATUS);
  if (success) {
    return shader;
  }
  console.error(glw.getShaderInfoLog(shader));
  glw.deleteShader(shader);
}
function createProgram(glw, vertexShader, fragmentShader) {
  const program = glw.createProgram();
  if (!program) {
    throw new Error("Unable to create program");
  }
  glw.attachShader(program, vertexShader);
  glw.attachShader(program, fragmentShader);
  glw.linkProgram(program);
  const success = !!glw.getProgramParameter(program, glw.LINK_STATUS);
  if (success) {
    return program;
  }
  console.warn(glw.getProgramInfoLog(program));
  glw.deleteProgram(program);
  return void 0;
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreShader.js
var WebGlCoreShader = class extends CoreShader {
  constructor(options) {
    super();
    __publicField(this, "buffersBound", false);
    __publicField(this, "program");
    /**
     * Vertex Array Object
     *
     * @remarks
     * Used by WebGL2 Only
     */
    __publicField(this, "vao");
    __publicField(this, "renderer");
    __publicField(this, "glw");
    __publicField(this, "attributeLocations");
    __publicField(this, "uniformLocations");
    __publicField(this, "supportsIndexedTextures");
    const renderer3 = this.renderer = options.renderer;
    const glw = this.glw = this.renderer.glw;
    this.supportsIndexedTextures = options.supportsIndexedTextures || false;
    const webGl2 = glw.isWebGl2();
    const requiredExtensions = webGl2 && options.webgl2Extensions || !webGl2 && options.webgl1Extensions || [];
    const glVersion = webGl2 ? "2.0" : "1.0";
    requiredExtensions.forEach((extensionName) => {
      if (!glw.getExtension(extensionName)) {
        throw new Error(`Shader "${this.constructor.name}" requires extension "${extensionName}" for WebGL ${glVersion} but wasn't found`);
      }
    });
    const shaderSources = options.shaderSources || this.constructor.shaderSources;
    if (!shaderSources) {
      throw new Error(`Shader "${this.constructor.name}" is missing shaderSources.`);
    } else if (webGl2 && (shaderSources == null ? void 0 : shaderSources.webGl2)) {
      shaderSources.fragment = shaderSources.webGl2.fragment;
      shaderSources.vertex = shaderSources.webGl2.vertex;
      delete shaderSources.webGl2;
    }
    const textureUnits = renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    const vertexSource = shaderSources.vertex instanceof Function ? shaderSources.vertex(textureUnits) : shaderSources.vertex;
    const fragmentSource = shaderSources.fragment instanceof Function ? shaderSources.fragment(textureUnits) : shaderSources.fragment;
    const vertexShader = createShader(glw, glw.VERTEX_SHADER, vertexSource);
    const fragmentShader = createShader(glw, glw.FRAGMENT_SHADER, fragmentSource);
    if (!vertexShader || !fragmentShader) {
      throw new Error(`Unable to create the following shader(s): ${[
        !vertexShader && "VERTEX_SHADER",
        !fragmentShader && "FRAGMENT_SHADER"
      ].filter(Boolean).join(" and ")}`);
    }
    const program = createProgram(glw, vertexShader, fragmentShader);
    if (!program) {
      throw new Error("Unable to create program");
    }
    this.program = program;
    this.attributeLocations = glw.getAttributeLocations(this.program);
    this.uniformLocations = glw.getUniformLocations(this.program);
  }
  disableAttribute(location) {
    this.glw.disableVertexAttribArray(location);
  }
  disableAttributes() {
    const glw = this.glw;
    const attribLen = this.attributeLocations.length;
    for (let i = 0; i < attribLen; i++) {
      glw.disableVertexAttribArray(i);
    }
  }
  /**
   * Given two sets of Shader props destined for this Shader, determine if they can be batched together
   * to reduce the number of draw calls.
   *
   * @remarks
   * This is used by the {@link WebGlCoreRenderer} to determine if it can batch multiple consecutive draw
   * calls into a single draw call.
   *
   * By default, this returns false (meaning no batching is allowed), but can be
   * overridden by child classes to provide more efficient batching.
   *
   * @param propsA
   * @param propsB
   * @returns
   */
  canBatchShaderProps(propsA, propsB) {
    return false;
  }
  bindRenderOp(renderOp, props) {
    var _a2;
    this.bindBufferCollection(renderOp.buffers);
    if (renderOp.textures.length > 0 && ((_a2 = renderOp.textures[0]) == null ? void 0 : _a2.ctxTexture)) {
      this.bindTextures(renderOp.textures);
    }
    const { glw, parentHasRenderTexture, renderToTexture } = renderOp;
    if (renderToTexture && parentHasRenderTexture) {
      return;
    }
    if (parentHasRenderTexture) {
      const { width, height } = renderOp.framebufferDimensions || {};
      glw.uniform1f(this.getUniformLocation("u_pixelRatio"), 1);
      glw.uniform2f(this.getUniformLocation("u_resolution"), width ?? 0, height ?? 0);
    } else {
      glw.uniform1f(this.getUniformLocation("u_pixelRatio"), renderOp.options.pixelRatio);
      glw.uniform2f(this.getUniformLocation("u_resolution"), glw.canvas.width, glw.canvas.height);
    }
    if (props) {
      if (hasOwn(props, "$dimensions")) {
        let dimensions = props.$dimensions;
        if (!dimensions) {
          dimensions = renderOp.dimensions;
        }
        glw.uniform2f(this.getUniformLocation("u_dimensions"), dimensions.width, dimensions.height);
      }
      if (hasOwn(props, "$alpha")) {
        let alpha = props.$alpha;
        if (!alpha) {
          alpha = renderOp.alpha;
        }
        glw.uniform1f(this.getUniformLocation("u_alpha"), alpha);
      }
      this.bindProps(props);
    }
  }
  getUniformLocation(name) {
    return this.uniformLocations[name] || null;
  }
  bindBufferCollection(buffer) {
    const { glw } = this;
    const attribs = this.attributeLocations;
    const attribLen = attribs.length;
    for (let i = 0; i < attribLen; i++) {
      const name = attribs[i];
      const resolvedBuffer = buffer.getBuffer(name);
      const resolvedInfo = buffer.getAttributeInfo(name);
      if (resolvedBuffer === void 0 || resolvedInfo === void 0) {
        continue;
      }
      glw.enableVertexAttribArray(i);
      glw.vertexAttribPointer(resolvedBuffer, i, resolvedInfo.size, resolvedInfo.type, resolvedInfo.normalized, resolvedInfo.stride, resolvedInfo.offset);
    }
  }
  bindProps(props) {
  }
  bindTextures(textures) {
  }
  attach() {
    this.glw.useProgram(this.program);
    if (this.glw.isWebGl2() && this.vao) {
      this.glw.bindVertexArray(this.vao);
    }
  }
  detach() {
    this.disableAttributes();
  }
};
__publicField(WebGlCoreShader, "shaderSources");

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DefaultShader.js
var DefaultShader = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3
    });
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
};
__publicField(DefaultShader, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;
      attribute vec2 a_nodeCoordinate;
      attribute vec4 a_color;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;


      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying vec2 v_nodeCoordinate;

      void main() {
        vec2 normalized = a_position * u_pixelRatio;
        vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);

        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;
        v_nodeCoordinate = a_nodeCoordinate;

        gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);
        gl_Position.y = -sign(screenSpace.y) * gl_Position.y;
      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform sampler2D u_texture;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;

      void main() {
          vec4 color = texture2D(u_texture, v_textureCoordinate);
          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DefaultShaderBatched.js
var DefaultShaderBatched = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3
    });
    __publicField(this, "supportsIndexedTextures", true);
  }
  bindTextures(texture) {
    const { renderer: renderer3, glw } = this;
    if (texture.length > renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS) {
      throw new Error(`DefaultShaderBatched: Cannot bind more than ${renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS} textures`);
    }
    texture.forEach((t, i) => {
      glw.activeTexture(i);
      glw.bindTexture(t.ctxTexture);
    });
    const samplers = Array.from(Array(texture.length).keys());
    this.glw.uniform1iv(this.getUniformLocation("u_textures[0]"), samplers);
  }
};
__publicField(DefaultShaderBatched, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_textureCoordinate;
      attribute vec2 a_position;
      attribute vec4 a_color;
      attribute float a_textureIndex;
      attribute float a_depth;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying float v_textureIndex;

      void main(){
        vec2 normalized = a_position * u_pixelRatio / u_resolution;
        vec2 zero_two = normalized * 2.0;
        vec2 clip_space = zero_two - 1.0;

        // pass to fragment
        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;
        v_textureIndex = a_textureIndex;

        // flip y
        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
      }
    `,
  fragment: (textureUnits) => `
      #define txUnits ${textureUnits}
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform sampler2D u_image;
      uniform sampler2D u_textures[txUnits];

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying float v_textureIndex;

      vec4 sampleFromTexture(sampler2D textures[${textureUnits}], int idx, vec2 uv) {
        ${Array.from(Array(textureUnits).keys()).map((idx) => `
          ${idx !== 0 ? "else " : ""}if (idx == ${idx}) {
            return texture2D(textures[${idx}], uv);
          }
        `).join("")}
        return texture2D(textures[0], uv);
      }

      void main(){
        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/ShaderEffect.js
var ShaderEffect = class {
  constructor(options) {
    __publicField(this, "priority", 1);
    __publicField(this, "name", "");
    __publicField(this, "ref");
    __publicField(this, "target");
    __publicField(this, "passParameters", "");
    __publicField(this, "declaredUniforms", "");
    __publicField(this, "uniformInfo", {});
    const { ref, target, props = {} } = options;
    this.ref = ref;
    this.target = target;
    const uniformInfo = {};
    const passParameters = [];
    let declaredUniforms = "";
    const uniforms = this.constructor.uniforms || {};
    for (const u in uniforms) {
      const unif = uniforms[u];
      const uniType = unif.type;
      const uniformName = `${ref}_${u}`;
      let define = "";
      if (unif.size) {
        define = `[${unif.size(props)}]`;
      }
      passParameters.push(uniformName);
      declaredUniforms += `uniform ${uniType} ${uniformName}${define};`;
      uniformInfo[u] = { name: uniformName, uniform: uniforms[u].method };
    }
    this.passParameters = passParameters.join(",");
    this.declaredUniforms = declaredUniforms;
    this.uniformInfo = uniformInfo;
  }
  static getEffectKey(props) {
    return "";
  }
  static getMethodParameters(uniforms, props) {
    const res = [];
    for (const u in uniforms) {
      const uni = uniforms[u];
      let define = "";
      if (uni.size) {
        define = `[${uni.size(props)}]`;
      }
      res.push(`${uni.type} ${u}${define}`);
    }
    return res.join(",");
  }
  static resolveDefaults(props) {
    return {};
  }
  static makeEffectKey(props) {
    return false;
  }
};
__publicField(ShaderEffect, "uniforms", {});
__publicField(ShaderEffect, "methods");
__publicField(ShaderEffect, "onShaderMask");
__publicField(ShaderEffect, "onColorize");
__publicField(ShaderEffect, "onEffectMask");

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DynamicShader.js
var effectCache = /* @__PURE__ */ new Map();
var getResolvedEffect = (effects, effectContructors) => {
  const key = JSON.stringify(effects);
  if (effectCache.has(key)) {
    return effectCache.get(key);
  }
  effects = effects ?? [];
  const resolvedEffects = [];
  const effectsLength = effects.length;
  let i = 0;
  for (; i < effectsLength; i++) {
    const { name, type, props } = effects[i];
    const resolvedEffect = {
      name,
      type,
      props: {}
    };
    const effectConstructor = effectContructors[type];
    const defaultPropValues = effectConstructor.resolveDefaults(props);
    const uniforms = effectConstructor.uniforms;
    const uniformKeys = Object.keys(uniforms);
    const uniformsLength = uniformKeys.length;
    let j = 0;
    for (; j < uniformsLength; j++) {
      const key2 = uniformKeys[j];
      const uniform = uniforms[key2];
      const result = {
        value: defaultPropValues[key2],
        programValue: void 0,
        method: uniform.method,
        updateOnBind: uniform.updateOnBind || false,
        hasValidator: uniform.validator !== void 0,
        hasProgramValueUpdater: uniform.updateProgramValue !== void 0
      };
      const validatedValue = result.hasValidator && uniform.validator(defaultPropValues[key2], defaultPropValues) || defaultPropValues[key2];
      if (defaultPropValues[key2] !== validatedValue) {
        result.validatedValue = validatedValue;
      }
      if (result.hasProgramValueUpdater) {
        uniform.updateProgramValue(result);
      }
      if (result.programValue === void 0) {
        result.programValue = result.value;
      }
      resolvedEffect.props[key2] = result;
    }
    resolvedEffects.push(resolvedEffect);
  }
  effectCache.set(key, resolvedEffects);
  return resolvedEffects;
};
var _DynamicShader = class _DynamicShader extends WebGlCoreShader {
  constructor(renderer3, props, effectContructors) {
    const shader = _DynamicShader.createShader(props, effectContructors);
    super({
      renderer: renderer3,
      shaderSources: {
        vertex: shader.vertex,
        fragment: shader.fragment
      }
    });
    __publicField(this, "effects", []);
    this.effects = shader.effects;
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindUniformMethods(props) {
    const glw = this.glw;
    const effects = props.effects;
    const effectsL = effects.length;
    for (let i = 0; i < effectsL; i++) {
      const uniformInfo = this.effects[i].uniformInfo;
      const effect2 = effects[i];
      const propKeys = Object.keys(effect2.props);
      const propsLength = propKeys.length;
      for (let j = 0; j < propsLength; j++) {
        const key = propKeys[j];
        const method = effect2.props[key].method;
        const location = this.getUniformLocation(uniformInfo[key].name);
        if (method === "uniform2fv" || method === "uniform2iv" || //uniform === 'uniform3fv	' || <--- check why this isnt recognized
        method === "uniform3iv" || method === "uniform4fv" || method === "uniform4iv" || method === "uniformMatrix2fv" || method === "uniformMatrix3fv" || method === "uniformMatrix4fv" || method === "uniform1f" || method === "uniform1fv" || method === "uniform1i" || method === "uniform1iv") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue);
          };
          continue;
        }
        if (method === "uniform2f" || method === "uniform2i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1]);
          };
          continue;
        }
        if (method === "uniform3f" || method === "uniform3i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2]);
          };
          continue;
        }
        if (method === "uniform4f" || method === "uniform4i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2], this.programValue[3]);
          };
          continue;
        }
      }
    }
  }
  bindProps(props) {
    var _a2;
    const effects = props.effects;
    const effectsL = effects.length;
    let i = 0;
    for (; i < effectsL; i++) {
      const effect2 = effects[i];
      const propKeys = Object.keys(effect2.props);
      const propsLength = propKeys.length;
      let j = 0;
      for (; j < propsLength; j++) {
        const key = propKeys[j];
        const prop = effect2.props[key];
        if (prop.updateOnBind === true) {
          const uniform = (_a2 = this.renderer.shManager.getRegisteredEffects()[effect2.type]) == null ? void 0 : _a2.uniforms[key];
          uniform == null ? void 0 : uniform.updateProgramValue(effect2.props[key], props);
        }
        prop.setUniformValue();
      }
    }
  }
  canBatchShaderProps(propsA, propsB) {
    if (propsA.$alpha !== propsB.$alpha || propsA.$dimensions.width !== propsB.$dimensions.width || propsA.$dimensions.height !== propsB.$dimensions.height || propsA.effects.length !== propsB.effects.length) {
      return false;
    }
    const propsEffectsLen = propsA.effects.length;
    let i = 0;
    for (; i < propsEffectsLen; i++) {
      const effectA = propsA.effects[i];
      const effectB = propsB.effects[i];
      if (effectA.type !== effectB.type) {
        return false;
      }
      for (const key in effectA.props) {
        if (effectB.props && !effectB.props[key] || effectA.props[key].value !== effectB.props[key].value) {
          return false;
        }
      }
    }
    return true;
  }
  static createShader(props, effectContructors) {
    const effectNameCount = {};
    const methods = {};
    let declareUniforms = "";
    const uniforms = [];
    const uFx = [];
    const effects = props.effects.map((effect2) => {
      const baseClass = effectContructors[effect2.type];
      const key = baseClass.getEffectKey(effect2.props || {});
      effectNameCount[key] = effectNameCount[key] ? ++effectNameCount[key] : 1;
      const nr = effectNameCount[key];
      if (nr === 1) {
        uFx.push({ key, type: effect2.type, props: effect2.props });
      }
      const fxClass = new baseClass({
        ref: `${key}${nr === 1 ? "" : nr}`,
        target: key,
        props: effect2.props
      });
      declareUniforms += fxClass.declaredUniforms;
      uniforms.push(...Object.values(fxClass.uniformInfo));
      return fxClass;
    });
    let effectMethods = "";
    uFx == null ? void 0 : uFx.forEach((fx) => {
      const fxClass = effectContructors[fx.type];
      const fxProps = fxClass.resolveDefaults(fx.props ?? {});
      const remap = [];
      for (const m in fxClass.methods) {
        let cm = m;
        const fxMethod = fxClass.methods[m];
        if (methods[m] && methods[m] !== fxMethod) {
          cm = _DynamicShader.resolveMethodDuplicate(m, fxMethod, methods);
        }
        methods[cm] = fxMethod.replace("function", cm);
        remap.push({ m, cm });
      }
      let onShaderMask = fxClass.onShaderMask instanceof Function ? fxClass.onShaderMask(fxProps) : fxClass.onShaderMask;
      let onColorize = fxClass.onColorize instanceof Function ? fxClass.onColorize(fxProps) : fxClass.onColorize;
      let onEffectMask = fxClass.onEffectMask instanceof Function ? fxClass.onEffectMask(fxProps) : fxClass.onEffectMask;
      remap.forEach((r) => {
        const { m, cm } = r;
        const reg = new RegExp(`\\$${m}`, "g");
        if (onShaderMask) {
          onShaderMask = onShaderMask.replace(reg, cm);
        }
        if (onColorize) {
          onColorize = onColorize.replace(reg, cm);
        }
        if (onEffectMask) {
          onEffectMask = onEffectMask.replace(reg, cm);
        }
      });
      const methodParameters = fxClass.getMethodParameters(fxClass.uniforms, fxProps);
      const pm = methodParameters.length > 0 ? `, ${methodParameters}` : "";
      if (onShaderMask) {
        effectMethods += `
        float fx_${fx.key}_onShaderMask(float shaderMask ${pm}) {
          ${onShaderMask}
        }
        `;
      }
      if (onColorize) {
        effectMethods += `
          vec4 fx_${fx.key}_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor${pm}) {
            ${onColorize}
          }
        `;
      }
      if (onEffectMask) {
        effectMethods += `
          vec4 fx_${fx.key}_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor${pm}) {
            ${onEffectMask}
          }
        `;
      }
    });
    let sharedMethods = "";
    for (const m in methods) {
      sharedMethods += methods[m];
    }
    let currentMask = `mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))`;
    let drawEffects = `

    `;
    for (let i = 0; i < effects.length; i++) {
      const current = effects[i];
      const pm = current.passParameters.length > 0 ? `, ${current.passParameters}` : "";
      const currentClass = effectContructors[current.name];
      if (currentClass.onShaderMask) {
        drawEffects += `
        shaderMask = fx_${current.target}_onShaderMask(shaderMask ${pm});
        `;
      }
      if (currentClass.onColorize) {
        drawEffects += `
        maskColor = fx_${current.target}_onColorize(shaderMask, maskColor, shaderColor${pm});
        `;
      }
      if (currentClass.onEffectMask) {
        currentMask = `fx_${current.target}_onEffectMask(shaderMask, maskColor, shaderColor${pm})`;
      }
      const next = effects[i + 1];
      if (next === void 0 || effectContructors[next.name].onEffectMask) {
        drawEffects += `
          shaderColor = ${currentMask};
        `;
      }
    }
    return {
      effects,
      uniforms,
      fragment: _DynamicShader.fragment(declareUniforms, sharedMethods, effectMethods, drawEffects),
      vertex: _DynamicShader.vertex()
    };
  }
  static resolveMethodDuplicate(key, effectMethod, methodCollection, increment = 0) {
    const m = key + (increment > 0 ? increment : "");
    if (methodCollection[m] && methodCollection[m] !== effectMethod) {
      return this.resolveMethodDuplicate(key, effectMethod, methodCollection, ++increment);
    }
    return m;
  }
  static resolveDefaults(props, effectContructors) {
    assertTruthy(effectContructors);
    return {
      effects: getResolvedEffect(props.effects ?? [], effectContructors),
      $dimensions: {
        width: 0,
        height: 0
      },
      $alpha: 0
    };
  }
  static makeCacheKey(props, effectContructors) {
    var _a2;
    let fx = "";
    (_a2 = props.effects) == null ? void 0 : _a2.forEach((effect2) => {
      const baseClass = effectContructors[effect2.type];
      const key = baseClass.getEffectKey(effect2.props || {});
      fx += `,${key}`;
    });
    return `DynamicShader${fx}`;
  }
};
__publicField(_DynamicShader, "z$__type__Props");
__publicField(_DynamicShader, "vertex", () => `
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision mediump float;
    # endif

    attribute vec2 a_textureCoordinate;
    attribute vec2 a_nodeCoordinate;
    attribute vec2 a_position;
    attribute vec4 a_color;
    attribute float a_textureIndex;

    uniform vec2 u_resolution;
    uniform float u_pixelRatio;

    varying vec4 v_color;
    varying vec2 v_textureCoordinate;
    varying float v_textureIndex;
    varying vec2 v_nodeCoordinate;

    void main(){
      vec2 normalized = a_position * u_pixelRatio / u_resolution;
      vec2 zero_two = normalized * 2.0;
      vec2 clip_space = zero_two - 1.0;

      // pass to fragment
      v_color = a_color;
      v_textureCoordinate = a_textureCoordinate;
      v_textureIndex = a_textureIndex;
      v_nodeCoordinate = a_nodeCoordinate;

      // flip y
      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
    }
  `);
__publicField(_DynamicShader, "fragment", (uniforms, methods, effectMethods, drawEffects) => `
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision mediump float;
    # endif

    #define PI 3.14159265359

    uniform vec2 u_resolution;
    uniform vec2 u_dimensions;
    uniform float u_alpha;
    uniform float u_radius;
    uniform sampler2D u_texture;
    uniform float u_pixelRatio;

    ${uniforms}

    varying vec4 v_color;
    varying vec2 v_textureCoordinate;
    varying vec2 v_nodeCoordinate;

    ${methods}

    ${effectMethods}

    void main() {
      vec2 p = v_nodeCoordinate.xy * u_dimensions - u_dimensions * 0.5;
      vec2 d = abs(p) - (u_dimensions) * 0.5;
      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));

      vec4 shaderColor = vec4(0.0);
      float shaderMask = lng_DefaultMask;

      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;

      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));

      ${drawEffects}

      gl_FragColor = shaderColor * u_alpha;
    }
  `);
var DynamicShader = _DynamicShader;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/RoundedRectangle.js
var RoundedRectangle = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3
    });
  }
  static resolveDefaults(props) {
    return {
      radius: props.radius || 10,
      $dimensions: {
        width: 0,
        height: 0
      }
    };
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindProps(props) {
    const radiusFactor = Math.min(props.$dimensions.width, props.$dimensions.height) / (2 * props.radius);
    this.glw.uniform1f(this.getUniformLocation("u_radius"), props.radius * Math.min(radiusFactor, 1));
  }
  canBatchShaderProps(propsA, propsB) {
    return propsA.radius === propsB.radius && propsA.$dimensions.width === propsB.$dimensions.width && propsA.$dimensions.height === propsB.$dimensions.height;
  }
};
__publicField(RoundedRectangle, "z$__type__Props");
__publicField(RoundedRectangle, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;
      attribute vec4 a_color;
      attribute float a_textureIndex;
      attribute vec2 a_nodeCoordinate;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying vec2 v_nodeCoordinate;

      void main() {
        vec2 normalized = a_position * u_pixelRatio / u_resolution;
        vec2 zero_two = normalized * 2.0;
        vec2 clip_space = zero_two - 1.0;

        // pass to fragment
        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;
        v_nodeCoordinate = a_nodeCoordinate;

        // flip y
        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform vec2 u_dimensions;
      uniform float u_radius;
      uniform sampler2D u_texture;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying vec2 v_nodeCoordinate;

      float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }

      float fillMask(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }

      void main() {
        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;
        vec2 halfDimensions = u_dimensions * 0.5;

        float d = boxDist(v_nodeCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);
        gl_FragColor = mix(vec4(0.0), color, fillMask(d));
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/SdfShader.js
var IDENTITY_MATRIX_3x3 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var _SdfShader = class _SdfShader extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3
    });
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindProps(props) {
    const resolvedProps = _SdfShader.resolveDefaults(props);
    for (const key in resolvedProps) {
      if (key === "transform") {
        this.glw.uniformMatrix3fv(this.getUniformLocation("u_transform"), resolvedProps[key]);
      } else if (key === "scrollY") {
        this.glw.uniform1f(this.getUniformLocation("u_scrollY"), resolvedProps[key]);
      } else if (key === "color") {
        const components = getNormalizedRgbaComponents(resolvedProps.color);
        this.glw.uniform4fv(this.getUniformLocation("u_color"), components);
      } else if (key === "size") {
        this.glw.uniform1f(this.getUniformLocation("u_size"), resolvedProps[key]);
      } else if (key === "distanceRange") {
        this.glw.uniform1f(this.getUniformLocation("u_distanceRange"), resolvedProps[key]);
      } else if (key === "debug") {
        this.glw.uniform1i(this.getUniformLocation("u_debug"), resolvedProps[key] ? 1 : 0);
      }
    }
  }
  static resolveDefaults(props = {}) {
    return {
      transform: props.transform ?? IDENTITY_MATRIX_3x3,
      scrollY: props.scrollY ?? 0,
      color: props.color ?? 4294967295,
      size: props.size ?? 16,
      distanceRange: props.distanceRange ?? 1,
      debug: props.debug ?? false
    };
  }
};
__publicField(_SdfShader, "z$__type__Props");
__publicField(_SdfShader, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif
      // an attribute is an input (in) to a vertex shader.
      // It will receive data from a buffer
      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;

      uniform vec2 u_resolution;
      uniform mat3 u_transform;
      uniform float u_scrollY;
      uniform float u_pixelRatio;
      uniform float u_size;

      varying vec2 v_texcoord;

      void main() {
        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);
        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;

        // Calculate screen space with pixel ratio
        vec2 screenSpace = (transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1);

        gl_Position = vec4(screenSpace, 0.0, 1.0);
        v_texcoord = a_textureCoordinate;

      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif
      uniform vec4 u_color;
      uniform sampler2D u_texture;
      uniform float u_distanceRange;
      uniform float u_pixelRatio;
      uniform int u_debug;

      varying vec2 v_texcoord;

      float median(float r, float g, float b) {
          return max(min(r, g), min(max(r, g), b));
      }

      void main() {
          vec3 sample = texture2D(u_texture, v_texcoord).rgb;
          if (u_debug == 1) {
            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);
            return;
          }
          float scaledDistRange = u_distanceRange * u_pixelRatio;
          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);
          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;

          // Build the final color.
          // IMPORTANT: We must premultiply the color by the alpha value before returning it.
          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);
      }
    `
});
var SdfShader = _SdfShader;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/EffectUtils.js
var updateShaderEffectColor = (values) => {
  if (values.programValue === void 0) {
    values.programValue = new Float32Array(4);
  }
  const rgba2 = values.value;
  const floatArray = values.programValue;
  floatArray[0] = (rgba2 >>> 24) / 255;
  floatArray[1] = (rgba2 >>> 16 & 255) / 255;
  floatArray[2] = (rgba2 >>> 8 & 255) / 255;
  floatArray[3] = (rgba2 & 255) / 255;
};
var updateFloat32ArrayLength2 = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const floatArray = values.programValue;
    floatArray[0] = validatedValue[0];
    floatArray[1] = validatedValue[1];
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var updateFloat32ArrayLength4 = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const floatArray = values.programValue;
    floatArray[0] = validatedValue[0];
    floatArray[1] = validatedValue[1];
    floatArray[2] = validatedValue[2];
    floatArray[3] = validatedValue[3];
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var updateFloat32ArrayLengthN = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const len = validatedValue.length;
    const programValue = values.programValue;
    for (let i = 0; i < len; i++) {
      programValue[i] = validatedValue[i];
    }
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var validateArrayLength4 = (value) => {
  const isArray = Array.isArray(value);
  if (!isArray) {
    return [value, value, value, value];
  } else if (isArray && value.length === 4) {
    return value;
  } else if (isArray && value.length === 2) {
    return [value[0], value[1], value[0], value[1]];
  } else if (isArray && value.length === 3) {
    return [value[0], value[1], value[2], value[0]];
  }
  return [value[0], value[0], value[0], value[0]];
};
var updateWebSafeRadius = (values, shaderProps) => {
  if (values.programValue === void 0) {
    values.programValue = new Float32Array(4);
  }
  const programValue = values.programValue;
  const validatedValue = values.validatedValue || values.value;
  if (shaderProps === void 0 && values.$dimensions === void 0) {
    programValue[0] = validatedValue[0];
    programValue[1] = validatedValue[1];
    programValue[2] = validatedValue[2];
    programValue[3] = validatedValue[3];
    return;
  }
  let storedDimensions = values.$dimensions;
  if (shaderProps !== void 0) {
    const { $dimensions } = shaderProps;
    if (storedDimensions !== void 0 && (storedDimensions.width === $dimensions.width || storedDimensions.height === $dimensions.height)) {
      return;
    }
    if (storedDimensions === void 0) {
      storedDimensions = {
        width: $dimensions == null ? void 0 : $dimensions.width,
        height: $dimensions == null ? void 0 : $dimensions.height
      };
      values.$dimensions = storedDimensions;
    }
  }
  const { width, height } = storedDimensions;
  const [r0, r1, r2, r3] = validatedValue;
  const factor = Math.min(Math.min(Math.min(width / Math.max(width, r0 + r1), width / Math.max(width, r2 + r3)), Math.min(height / Math.max(height, r0 + r2), height / Math.max(height, r1 + r3))), 1);
  programValue[0] = r0 * factor;
  programValue[1] = r1 * factor;
  programValue[2] = r2 * factor;
  programValue[3] = r3 * factor;
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadiusEffect.js
var RadiusEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radius");
  }
  static getEffectKey() {
    return `radius`;
  }
  static resolveDefaults(props) {
    return {
      radius: props.radius ?? 10
    };
  }
};
__publicField(RadiusEffect, "z$__type__Props");
__publicField(RadiusEffect, "uniforms", {
  radius: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    updateOnBind: true,
    validator: validateArrayLength4,
    updateProgramValue: updateWebSafeRadius
  }
});
__publicField(RadiusEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  boxDist: `
      float function(vec2 p, vec2 size, float radius) {
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }
    `
});
__publicField(RadiusEffect, "onShaderMask", `
  vec2 halfDimensions = u_dimensions * 0.5;
  vec2 p = v_nodeCoordinate.xy * u_dimensions - halfDimensions;
  vec4 r = radius;
  r.xy = (p.x > 0.0) ? r.yz : r.xw;
  float cornerRadius = (p.y > 0.0) ? r.y : r.x;
  return $boxDist(p, halfDimensions, cornerRadius);
  `);
__publicField(RadiusEffect, "onEffectMask", `
  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderEffect.js
var BorderEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "border");
  }
  static getEffectKey() {
    return `border`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderEffect, "z$__type__Props");
__publicField(BorderEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderEffect, "onEffectMask", `
  float intR = shaderMask + 1.0;
  float mask = clamp(intR + width, 0.0, 1.0) - clamp(intR, 0.0, 1.0);
  return mix(shaderColor, mix(shaderColor, maskColor, maskColor.a), mask);
  `);
__publicField(BorderEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/LinearGradientEffect.js
var LinearGradientEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "linearGradient");
  }
  static getEffectKey(props) {
    if (props.colors.value) {
      return `linearGradient${props.colors.value.length}`;
    }
    return `linearGradient${props.colors.length}`;
  }
  static resolveDefaults(props) {
    const colors = props.colors ?? [4278190080, 4294967295];
    let stops = props.stops || [];
    if (stops.length === 0 || stops.length !== colors.length) {
      const colorsL = colors.length;
      let i = 0;
      const tmp = stops;
      for (; i < colorsL; i++) {
        if (stops[i]) {
          tmp[i] = stops[i];
          if (stops[i - 1] === void 0 && tmp[i - 2] !== void 0) {
            tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
          }
        } else {
          tmp[i] = i * (1 / (colors.length - 1));
        }
      }
      stops = tmp;
    }
    return {
      colors,
      stops,
      angle: props.angle ?? 0
    };
  }
};
__publicField(LinearGradientEffect, "z$__type__Props");
__publicField(LinearGradientEffect, "uniforms", {
  angle: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  colors: {
    value: 4294967295,
    validator: (rgbas) => {
      return rgbas.reduce((acc, val) => acc.concat(getNormalizedRgbaComponents(val)), []);
    },
    updateProgramValue: updateFloat32ArrayLengthN,
    size: (props) => props.colors.length,
    method: "uniform4fv",
    type: "vec4"
  },
  stops: {
    value: [],
    size: (props) => props.colors.length,
    method: "uniform1fv",
    type: "float"
  }
});
__publicField(LinearGradientEffect, "methods", {
  calcPoint: `
      vec2 function(float d, float angle) {
        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);
      }
    `
});
__publicField(LinearGradientEffect, "ColorLoop", (amount) => {
  let loop = "";
  for (let i = 2; i < amount; i++) {
    loop += `colorOut = mix(colorOut, colors[${i}], clamp((dist - stops[${i - 1}]) / (stops[${i}] - stops[${i - 1}]), 0.0, 1.0));`;
  }
  return loop;
});
__publicField(LinearGradientEffect, "onColorize", (props) => {
  const colors = props.colors.length || 1;
  return `
      float a = angle - (PI / 180.0 * 90.0);
      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));
      vec2 f = $calcPoint(lineDist * 0.5, a);
      vec2 t = $calcPoint(lineDist * 0.5, a + PI);
      vec2 gradVec = t - f;
      float dist = dot(v_nodeCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);

      //return early if dist is lower or equal to first stop
      if(dist <= stops[0]) {
        return mix(maskColor, colors[0], clamp(colors[0].a, 0.0, 1.0));
      }
      const int amount = ${colors};
      const int last = amount - 1;

      if(dist >= stops[last]) {
        return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));
      }

      for(int i = 0; i < last; i++) {
        float left = stops[i];
        float right = stops[i + 1];
        if(dist >= left && dist <= right) {
          float localDist = smoothstep(left, right, dist);
          vec4 colorOut = mix(colors[i], colors[i + 1], localDist);
          return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));
        }
      }

      //final fallback
      return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));
    `;
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/GrayscaleEffect.js
var GrayscaleEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "grayscale");
  }
  static getEffectKey() {
    return `grayscale`;
  }
  static resolveDefaults(props) {
    return {
      amount: props.amount ?? 1
    };
  }
};
__publicField(GrayscaleEffect, "uniforms", {
  amount: {
    value: 1,
    method: "uniform1f",
    type: "float"
  }
});
__publicField(GrayscaleEffect, "onColorize", `
    float grayness = 0.2 * maskColor.r + 0.6 * maskColor.g + 0.2 * maskColor.b;
    return vec4(amount * vec3(grayness) + (1.0 - amount) * maskColor.rgb, maskColor.a);
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderRightEffect.js
var BorderRightEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderRight");
  }
  static getEffectKey() {
    return `borderRight`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderRightEffect, "z$__type__Props");
__publicField(BorderRightEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderRightEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderRightEffect, "onEffectMask", `
  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);
  float mask = $rectDist(v_nodeCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderRightEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderTopEffect.js
var BorderTopEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderTop");
  }
  static getEffectKey() {
    return `borderTop`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderTopEffect, "z$__type__Props");
__publicField(BorderTopEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderTopEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderTopEffect, "onEffectMask", `
  vec2 pos = vec2(0.0, width * 0.5);
  float mask = $rectDist(v_nodeCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderTopEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderBottomEffect.js
var BorderBottomEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderBottom");
  }
  static getEffectKey() {
    return `borderBottom`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderBottomEffect, "z$__type__Props");
__publicField(BorderBottomEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderBottomEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderBottomEffect, "onEffectMask", `
  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);
  float mask = $rectDist(v_nodeCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderBottomEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderLeftEffect.js
var BorderLeftEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderLeft");
  }
  static getEffectKey() {
    return `borderLeft`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderLeftEffect, "z$__type__Props");
__publicField(BorderLeftEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderLeftEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderLeftEffect, "onEffectMask", `
  vec2 pos = vec2(width * 0.5, 0.0);
  float mask = $rectDist(v_nodeCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderLeftEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/GlitchEffect.js
var GlitchEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "glitch");
  }
  static getEffectKey(props) {
    return `glitch`;
  }
  static resolveDefaults(props) {
    return {
      amplitude: props.amplitude ?? 0.2,
      narrowness: props.narrowness ?? 4,
      blockiness: props.blockiness ?? 2,
      minimizer: props.minimizer ?? 8,
      time: props.time ?? Date.now()
    };
  }
};
__publicField(GlitchEffect, "z$__type__Props");
__publicField(GlitchEffect, "uniforms", {
  amplitude: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  narrowness: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  blockiness: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  minimizer: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  time: {
    value: 0,
    method: "uniform1f",
    updateOnBind: true,
    updateProgramValue: (values) => {
      const value = values.value = (Date.now() - values.value) % 1e3;
      values.programValue = value;
    },
    type: "float"
  }
});
__publicField(GlitchEffect, "methods", {
  rand: `
      float function(vec2 p, float time) {
        float t = floor(time * 20.) / 10.;
        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);
      }
    `,
  noise: `
      float function(vec2 uv, float blockiness, float time) {
        vec2 lv = fract(uv);
        vec2 id = floor(uv);

        float n1 = rand(id, time);
        float n2 = rand(id+vec2(1,0), time);
        float n3 = rand(id+vec2(0,1), time);
        float n4 = rand(id+vec2(1,1), time);
        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);
        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);
      }
    `,
  fbm: `
      float function(vec2 uv, int count, float blockiness, float complexity, float time) {
        float val = 0.0;
        float amp = 0.5;
        const int MAX_ITERATIONS = 10;

        for(int i = 0; i < MAX_ITERATIONS; i++) {
          if(i >= count) {break;}
          val += amp * noise(uv, blockiness, time);
          amp *= 0.5;
          uv *= complexity;
        }
        return val;
      }
    `
});
__publicField(GlitchEffect, "onColorize", `
    vec2 uv = v_textureCoordinate.xy;
    float aspect = u_dimensions.x / u_dimensions.y;
    vec2 a = vec2(uv.x * aspect , uv.y);
    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));

    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);
    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);
    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);
    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);

    vec3 f = vec3(colR, colG, colB);
    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/FadeOutEffect.js
var FadeOutEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "fadeOut");
  }
  static getEffectKey() {
    return `fadeOut`;
  }
  static resolveDefaults(props) {
    return {
      fade: props.fade ?? 10
    };
  }
};
__publicField(FadeOutEffect, "z$__type__Props");
__publicField(FadeOutEffect, "uniforms", {
  fade: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    validator: validateArrayLength4,
    updateProgramValue: updateFloat32ArrayLength4
  }
});
__publicField(FadeOutEffect, "onColorize", `
  vec2 point = v_nodeCoordinate.xy * u_dimensions.xy;
  vec2 pos1;
  vec2 pos2;
  vec2 d;
  float c;
  vec4 result = maskColor;


  if(fade[0] > 0.0) {
    pos1 = vec2(point.x, point.y);
    pos2 = vec2(point.x, point.y + fade[0]);
    d = pos2 - pos1;
    c = dot(pos1, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[1] > 0.0) {
    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_nodeCoordinate.y);
    pos2 = vec2(point.x - u_dimensions.x, v_nodeCoordinate.y);
    d = pos1 - pos2;
    c = dot(pos2, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[2] > 0.0) {
    pos1 = vec2(v_nodeCoordinate.x, point.y - u_dimensions.y - fade[2]);
    pos2 = vec2(v_nodeCoordinate.x, point.y - u_dimensions.y);
    d = pos1 - pos2;
    c = dot(pos2, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[3] > 0.0) {
    pos1 = vec2(point.x, point.y);
    pos2 = vec2(point.x + fade[3], point.y);
    d = pos2 - pos1;
    c = dot(pos1, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  return result;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadialGradientEffect.js
var RadialGradientEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radialGradient");
  }
  static getEffectKey(props) {
    if (props.colors.value) {
      return `radialGradient${props.colors.value.length}`;
    }
    return `radialGradient${props.colors.length}`;
  }
  static resolveDefaults(props) {
    const colors = props.colors ?? [4278190080, 4294967295];
    let stops = props.stops || [];
    if (stops.length === 0 || stops.length !== colors.length) {
      const colorsL = colors.length;
      let i = 0;
      const tmp = stops;
      for (; i < colorsL; i++) {
        if (stops[i]) {
          tmp[i] = stops[i];
          if (stops[i - 1] === void 0 && tmp[i - 2] !== void 0) {
            tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
          }
        } else {
          tmp[i] = i * (1 / (colors.length - 1));
        }
      }
      stops = tmp;
    }
    return {
      colors,
      stops,
      width: props.width ?? 0,
      height: props.height ?? props.width ?? 0,
      pivot: props.pivot ?? [0.5, 0.5]
    };
  }
};
__publicField(RadialGradientEffect, "z$__type__Props");
__publicField(RadialGradientEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  height: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  pivot: {
    value: [0.5, 0.5],
    updateProgramValue: updateFloat32ArrayLength2,
    method: "uniform2fv",
    type: "vec2"
  },
  colors: {
    value: 4294967295,
    validator: (rgbas) => {
      return rgbas.reduce((acc, val) => acc.concat(getNormalizedRgbaComponents(val)), []);
    },
    updateProgramValue: updateFloat32ArrayLengthN,
    size: (props) => props.colors.length,
    method: "uniform4fv",
    type: "vec4"
  },
  stops: {
    value: [],
    size: (props) => props.colors.length,
    method: "uniform1fv",
    type: "float"
  }
});
__publicField(RadialGradientEffect, "methods", {
  getGradientColor: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `
});
__publicField(RadialGradientEffect, "ColorLoop", (amount) => {
  let loop = "";
  for (let i = 2; i < amount; i++) {
    loop += `colorOut = mix(colorOut, colors[${i}], clamp((dist - stops[${i - 1}]) / (stops[${i}] - stops[${i - 1}]), 0.0, 1.0));`;
  }
  return loop;
});
__publicField(RadialGradientEffect, "onColorize", (props) => {
  const colors = props.colors.length || 1;
  return `
      vec2 point = v_nodeCoordinate.xy * u_dimensions;
      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);

      float dist = length((point - projection) / vec2(width, height));

      dist = clamp(dist, 0.0, 1.0);
      //return early if dist is lower or equal to first stop
      if(dist <= stops[0]) {
        return mix(maskColor, colors[0], clamp(colors[0].a, 0.0, 1.0));
      }
      const int amount = ${colors};
      const int last = amount - 1;

      if(dist >= stops[last]) {
        return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));
      }

      for(int i = 0; i < last; i++) {
        float left = stops[i];
        float right = stops[i + 1];
        if(dist >= left && dist <= right) {
          float localDist = smoothstep(left, right, dist);
          vec4 colorOut = mix(colors[i], colors[i + 1], localDist);
          return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));
        }
      }

      //final fallback
      return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));
    `;
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadialProgressEffect.js
var RadialProgressEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radialProgress");
  }
  static getEffectKey() {
    return `radialProgress`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      progress: props.progress ?? 0.5,
      offset: props.offset ?? 0,
      range: props.range ?? Math.PI * 2,
      rounded: props.rounded ?? false,
      radius: props.radius ?? 1,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(RadialProgressEffect, "z$__type__Props");
__publicField(RadialProgressEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  progress: {
    value: 0.5,
    method: "uniform1f",
    type: "float"
  },
  offset: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  range: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  rounded: {
    value: 0,
    method: "uniform1f",
    type: "float",
    validator: (value) => {
      return value ? 1 : 0;
    }
  },
  radius: {
    value: 1,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(RadialProgressEffect, "methods", {
  rotateUV: `
    vec2 function(vec2 uv, float d) {
      float s = sin(d);
      float c = cos(d);
      mat2 rotMatrix = mat2(c, -s, s, c);
      return uv * rotMatrix;
    }
    `,
  drawDot: `
    float function(vec2 uv, vec2 p, float r) {
      uv += p;
      float circle = length(uv) - r;
      return clamp(-circle, 0.0, 1.0);
    }
    `
});
__publicField(RadialProgressEffect, "onEffectMask", `
    float outerRadius = radius * u_dimensions.y * 0.5;

    float endAngle = range * progress - 0.0005;

    vec2 uv = v_nodeCoordinate.xy * u_dimensions.xy - u_dimensions * 0.5;

    uv = $rotateUV(uv, -(offset));
    float linewidth = width * u_pixelRatio;
    float circle = length(uv) - (outerRadius - linewidth) ;
    circle = abs(circle) - linewidth;
    circle = clamp(-circle, 0.0, 1.0);

    float angle = (atan(uv.x, -uv.y) / 3.14159265359 * 0.5);
    float p = endAngle / (PI * 2.);

    circle *= step(fract(angle), fract(p));

    circle = rounded < 1. ? circle : max(circle, $drawDot(uv, vec2(0, outerRadius - linewidth), linewidth));
    circle = rounded < 1. ? circle : max(circle, $drawDot($rotateUV(uv, -(endAngle)), vec2(0, outerRadius - linewidth), linewidth));

    return mix(shaderColor, maskColor, circle);
  `);
__publicField(RadialProgressEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/HolePunchEffect.js
var HolePunchEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "holePunch");
  }
  static getEffectKey() {
    return `holePunch`;
  }
  static resolveDefaults(props) {
    return {
      x: props.x || 0,
      y: props.y || 0,
      width: props.width || 50,
      height: props.height || 50,
      radius: props.radius ?? 0
    };
  }
};
__publicField(HolePunchEffect, "z$__type__Props");
__publicField(HolePunchEffect, "uniforms", {
  x: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  y: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  height: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  radius: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    updateOnBind: true,
    validator: validateArrayLength4,
    updateProgramValue: updateWebSafeRadius
  }
});
__publicField(HolePunchEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  boxDist: `
      float function(vec2 p, vec2 size, float radius) {
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }
    `
});
__publicField(HolePunchEffect, "onShaderMask", `
  vec2 halfDimensions = u_dimensions * 0.5;
  vec2 size = vec2(width, height) * 0.5;
  vec2 basePos = v_nodeCoordinate.xy * u_dimensions.xy - vec2(x, y);
  vec2 pos = basePos - size;
  float r = radius[0] * step(pos.x, 0.5) * step(pos.y, 0.5);
  r = r + radius[1] * step(0.5, pos.x) * step(pos.y, 0.5);
  r = r + radius[2] * step(0.5, pos.x) * step(0.5, pos.y);
  r = r + radius[3] * step(pos.x, 0.5) * step(0.5, pos.y);
  return $boxDist(pos, size, r);
  `);
__publicField(HolePunchEffect, "onEffectMask", `
  return mix(maskColor, vec4(0.0), $fillMask(shaderMask));
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/shaders/UnsupportedShader.js
var ROUNDED_RECTANGLE_SHADER_TYPE = "RoundedRectangle";
var UnsupportedShader = class extends CoreShader {
  constructor(shType) {
    super();
    __publicField(this, "shType");
    this.shType = shType;
  }
  bindRenderOp() {
  }
  bindProps() {
  }
  attach() {
  }
  detach() {
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/ShaderController.js
var ShaderController = class {
  constructor(type, shader, props, stage2) {
    __publicField(this, "type");
    __publicField(this, "shader");
    __publicField(this, "resolvedProps");
    __publicField(this, "props");
    this.type = type;
    this.shader = shader;
    this.resolvedProps = props;
    const keys = Object.keys(props);
    const l = keys.length;
    const definedProps = {};
    for (let i = 0; i < l; i++) {
      const name = keys[i];
      Object.defineProperty(definedProps, name, {
        get: () => {
          return this.resolvedProps[name];
        },
        set: (value) => {
          this.resolvedProps[name] = value;
          stage2.requestRender();
        }
      });
    }
    this.props = definedProps;
  }
  getResolvedProps() {
    return this.resolvedProps;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/DynamicShaderController.js
var DynamicShaderController = class {
  constructor(shader, props, shManager) {
    __publicField(this, "shader");
    __publicField(this, "resolvedProps");
    __publicField(this, "props");
    __publicField(this, "type");
    this.shader = shader;
    this.type = "DynamicShader";
    this.resolvedProps = props;
    const effectConstructors = shManager.getRegisteredEffects();
    const definedProps = {};
    const effects = props.effects;
    const effectsLength = effects.length;
    for (let i = 0; i < effectsLength; i++) {
      const { name: effectName, props: effectProps, type: effectType } = effects[i];
      if (effectName === void 0) {
        continue;
      }
      const definedEffectProps = {};
      const propEntries = Object.keys(effectProps);
      const propEntriesLength = propEntries.length;
      for (let j = 0; j < propEntriesLength; j++) {
        const propName = propEntries[j];
        Object.defineProperty(definedEffectProps, propName, {
          get: () => {
            return this.resolvedProps.effects[i].props[propName].value;
          },
          set: (value) => {
            var _a2, _b;
            const target = this.resolvedProps.effects[i].props[propName];
            target.value = value;
            if (target.hasValidator) {
              value = target.validatedValue = (_a2 = effectConstructors[effectType].uniforms[propName]) == null ? void 0 : _a2.validator(value, effectProps);
            }
            if (target.hasProgramValueUpdater) {
              (_b = effectConstructors[effectType].uniforms[propName]) == null ? void 0 : _b.updateProgramValue(target);
            } else {
              target.programValue = value;
            }
            shManager.renderer.stage.requestRender();
          }
        });
      }
      Object.defineProperty(definedProps, effectName, {
        get: () => {
          return definedEffectProps;
        }
      });
    }
    this.props = definedProps;
  }
  getResolvedProps() {
    return this.resolvedProps;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreShaderManager.js
var CoreShaderManager = class {
  constructor() {
    __publicField(this, "shCache", /* @__PURE__ */ new Map());
    __publicField(this, "shConstructors", {});
    __publicField(this, "attachedShader", null);
    __publicField(this, "effectConstructors", {});
    __publicField(this, "renderer");
    this.registerShaderType("DefaultShader", DefaultShader);
    this.registerShaderType("DefaultShaderBatched", DefaultShaderBatched);
    this.registerShaderType("RoundedRectangle", RoundedRectangle);
    this.registerShaderType("DynamicShader", DynamicShader);
    this.registerShaderType("SdfShader", SdfShader);
    this.registerEffectType("border", BorderEffect);
    this.registerEffectType("borderBottom", BorderBottomEffect);
    this.registerEffectType("borderLeft", BorderLeftEffect);
    this.registerEffectType("borderRight", BorderRightEffect);
    this.registerEffectType("borderTop", BorderTopEffect);
    this.registerEffectType("fadeOut", FadeOutEffect);
    this.registerEffectType("linearGradient", LinearGradientEffect);
    this.registerEffectType("radialGradient", RadialGradientEffect);
    this.registerEffectType("grayscale", GrayscaleEffect);
    this.registerEffectType("glitch", GlitchEffect);
    this.registerEffectType("radius", RadiusEffect);
    this.registerEffectType("radialProgress", RadialProgressEffect);
    this.registerEffectType("holePunch", HolePunchEffect);
  }
  registerShaderType(shType, shClass) {
    this.shConstructors[shType] = shClass;
  }
  registerEffectType(effectType, effectClass) {
    this.effectConstructors[effectType] = effectClass;
  }
  getRegisteredEffects() {
    return this.effectConstructors;
  }
  getRegisteredShaders() {
    return this.shConstructors;
  }
  /**
   * Loads a shader (if not already loaded) and returns a controller for it.
   *
   * @param shType
   * @param props
   * @returns
   */
  loadShader(shType, props) {
    if (!this.renderer) {
      throw new Error(`Renderer is not been defined`);
    }
    const ShaderClass = this.shConstructors[shType];
    if (!ShaderClass) {
      throw new Error(`Shader type "${shType}" is not registered`);
    }
    if (this.renderer.mode === "canvas" && ShaderClass.prototype instanceof WebGlCoreShader) {
      return this._createShaderCtr(shType, new UnsupportedShader(shType), props);
    }
    if (shType === "DynamicShader") {
      return this.loadDynamicShader(props);
    }
    const resolvedProps = ShaderClass.resolveDefaults(props);
    const cacheKey = ShaderClass.makeCacheKey(resolvedProps) || ShaderClass.name;
    if (cacheKey && this.shCache.has(cacheKey)) {
      return this._createShaderCtr(shType, this.shCache.get(cacheKey), resolvedProps);
    }
    const shader = new ShaderClass(this.renderer, props);
    if (cacheKey) {
      this.shCache.set(cacheKey, shader);
    }
    return this._createShaderCtr(shType, shader, resolvedProps);
  }
  loadDynamicShader(props) {
    if (!this.renderer) {
      throw new Error(`Renderer is not been defined`);
    }
    const resolvedProps = DynamicShader.resolveDefaults(props, this.effectConstructors);
    const cacheKey = DynamicShader.makeCacheKey(resolvedProps, this.effectConstructors);
    if (cacheKey && this.shCache.has(cacheKey)) {
      return this._createDynShaderCtr(this.shCache.get(cacheKey), resolvedProps);
    }
    const shader = new DynamicShader(this.renderer, props, this.effectConstructors);
    if (cacheKey) {
      this.shCache.set(cacheKey, shader);
    }
    return this._createDynShaderCtr(shader, resolvedProps);
  }
  _createShaderCtr(type, shader, props) {
    return new ShaderController(type, shader, props, this.renderer.stage);
  }
  _createDynShaderCtr(shader, props) {
    shader.bindUniformMethods(props);
    return new DynamicShaderController(shader, props, this);
  }
  useShader(shader) {
    if (this.attachedShader === shader) {
      return;
    }
    if (this.attachedShader) {
      this.attachedShader.detach();
    }
    shader.attach();
    this.attachedShader = shader;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/TextRenderer.js
var trPropSetterDefaults = {
  x: (state2, value) => {
    state2.props.x = value;
  },
  y: (state2, value) => {
    state2.props.y = value;
  },
  width: (state2, value) => {
    state2.props.width = value;
  },
  height: (state2, value) => {
    state2.props.height = value;
  },
  color: (state2, value) => {
    state2.props.color = value;
  },
  zIndex: (state2, value) => {
    state2.props.zIndex = value;
  },
  fontFamily: (state2, value) => {
    state2.props.fontFamily = value;
  },
  fontWeight: (state2, value) => {
    state2.props.fontWeight = value;
  },
  fontStyle: (state2, value) => {
    state2.props.fontStyle = value;
  },
  fontStretch: (state2, value) => {
    state2.props.fontStretch = value;
  },
  fontSize: (state2, value) => {
    state2.props.fontSize = value;
  },
  text: (state2, value) => {
    state2.props.text = value;
  },
  textAlign: (state2, value) => {
    state2.props.textAlign = value;
  },
  contain: (state2, value) => {
    state2.props.contain = value;
  },
  offsetY: (state2, value) => {
    state2.props.offsetY = value;
  },
  scrollable: (state2, value) => {
    state2.props.scrollable = value;
  },
  scrollY: (state2, value) => {
    state2.props.scrollY = value;
  },
  letterSpacing: (state2, value) => {
    state2.props.letterSpacing = value;
  },
  lineHeight: (state2, value) => {
    state2.props.lineHeight = value;
  },
  maxLines: (state2, value) => {
    state2.props.maxLines = value;
  },
  textBaseline: (state2, value) => {
    state2.props.textBaseline = value;
  },
  verticalAlign: (state2, value) => {
    state2.props.verticalAlign = value;
  },
  overflowSuffix: (state2, value) => {
    state2.props.overflowSuffix = value;
  },
  debug: (state2, value) => {
    state2.props.debug = value;
  }
};
var TextRenderer = class {
  constructor(stage2) {
    __publicField(this, "stage");
    __publicField(this, "set");
    this.stage = stage2;
    const propSetters = {
      ...trPropSetterDefaults,
      ...this.getPropertySetters()
    };
    const propSet = {};
    Object.keys(propSetters).forEach((key) => {
      Object.defineProperty(propSet, key, {
        value: (state2, value) => {
          if (state2.props[key] !== value) {
            propSetters[key](state2, value);
            this.stage.requestRender();
          }
        },
        writable: false,
        // Prevents property from being changed
        configurable: false
        // Prevents property from being deleted
      });
    });
    this.set = propSet;
  }
  setStatus(state2, status, error) {
    if (state2.status === status) {
      return;
    }
    state2.status = status;
    state2.emitter.emit(status, error);
  }
  /**
   * Allows the CoreTextNode to communicate changes to the isRenderable state of
   * the itself.
   *
   * @param state
   * @param renderable
   */
  setIsRenderable(state2, renderable) {
    state2.isRenderable = renderable;
  }
  /**
   * Destroy/Clean up the state object
   *
   * @remarks
   * Opposite of createState(). Frees any event listeners / resources held by
   * the state that may not reliably get garbage collected.
   *
   * @param state
   */
  destroyState(state2) {
    this.setStatus(state2, "destroyed");
    state2.emitter.removeAllListeners();
  }
  /**
   * Schedule a state update via queueMicrotask
   *
   * @remarks
   * This method is used to schedule a state update via queueMicrotask. This
   * method should be called whenever a state update is needed, and it will
   * ensure that the state is only updated once per microtask.
   * @param state
   * @returns
   */
  scheduleUpdateState(state2) {
    if (state2.updateScheduled) {
      return;
    }
    state2.updateScheduled = true;
    queueMicrotask(() => {
      if (state2.status === "destroyed") {
        return;
      }
      state2.updateScheduled = false;
      this.updateState(state2);
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/ContextSpy.js
var ContextSpy = class {
  constructor() {
    __publicField(this, "data", {});
  }
  reset() {
    this.data = {};
  }
  increment(name) {
    if (!this.data[name]) {
      this.data[name] = 0;
    }
    this.data[name]++;
  }
  getData() {
    return { ...this.data };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/TextureMemoryManager.js
var TextureMemoryManager = class {
  constructor(stage2, settings2) {
    __publicField(this, "stage");
    __publicField(this, "memUsed", 0);
    __publicField(this, "loadedTextures", []);
    __publicField(this, "criticalThreshold");
    __publicField(this, "targetThreshold");
    __publicField(this, "cleanupInterval");
    __publicField(this, "debugLogging");
    __publicField(this, "lastCleanupTime", 0);
    __publicField(this, "baselineMemoryAllocation");
    __publicField(this, "hasWarnedAboveCritical", false);
    __publicField(this, "criticalCleanupRequested", false);
    __publicField(this, "doNotExceedCriticalThreshold");
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to determine when to perform Idle Texture Cleanups.
     *
     * Set by stage via `updateFrameTime` method.
     */
    __publicField(this, "frameTime", 0);
    this.stage = stage2;
    const { criticalThreshold, doNotExceedCriticalThreshold } = settings2;
    this.doNotExceedCriticalThreshold = doNotExceedCriticalThreshold || false;
    this.criticalThreshold = Math.round(criticalThreshold);
    const targetFraction = Math.max(0, Math.min(1, settings2.targetThresholdLevel));
    this.cleanupInterval = settings2.cleanupInterval;
    this.debugLogging = settings2.debugLogging;
    this.baselineMemoryAllocation = Math.round(settings2.baselineMemoryAllocation);
    this.targetThreshold = Math.max(Math.round(criticalThreshold * targetFraction), this.baselineMemoryAllocation);
    this.memUsed = Math.round(settings2.baselineMemoryAllocation);
    if (settings2.debugLogging) {
      let lastMemUse = 0;
      setInterval(() => {
        if (lastMemUse !== this.memUsed) {
          lastMemUse = this.memUsed;
          console.log(`[TextureMemoryManager] Memory used: ${bytesToMb(this.memUsed)} mb / ${bytesToMb(this.criticalThreshold)} mb (${(this.memUsed / this.criticalThreshold * 100).toFixed(1)}%)`);
        }
      }, 1e3);
    }
    if (criticalThreshold === 0) {
      this.setTextureMemUse = () => {
      };
    }
  }
  /**
   * Set the memory usage of a texture
   *
   * @param texture - The texture to set memory usage for
   * @param byteSize - The size of the texture in bytes
   */
  setTextureMemUse(texture, byteSize) {
    this.memUsed -= texture.memUsed;
    if (byteSize === 0) {
      const index = this.loadedTextures.indexOf(texture);
      if (index !== -1) {
        this.loadedTextures[index] = null;
      }
      texture.memUsed = 0;
      return;
    } else {
      texture.memUsed = byteSize;
      this.memUsed += byteSize;
      if (this.loadedTextures.indexOf(texture) === -1) {
        const emptyIndex = this.loadedTextures.indexOf(null);
        if (emptyIndex !== -1) {
          this.loadedTextures[emptyIndex] = texture;
        } else {
          this.loadedTextures.push(texture);
        }
      }
    }
    if (this.memUsed > this.criticalThreshold) {
      this.criticalCleanupRequested = true;
    }
  }
  checkCleanup() {
    return this.criticalCleanupRequested || this.memUsed > this.targetThreshold && this.frameTime - this.lastCleanupTime >= this.cleanupInterval;
  }
  checkCriticalCleanup() {
    return this.memUsed > this.criticalThreshold;
  }
  /**
   * Destroy a texture and null out its array position
   *
   * @param texture - The texture to destroy
   */
  destroyTexture(texture) {
    if (this.debugLogging === true) {
      console.log(`[TextureMemoryManager] Destroying texture. State: ${texture.state}`);
    }
    const index = this.loadedTextures.indexOf(texture);
    if (index !== -1) {
      this.loadedTextures[index] = null;
    }
    const txManager = this.stage.txManager;
    txManager.removeTextureFromCache(texture);
    texture.destroy();
    this.memUsed -= texture.memUsed;
    texture.memUsed = 0;
  }
  cleanup() {
    const critical = this.criticalCleanupRequested;
    this.lastCleanupTime = this.frameTime;
    if (critical === true) {
      this.stage.queueFrameEvent("criticalCleanup", {
        memUsed: this.memUsed,
        criticalThreshold: this.criticalThreshold
      });
    }
    if (this.debugLogging === true) {
      console.log(`[TextureMemoryManager] Cleaning up textures. Critical: ${critical}.`);
    }
    const memTarget = critical ? this.criticalThreshold : this.targetThreshold;
    let currentMemUsed = this.memUsed;
    for (let i = 0; i < this.loadedTextures.length; i++) {
      if (currentMemUsed < memTarget) {
        break;
      }
      const texture = this.loadedTextures[i];
      if (!texture)
        continue;
      const isCleanableType = texture.type === TextureType.image || texture.type === TextureType.noise || texture.type === TextureType.renderToTexture;
      if (isCleanableType && texture.canBeCleanedUp() === true) {
        const textureMemory = texture.memUsed;
        this.destroyTexture(texture);
        currentMemUsed -= textureMemory;
      }
    }
    if (this.memUsed >= this.criticalThreshold) {
      this.stage.queueFrameEvent("criticalCleanupFailed", {
        memUsed: this.memUsed,
        criticalThreshold: this.criticalThreshold
      });
      if (!this.hasWarnedAboveCritical && (this.debugLogging === true || isProductionEnvironment === false)) {
        console.warn(`[TextureMemoryManager] Memory usage above critical threshold after cleanup: ${this.memUsed}`);
        this.hasWarnedAboveCritical = true;
      }
    } else {
      this.criticalCleanupRequested = false;
      this.hasWarnedAboveCritical = false;
    }
  }
  /**
   * Get the current texture memory usage information
   *
   * @remarks
   * This method is for debugging purposes and returns information about the
   * current memory usage of the textures in the Renderer.
   */
  getMemoryInfo() {
    let renderableTexturesLoaded = 0;
    let renderableMemUsed = this.baselineMemoryAllocation;
    for (const texture of this.loadedTextures) {
      if (texture && texture.renderable) {
        renderableTexturesLoaded += 1;
        renderableMemUsed += texture.memUsed;
      }
    }
    const actualLoadedTextures = this.loadedTextures.filter((t) => t !== null).length;
    return {
      criticalThreshold: this.criticalThreshold,
      targetThreshold: this.targetThreshold,
      renderableMemUsed,
      memUsed: this.memUsed,
      renderableTexturesLoaded,
      loadedTextures: actualLoadedTextures,
      baselineMemoryAllocation: this.baselineMemoryAllocation
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreContextTexture.js
var CoreContextTexture = class {
  constructor(memManager, textureSource) {
    __publicField(this, "textureSource");
    __publicField(this, "memManager");
    __publicField(this, "state", "freed");
    this.memManager = memManager;
    this.textureSource = textureSource;
  }
  setTextureMemUse(byteSize) {
    this.memManager.setTextureMemUse(this.textureSource, byteSize);
  }
  get renderable() {
    return this.textureSource.renderable;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreRenderer.js
var CoreRenderer = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "mode");
    __publicField(this, "stage");
    //// Core Managers
    __publicField(this, "txManager");
    __publicField(this, "txMemManager");
    __publicField(this, "shManager");
    __publicField(this, "rttNodes", []);
    this.options = options;
    this.stage = options.stage;
    this.txManager = options.txManager;
    this.txMemManager = options.txMemManager;
    this.shManager = options.shManager;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreTextNode.js
var CoreTextNode = class extends CoreNode {
  constructor(stage2, props, textRenderer) {
    super(stage2, props);
    __publicField(this, "textRenderer");
    __publicField(this, "trState");
    __publicField(this, "_textRendererOverride", null);
    __publicField(this, "onTextLoaded", () => {
      const { contain } = this;
      const setWidth = this.trState.props.width;
      const setHeight = this.trState.props.height;
      const calcWidth = this.trState.textW || 0;
      const calcHeight2 = this.trState.textH || 0;
      if (contain === "both") {
        this.props.width = setWidth;
        this.props.height = setHeight;
      } else if (contain === "width") {
        this.props.width = setWidth;
        this.props.height = calcHeight2;
      } else if (contain === "none") {
        this.props.width = calcWidth;
        this.props.height = calcHeight2;
      }
      this.updateLocalTransform();
      this.stage.requestRender();
      this.emit("loaded", {
        type: "text",
        dimensions: {
          width: this.trState.textW || 0,
          height: this.trState.textH || 0
        }
      });
    });
    __publicField(this, "onTextFailed", (target, error) => {
      this.emit("failed", {
        type: "text",
        error
      });
    });
    this._textRendererOverride = props.textRendererOverride;
    this.textRenderer = textRenderer;
    const textRendererState = this.createState({
      x: 0,
      y: 0,
      width: props.width,
      height: props.height,
      textAlign: props.textAlign,
      color: props.color,
      zIndex: props.zIndex,
      contain: props.contain,
      scrollable: props.scrollable,
      scrollY: props.scrollY,
      offsetY: props.offsetY,
      letterSpacing: props.letterSpacing,
      debug: props.debug,
      fontFamily: props.fontFamily,
      fontSize: props.fontSize,
      fontStretch: props.fontStretch,
      fontStyle: props.fontStyle,
      fontWeight: props.fontWeight,
      text: props.text,
      lineHeight: props.lineHeight,
      maxLines: props.maxLines,
      textBaseline: props.textBaseline,
      verticalAlign: props.verticalAlign,
      overflowSuffix: props.overflowSuffix
    });
    this.trState = textRendererState;
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    this.props.width = value;
    this.textRenderer.set.width(this.trState, value);
    if (this.contain === "none") {
      this.setUpdateType(UpdateType.Local);
    }
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    this.props.height = value;
    this.textRenderer.set.height(this.trState, value);
    if (this.contain !== "both") {
      this.setUpdateType(UpdateType.Local);
    }
  }
  get color() {
    return this.trState.props.color;
  }
  set color(value) {
    this.textRenderer.set.color(this.trState, value);
  }
  get text() {
    return this.trState.props.text;
  }
  set text(value) {
    this.textRenderer.set.text(this.trState, value);
  }
  get textRendererOverride() {
    return this._textRendererOverride;
  }
  set textRendererOverride(value) {
    this._textRendererOverride = value;
    this.textRenderer.destroyState(this.trState);
    const textRenderer = this.stage.resolveTextRenderer(this.trState.props, this._textRendererOverride);
    if (!textRenderer) {
      console.warn("Text Renderer not found for font", this.trState.props.fontFamily);
      return;
    }
    this.textRenderer = textRenderer;
    this.trState = this.createState(this.trState.props);
  }
  get fontSize() {
    return this.trState.props.fontSize;
  }
  set fontSize(value) {
    this.textRenderer.set.fontSize(this.trState, value);
  }
  get fontFamily() {
    return this.trState.props.fontFamily;
  }
  set fontFamily(value) {
    this.textRenderer.set.fontFamily(this.trState, value);
  }
  get fontStretch() {
    return this.trState.props.fontStretch;
  }
  set fontStretch(value) {
    this.textRenderer.set.fontStretch(this.trState, value);
  }
  get fontStyle() {
    return this.trState.props.fontStyle;
  }
  set fontStyle(value) {
    this.textRenderer.set.fontStyle(this.trState, value);
  }
  get fontWeight() {
    return this.trState.props.fontWeight;
  }
  set fontWeight(value) {
    this.textRenderer.set.fontWeight(this.trState, value);
  }
  get textAlign() {
    return this.trState.props.textAlign;
  }
  set textAlign(value) {
    this.textRenderer.set.textAlign(this.trState, value);
  }
  get contain() {
    return this.trState.props.contain;
  }
  set contain(value) {
    this.textRenderer.set.contain(this.trState, value);
  }
  get scrollable() {
    return this.trState.props.scrollable;
  }
  set scrollable(value) {
    this.textRenderer.set.scrollable(this.trState, value);
  }
  get scrollY() {
    return this.trState.props.scrollY;
  }
  set scrollY(value) {
    this.textRenderer.set.scrollY(this.trState, value);
  }
  get offsetY() {
    return this.trState.props.offsetY;
  }
  set offsetY(value) {
    this.textRenderer.set.offsetY(this.trState, value);
  }
  get letterSpacing() {
    return this.trState.props.letterSpacing;
  }
  set letterSpacing(value) {
    this.textRenderer.set.letterSpacing(this.trState, value);
  }
  get lineHeight() {
    return this.trState.props.lineHeight;
  }
  set lineHeight(value) {
    this.textRenderer.set.lineHeight(this.trState, value);
  }
  get maxLines() {
    return this.trState.props.maxLines;
  }
  set maxLines(value) {
    this.textRenderer.set.maxLines(this.trState, value);
  }
  get textBaseline() {
    return this.trState.props.textBaseline;
  }
  set textBaseline(value) {
    this.textRenderer.set.textBaseline(this.trState, value);
  }
  get verticalAlign() {
    return this.trState.props.verticalAlign;
  }
  set verticalAlign(value) {
    this.textRenderer.set.verticalAlign(this.trState, value);
  }
  get overflowSuffix() {
    return this.trState.props.overflowSuffix;
  }
  set overflowSuffix(value) {
    this.textRenderer.set.overflowSuffix(this.trState, value);
  }
  get debug() {
    return this.trState.props.debug;
  }
  set debug(value) {
    this.textRenderer.set.debug(this.trState, value);
  }
  update(delta, parentClippingRect) {
    super.update(delta, parentClippingRect);
    assertTruthy(this.globalTransform);
    this.textRenderer.set.x(this.trState, this.globalTransform.tx);
    this.textRenderer.set.y(this.trState, this.globalTransform.ty);
  }
  checkBasicRenderability() {
    if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
      return false;
    }
    if (this.trState && this.trState.props.text !== "") {
      return true;
    }
    return false;
  }
  setRenderable(isRenderable) {
    super.setRenderable(isRenderable);
    this.textRenderer.setIsRenderable(this.trState, isRenderable);
  }
  renderQuads(renderer3) {
    var _a2;
    assertTruthy(this.globalTransform);
    if (!this.textRenderer.renderQuads) {
      super.renderQuads(renderer3);
      return;
    }
    if (this.parentHasRenderTexture) {
      if (!renderer3.renderToTextureActive) {
        return;
      }
      if (this.parentRenderTexture !== renderer3.activeRttNode) {
        return;
      }
    }
    if (this.parentHasRenderTexture && ((_a2 = this.props.parent) == null ? void 0 : _a2.rtt)) {
      this.globalTransform = Matrix3d.identity();
      if (this.localTransform) {
        this.globalTransform.multiply(this.localTransform);
      }
    }
    assertTruthy(this.globalTransform);
    this.textRenderer.renderQuads(this.trState, this.globalTransform, this.clippingRect, this.worldAlpha, this.parentHasRenderTexture, this.framebufferDimensions);
  }
  /**
   * Destroy the node and cleanup all resources
   */
  destroy() {
    super.destroy();
    this.textRenderer.destroyState(this.trState);
  }
  /**
   * Resolve a text renderer and a new state based on the current text renderer props provided
   * @param props
   * @returns
   */
  createState(props) {
    const textRendererState = this.textRenderer.createState(props, this);
    textRendererState.emitter.on("loaded", this.onTextLoaded);
    textRendererState.emitter.on("failed", this.onTextFailed);
    this.textRenderer.scheduleUpdateState(textRendererState);
    return textRendererState;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/utils.js
function santizeCustomDataMap(d) {
  const validTypes = {
    boolean: true,
    string: true,
    number: true,
    undefined: true
  };
  const keys = Object.keys(d);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!key) {
      continue;
    }
    const value = d[key];
    const valueType = typeof value;
    if (valueType === "string" && value.length > 2048) {
      console.warn(`Custom Data value for ${key} is too long, it will be truncated to 2048 characters`);
      d[key] = value.substring(0, 2048);
    }
    if (!validTypes[valueType]) {
      console.warn(`Custom Data value for ${key} is not a boolean, string, or number, it will be ignored`);
      delete d[key];
    }
  }
  return d;
}

// node_modules/@lightningjs/renderer/dist/src/core/Stage.js
var bufferMemory = 2e6;
var autoStart = true;
var Stage = class {
  /**
   * Stage constructor
   */
  constructor(options) {
    __publicField(this, "options");
    /// Module Instances
    __publicField(this, "animationManager");
    __publicField(this, "txManager");
    __publicField(this, "txMemManager");
    __publicField(this, "fontManager");
    __publicField(this, "textRenderers");
    __publicField(this, "shManager");
    __publicField(this, "renderer");
    __publicField(this, "root");
    __publicField(this, "interactiveNodes", /* @__PURE__ */ new Set());
    __publicField(this, "boundsMargin");
    __publicField(this, "defShaderCtr");
    __publicField(this, "strictBound");
    __publicField(this, "preloadBound");
    __publicField(this, "strictBounds");
    __publicField(this, "defaultTexture", null);
    /**
     * Target frame time in milliseconds (calculated from targetFPS)
     *
     * @remarks
     * This is pre-calculated to avoid recalculating on every frame.
     * - 0 means no throttling (use display refresh rate)
     * - >0 means throttle to this frame time (1000 / targetFPS)
     */
    __publicField(this, "targetFrameTime", 0);
    /**
     * Renderer Event Bus for the Stage to emit events onto
     *
     * @remarks
     * In reality this is just the RendererMain instance, which is an EventEmitter.
     * this allows us to directly emit events from the Stage to RendererMain
     * without having to set up forwarding handlers.
     */
    __publicField(this, "eventBus");
    /// State
    __publicField(this, "deltaTime", 0);
    __publicField(this, "lastFrameTime", 0);
    __publicField(this, "currentFrameTime", 0);
    __publicField(this, "fpsNumFrames", 0);
    __publicField(this, "fpsElapsedTime", 0);
    __publicField(this, "numQuadsRendered", 0);
    __publicField(this, "renderRequested", false);
    __publicField(this, "frameEventQueue", []);
    __publicField(this, "fontResolveMap", {});
    /// Debug data
    __publicField(this, "contextSpy", null);
    this.options = options;
    const { canvas, clearColor, appWidth, appHeight, boundsMargin, enableContextSpy, forceWebGL2, numImageWorkers, textureMemory, renderEngine: renderEngine2, fontEngines, createImageBitmapSupport, maxRetryCount } = options;
    this.eventBus = options.eventBus;
    this.targetFrameTime = options.targetFPS > 0 ? 1e3 / options.targetFPS : 0;
    this.txManager = new CoreTextureManager(this, {
      numImageWorkers,
      createImageBitmapSupport,
      maxRetryCount
    });
    this.txManager.on("initialized", () => {
      this.requestRender();
    });
    this.txMemManager = new TextureMemoryManager(this, textureMemory);
    this.shManager = new CoreShaderManager();
    this.animationManager = new AnimationManager();
    this.contextSpy = enableContextSpy ? new ContextSpy() : null;
    this.strictBounds = options.strictBounds;
    let bm = [0, 0, 0, 0];
    if (boundsMargin) {
      bm = Array.isArray(boundsMargin) ? boundsMargin : [boundsMargin, boundsMargin, boundsMargin, boundsMargin];
    }
    this.boundsMargin = bm;
    this.strictBound = createBound(0, 0, appWidth, appHeight);
    this.preloadBound = createPreloadBounds(this.strictBound, bm);
    const rendererOptions = {
      stage: this,
      canvas,
      pixelRatio: options.devicePhysicalPixelRatio * options.deviceLogicalPixelRatio,
      clearColor: clearColor ?? 4278190080,
      bufferMemory,
      txManager: this.txManager,
      txMemManager: this.txMemManager,
      shManager: this.shManager,
      contextSpy: this.contextSpy,
      forceWebGL2
    };
    this.renderer = new renderEngine2(rendererOptions);
    const renderMode = this.renderer.mode || "webgl";
    this.createDefaultTexture();
    this.defShaderCtr = this.renderer.getDefShaderCtr();
    setPremultiplyMode(renderMode);
    this.txManager.renderer = this.renderer;
    this.textRenderers = {};
    fontEngines.forEach((fontEngineConstructor) => {
      const fontEngineInstance = new fontEngineConstructor(this);
      const className = fontEngineInstance.type;
      if (className === "sdf" && renderMode === "canvas") {
        console.warn("SdfTextRenderer is not compatible with Canvas renderer. Skipping...");
        return;
      }
      if (fontEngineInstance instanceof TextRenderer) {
        if (className === "canvas") {
          this.textRenderers["canvas"] = fontEngineInstance;
        } else if (className === "sdf") {
          this.textRenderers["sdf"] = fontEngineInstance;
        }
      }
    });
    if (Object.keys(this.textRenderers).length === 0) {
      console.warn("No text renderers available. Your text will not render.");
    }
    this.fontManager = new TrFontManager(this.textRenderers);
    const rootNode = new CoreNode(this, {
      x: 0,
      y: 0,
      width: appWidth,
      height: appHeight,
      alpha: 1,
      autosize: false,
      boundsMargin: null,
      clipping: false,
      color: 0,
      colorTop: 0,
      colorBottom: 0,
      colorLeft: 0,
      colorRight: 0,
      colorTl: 0,
      colorTr: 0,
      colorBl: 0,
      colorBr: 0,
      zIndex: 0,
      zIndexLocked: 0,
      scaleX: 1,
      scaleY: 1,
      mountX: 0,
      mountY: 0,
      mount: 0,
      pivot: 0.5,
      pivotX: 0.5,
      pivotY: 0.5,
      rotation: 0,
      parent: null,
      texture: null,
      textureOptions: {},
      shader: this.defShaderCtr,
      rtt: false,
      src: null,
      scale: 1,
      preventCleanup: false,
      strictBounds: this.strictBounds
    });
    this.root = rootNode;
    if (autoStart) {
      startLoop(this);
    }
  }
  setClearColor(color) {
    this.renderer.updateClearColor(color);
    this.renderRequested = true;
  }
  /**
   * Update the target frame time based on the current targetFPS setting
   *
   * @remarks
   * This should be called whenever the targetFPS option is changed
   * to ensure targetFrameTime stays in sync.
   * targetFPS of 0 means no throttling (targetFrameTime = 0)
   * targetFPS > 0 means throttle to 1000/targetFPS milliseconds
   */
  updateTargetFrameTime() {
    this.targetFrameTime = this.options.targetFPS > 0 ? 1e3 / this.options.targetFPS : 0;
  }
  updateFrameTime() {
    const newFrameTime = getTimeStamp();
    this.lastFrameTime = this.currentFrameTime;
    this.currentFrameTime = newFrameTime;
    this.deltaTime = !this.lastFrameTime ? 100 / 6 : newFrameTime - this.lastFrameTime;
    this.txManager.frameTime = newFrameTime;
    this.txMemManager.frameTime = newFrameTime;
    this.eventBus.emit("frameTick", {
      time: this.currentFrameTime,
      delta: this.deltaTime
    });
  }
  /**
   * Create default PixelTexture
   */
  createDefaultTexture() {
    this.defaultTexture = this.txManager.createTexture("ColorTexture", {
      color: 4294967295
    });
    assertTruthy(this.defaultTexture instanceof ColorTexture);
    this.txManager.loadTexture(this.defaultTexture, true);
    this.defaultTexture.setRenderableOwner("stage", true);
    this.defaultTexture.once("loaded", () => {
      this.requestRender();
    });
  }
  /**
   * Update animations
   */
  updateAnimations() {
    const { animationManager } = this;
    if (!this.root) {
      return;
    }
    animationManager.update(this.deltaTime);
  }
  /**
   * Check if the scene has updates
   */
  hasSceneUpdates() {
    return !!this.root.updateType || this.renderRequested || this.txManager.hasUpdates();
  }
  /**
   * Start a new frame draw
   */
  drawFrame() {
    const { renderer: renderer3, renderRequested } = this;
    assertTruthy(renderer3);
    if (this.root.updateType !== 0) {
      this.root.update(this.deltaTime, this.root.clippingRect);
    }
    this.txManager.processSome(this.options.textureProcessingTimeLimit).catch((err) => {
      console.error("Error processing textures:", err);
    });
    renderer3.reset();
    if (renderer3.rttNodes.length > 0) {
      renderer3.renderRTTNodes();
    }
    this.addQuads(this.root);
    renderer3 == null ? void 0 : renderer3.render();
    this.calculateFps();
    this.calculateQuads();
    if (renderRequested) {
      this.renderRequested = false;
    }
    if (this.txMemManager.criticalCleanupRequested === true) {
      this.txMemManager.cleanup();
    }
  }
  /**
   * Queue an event to be emitted after the current/next frame is rendered
   *
   * @remarks
   * When we are operating in the context of the render loop, we may want to
   * emit events that are related to the current frame. However, we generally do
   * NOT want to emit events directly in the middle of the render loop, since
   * this could enable event handlers to modify the scene graph and cause
   * unexpected behavior. Instead, we queue up events to be emitted and then
   * flush the queue after the frame has been rendered.
   *
   * @param name
   * @param data
   */
  queueFrameEvent(name, data) {
    this.frameEventQueue.push([name, data]);
  }
  /**
   * Emit all queued frame events
   *
   * @remarks
   * This method should be called after the frame has been rendered to emit
   * all events that were queued during the frame.
   *
   * See {@link queueFrameEvent} for more information.
   */
  flushFrameEvents() {
    for (const [name, data] of this.frameEventQueue) {
      this.eventBus.emit(name, data);
    }
    this.frameEventQueue = [];
  }
  calculateFps() {
    var _a2, _b;
    const { fpsUpdateInterval } = this.options;
    if (fpsUpdateInterval) {
      this.fpsNumFrames++;
      this.fpsElapsedTime += this.deltaTime;
      if (this.fpsElapsedTime >= fpsUpdateInterval) {
        const fps = Math.round(this.fpsNumFrames * 1e3 / this.fpsElapsedTime);
        this.fpsNumFrames = 0;
        this.fpsElapsedTime = 0;
        this.queueFrameEvent("fpsUpdate", {
          fps,
          contextSpyData: ((_a2 = this.contextSpy) == null ? void 0 : _a2.getData()) ?? null
        });
        (_b = this.contextSpy) == null ? void 0 : _b.reset();
      }
    }
  }
  calculateQuads() {
    const quads = this.renderer.getQuadCount();
    if (quads && quads !== this.numQuadsRendered) {
      this.numQuadsRendered = quads;
      this.queueFrameEvent("quadsUpdate", {
        quads
      });
    }
  }
  addQuads(node) {
    assertTruthy(this.renderer);
    if (node.isRenderable === true) {
      node.renderQuads(this.renderer);
    }
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (child === void 0) {
        continue;
      }
      if (child.worldAlpha === 0 || child.strictBounds === true && child.renderState === CoreNodeRenderState.OutOfBounds) {
        continue;
      }
      this.addQuads(child);
    }
  }
  /**
   * Request a render pass without forcing an update
   */
  requestRender() {
    this.renderRequested = true;
  }
  /**
   * Find all nodes at a given point
   * @param data
   */
  findNodesAtPoint(data) {
    const x = data.x / this.options.deviceLogicalPixelRatio;
    const y = data.y / this.options.deviceLogicalPixelRatio;
    const nodes = [];
    for (const node of this.interactiveNodes) {
      if (node.isRenderable === false) {
        continue;
      }
      if (pointInBound(x, y, node.renderBound) === true) {
        nodes.push(node);
      }
    }
    return nodes;
  }
  /**
   * Find the top node at a given point
   * @param data
   * @returns
   */
  getNodeFromPosition(data) {
    const nodes = this.findNodesAtPoint(data);
    if (nodes.length === 0) {
      return null;
    }
    let topNode = nodes[nodes.length - 1];
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].zIndex > topNode.zIndex) {
        topNode = nodes[i];
      }
    }
    return topNode || null;
  }
  /**
   * Given a font name, and possible renderer override, return the best compatible text renderer.
   *
   * @remarks
   * Will try to return a canvas renderer if no other suitable renderer can be resolved.
   *
   * @param fontFamily
   * @param textRendererOverride
   * @returns
   */
  resolveTextRenderer(trProps, textRendererOverride = null) {
    const fontCacheString = `${trProps.fontFamily}${trProps.fontStyle}${trProps.fontWeight}${trProps.fontStretch}${textRendererOverride ? textRendererOverride : ""}`;
    if (this.fontResolveMap[fontCacheString] !== void 0) {
      return this.fontResolveMap[fontCacheString];
    }
    let rendererId = textRendererOverride;
    let overrideFallback = false;
    if (rendererId) {
      const possibleRenderer = this.textRenderers[rendererId];
      if (!possibleRenderer) {
        console.warn(`Text renderer override '${rendererId}' not found.`);
        rendererId = null;
        overrideFallback = true;
      } else if (!possibleRenderer.canRenderFont(trProps)) {
        console.warn(`Cannot use override text renderer '${rendererId}' for font`, trProps);
        rendererId = null;
        overrideFallback = true;
      }
    }
    if (!rendererId) {
      for (const [trId, tr] of Object.entries(this.textRenderers)) {
        if (tr.canRenderFont(trProps)) {
          rendererId = trId;
          break;
        }
      }
      if (!rendererId && this.textRenderers.canvas !== void 0) {
        rendererId = "canvas";
      }
    }
    if (overrideFallback) {
      console.warn(`Falling back to text renderer ${String(rendererId)}`);
    }
    if (!rendererId) {
      return null;
    }
    const resolvedTextRenderer = this.textRenderers[rendererId];
    assertTruthy(resolvedTextRenderer, "resolvedTextRenderer undefined");
    this.fontResolveMap[fontCacheString] = resolvedTextRenderer;
    return resolvedTextRenderer;
  }
  /**
   * Create a shader controller instance
   *
   * @param type
   * @param props
   * @returns
   */
  createShaderCtr(type, props) {
    return this.shManager.loadShader(type, props);
  }
  createNode(props) {
    const resolvedProps = this.resolveNodeDefaults(props);
    return new CoreNode(this, resolvedProps);
  }
  createTextNode(props) {
    const fontSize = props.fontSize ?? 16;
    const resolvedProps = {
      ...this.resolveNodeDefaults(props),
      text: props.text ?? "",
      textRendererOverride: props.textRendererOverride ?? null,
      fontSize,
      fontFamily: props.fontFamily ?? "sans-serif",
      fontStyle: props.fontStyle ?? "normal",
      fontWeight: props.fontWeight ?? "normal",
      fontStretch: props.fontStretch ?? "normal",
      textAlign: props.textAlign ?? "left",
      contain: props.contain ?? "none",
      scrollable: props.scrollable ?? false,
      scrollY: props.scrollY ?? 0,
      offsetY: props.offsetY ?? 0,
      letterSpacing: props.letterSpacing ?? 0,
      lineHeight: props.lineHeight,
      // `undefined` is a valid value
      maxLines: props.maxLines ?? 0,
      textBaseline: props.textBaseline ?? "alphabetic",
      verticalAlign: props.verticalAlign ?? "middle",
      overflowSuffix: props.overflowSuffix ?? "...",
      debug: props.debug ?? {},
      shaderProps: null
    };
    const resolvedTextRenderer = this.resolveTextRenderer(resolvedProps, props.textRendererOverride);
    if (!resolvedTextRenderer) {
      throw new Error(`No compatible text renderer found for ${resolvedProps.fontFamily}`);
    }
    return new CoreTextNode(this, resolvedProps, resolvedTextRenderer);
  }
  setBoundsMargin(value) {
    this.boundsMargin = Array.isArray(value) ? value : [value, value, value, value];
    this.root.setUpdateType(UpdateType.RenderBounds);
  }
  /**
   * Resolves the default property values for a Node
   *
   * @remarks
   * This method is used internally by the RendererMain to resolve the default
   * property values for a Node. It is exposed publicly so that it can be used
   * by Core Driver implementations.
   *
   * @param props
   * @returns
   */
  resolveNodeDefaults(props) {
    const color = props.color ?? 4294967295;
    const colorTl = props.colorTl ?? props.colorTop ?? props.colorLeft ?? color;
    const colorTr = props.colorTr ?? props.colorTop ?? props.colorRight ?? color;
    const colorBl = props.colorBl ?? props.colorBottom ?? props.colorLeft ?? color;
    const colorBr = props.colorBr ?? props.colorBottom ?? props.colorRight ?? color;
    let data = {};
    if (this.options.inspector === true) {
      data = santizeCustomDataMap(props.data ?? {});
    }
    return {
      x: props.x ?? 0,
      y: props.y ?? 0,
      width: props.width ?? 0,
      height: props.height ?? 0,
      alpha: props.alpha ?? 1,
      autosize: props.autosize ?? false,
      boundsMargin: props.boundsMargin ?? null,
      clipping: props.clipping ?? false,
      color,
      colorTop: props.colorTop ?? color,
      colorBottom: props.colorBottom ?? color,
      colorLeft: props.colorLeft ?? color,
      colorRight: props.colorRight ?? color,
      colorBl,
      colorBr,
      colorTl,
      colorTr,
      zIndex: props.zIndex ?? 0,
      zIndexLocked: props.zIndexLocked ?? 0,
      parent: props.parent ?? null,
      texture: props.texture ?? null,
      textureOptions: props.textureOptions ?? {},
      shader: props.shader ?? this.defShaderCtr,
      // Since setting the `src` will trigger a texture load, we need to set it after
      // we set the texture. Otherwise, problems happen.
      src: props.src ?? null,
      srcHeight: props.srcHeight,
      srcWidth: props.srcWidth,
      srcX: props.srcX,
      srcY: props.srcY,
      scale: props.scale ?? null,
      scaleX: props.scaleX ?? props.scale ?? 1,
      scaleY: props.scaleY ?? props.scale ?? 1,
      mount: props.mount ?? 0,
      mountX: props.mountX ?? props.mount ?? 0,
      mountY: props.mountY ?? props.mount ?? 0,
      pivot: props.pivot ?? 0.5,
      pivotX: props.pivotX ?? props.pivot ?? 0.5,
      pivotY: props.pivotY ?? props.pivot ?? 0.5,
      rotation: props.rotation ?? 0,
      rtt: props.rtt ?? false,
      data,
      preventCleanup: props.preventCleanup ?? false,
      imageType: props.imageType,
      interactive: props.interactive ?? false,
      strictBounds: props.strictBounds ?? this.strictBounds
    };
  }
  /**
   * Cleanup Unused Textures
   *
   * @remarks
   * This method is used to cleanup unused textures that are no longer in use.
   */
  cleanup() {
    this.txMemManager.cleanup();
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/Renderer.js
var RendererMain = class extends EventEmitter {
  /**
   * Constructs a new Renderer instance
   *
   * @param settings Renderer settings
   * @param target Element ID or HTMLElement to insert the canvas into
   * @param driver Core Driver to use
   */
  constructor(settings2, target) {
    var _a2, _b, _c, _d, _e, _f;
    super();
    __publicField(this, "root");
    __publicField(this, "canvas");
    __publicField(this, "settings");
    __publicField(this, "stage");
    __publicField(this, "inspector", null);
    const resolvedTxSettings = {
      criticalThreshold: ((_a2 = settings2.textureMemory) == null ? void 0 : _a2.criticalThreshold) || 124e6,
      targetThresholdLevel: ((_b = settings2.textureMemory) == null ? void 0 : _b.targetThresholdLevel) || 0.5,
      cleanupInterval: ((_c = settings2.textureMemory) == null ? void 0 : _c.cleanupInterval) || 5e3,
      debugLogging: ((_d = settings2.textureMemory) == null ? void 0 : _d.debugLogging) || false,
      baselineMemoryAllocation: ((_e = settings2.textureMemory) == null ? void 0 : _e.baselineMemoryAllocation) || 26e6,
      doNotExceedCriticalThreshold: ((_f = settings2.textureMemory) == null ? void 0 : _f.doNotExceedCriticalThreshold) || false
    };
    const resolvedSettings = {
      appWidth: settings2.appWidth || 1920,
      appHeight: settings2.appHeight || 1080,
      textureMemory: resolvedTxSettings,
      boundsMargin: settings2.boundsMargin || 0,
      deviceLogicalPixelRatio: settings2.deviceLogicalPixelRatio || 1,
      devicePhysicalPixelRatio: settings2.devicePhysicalPixelRatio || window.devicePixelRatio,
      clearColor: settings2.clearColor ?? 0,
      fpsUpdateInterval: settings2.fpsUpdateInterval || 0,
      targetFPS: settings2.targetFPS || 0,
      numImageWorkers: settings2.numImageWorkers !== void 0 ? settings2.numImageWorkers : 2,
      enableContextSpy: settings2.enableContextSpy ?? false,
      forceWebGL2: settings2.forceWebGL2 ?? false,
      inspector: settings2.inspector ?? false,
      renderEngine: settings2.renderEngine,
      quadBufferSize: settings2.quadBufferSize ?? 4 * 1024 * 1024,
      fontEngines: settings2.fontEngines,
      strictBounds: settings2.strictBounds ?? true,
      textureProcessingTimeLimit: settings2.textureProcessingTimeLimit || 42,
      canvas: settings2.canvas || document.createElement("canvas"),
      createImageBitmapSupport: settings2.createImageBitmapSupport || "full",
      maxRetryCount: settings2.maxRetryCount ?? 5
    };
    this.settings = resolvedSettings;
    const { appWidth, appHeight, deviceLogicalPixelRatio, devicePhysicalPixelRatio, inspector, canvas } = resolvedSettings;
    const deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
    const deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
    this.canvas = canvas;
    canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
    canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
    canvas.style.width = `${deviceLogicalWidth}px`;
    canvas.style.height = `${deviceLogicalHeight}px`;
    this.stage = new Stage({
      appWidth: this.settings.appWidth,
      appHeight: this.settings.appHeight,
      boundsMargin: this.settings.boundsMargin,
      clearColor: this.settings.clearColor,
      canvas: this.canvas,
      deviceLogicalPixelRatio: this.settings.deviceLogicalPixelRatio,
      devicePhysicalPixelRatio: this.settings.devicePhysicalPixelRatio,
      enableContextSpy: this.settings.enableContextSpy,
      forceWebGL2: this.settings.forceWebGL2,
      fpsUpdateInterval: this.settings.fpsUpdateInterval,
      targetFPS: this.settings.targetFPS,
      numImageWorkers: this.settings.numImageWorkers,
      renderEngine: this.settings.renderEngine,
      textureMemory: resolvedTxSettings,
      eventBus: this,
      quadBufferSize: this.settings.quadBufferSize,
      fontEngines: this.settings.fontEngines,
      inspector: this.settings.inspector !== null,
      strictBounds: this.settings.strictBounds,
      textureProcessingTimeLimit: this.settings.textureProcessingTimeLimit,
      createImageBitmapSupport: this.settings.createImageBitmapSupport,
      maxRetryCount: this.settings.maxRetryCount
    });
    this.root = this.stage.root;
    let targetEl;
    if (typeof target === "string") {
      targetEl = document.getElementById(target);
    } else {
      targetEl = target;
    }
    if (!targetEl) {
      throw new Error("Could not find target element");
    }
    targetEl.appendChild(canvas);
    if (inspector && !isProductionEnvironment) {
      this.inspector = new inspector(canvas, resolvedSettings);
    }
  }
  /**
   * Create a new scene graph node
   *
   * @remarks
   * A node is the main graphical building block of the Renderer scene graph. It
   * can be a container for other nodes, or it can be a leaf node that renders a
   * solid color, gradient, image, or specific texture, using a specific shader.
   *
   * To create a text node, see {@link createTextNode}.
   *
   * See {@link CoreNode} for more details.
   *
   * @param props
   * @returns
   */
  createNode(props) {
    const node = this.stage.createNode(props);
    if (this.inspector) {
      return this.inspector.createNode(node);
    }
    return node;
  }
  /**
   * Create a new scene graph text node
   *
   * @remarks
   * A text node is the second graphical building block of the Renderer scene
   * graph. It renders text using a specific text renderer that is automatically
   * chosen based on the font requested and what type of fonts are installed
   * into an app.
   *
   * See {@link ITextNode} for more details.
   *
   * @param props
   * @returns
   */
  createTextNode(props) {
    const textNode = this.stage.createTextNode(props);
    if (this.inspector) {
      return this.inspector.createTextNode(textNode);
    }
    return textNode;
  }
  /**
   * Destroy a node
   *
   * @remarks
   * This method destroys a node
   *
   * @param node
   * @returns
   */
  destroyNode(node) {
    if (this.inspector) {
      this.inspector.destroyNode(node.id);
    }
    return node.destroy();
  }
  /**
   * Create a new texture reference
   *
   * @remarks
   * This method creates a new reference to a texture. The texture is not
   * loaded until it is used on a node.
   *
   * It can be assigned to a node's `texture` property, or it can be used
   * when creating a SubTexture.
   *
   * @param textureType
   * @param props
   * @param options
   * @returns
   */
  createTexture(textureType, props) {
    return this.stage.txManager.createTexture(textureType, props);
  }
  /**
   * Create a new shader controller for a shader type
   *
   * @remarks
   * This method creates a new Shader Controller for a specific shader type.
   *
   * If the shader has not been loaded yet, it will be loaded. Otherwise, the
   * existing shader will be reused.
   *
   * It can be assigned to a Node's `shader` property.
   *
   * @param shaderType
   * @param props
   * @returns
   */
  createShader(shaderType, props) {
    return this.stage.shManager.loadShader(shaderType, props);
  }
  /**
   * Create a new Dynamic Shader controller
   *
   * @remarks
   * A Dynamic Shader is a shader that can be composed of an array of mulitple
   * effects. Each effect can be animated or changed after creation (provided
   * the effect is given a name).
   *
   * Example:
   * ```ts
   * renderer.createNode({
   *   shader: renderer.createDynamicShader([
   *     renderer.createEffect('radius', {
   *       radius: 0
   *     }, 'effect1'),
   *     renderer.createEffect('border', {
   *       color: 0xff00ffff,
   *       width: 10,
   *     }, 'effect2'),
   *   ]),
   * });
   * ```
   *
   * @param effects
   * @returns
   */
  createDynamicShader(effects) {
    return this.stage.shManager.loadDynamicShader({
      effects
    });
  }
  /**
   * Create an effect to be used in a Dynamic Shader
   *
   * @remark
   * The {name} parameter is optional but required if you want to animate the effect
   * or change the effect's properties after creation.
   *
   * See {@link createDynamicShader} for an example.
   *
   * @param type
   * @param props
   * @param name
   * @returns
   */
  createEffect(type, props, name) {
    return {
      name,
      type,
      props
    };
  }
  /**
   * Get a Node by its ID
   *
   * @param id
   * @returns
   */
  getNodeById(id) {
    var _a2;
    const root = (_a2 = this.stage) == null ? void 0 : _a2.root;
    if (!root) {
      return null;
    }
    const findNode = (node) => {
      if (node.id === id) {
        return node;
      }
      for (const child of node.children) {
        const found = findNode(child);
        if (found) {
          return found;
        }
      }
      return null;
    };
    return findNode(root);
  }
  toggleFreeze() {
    throw new Error("Not implemented");
  }
  advanceFrame() {
    throw new Error("Not implemented");
  }
  getBufferInfo() {
    return this.stage.renderer.getBufferInfo();
  }
  /**
   * Re-render the current frame without advancing any running animations.
   *
   * @remarks
   * Any state changes will be reflected in the re-rendered frame. Useful for
   * debugging.
   *
   * May not do anything if the render loop is running on a separate worker.
   */
  rerender() {
    this.stage.requestRender();
  }
  /**
   * Cleanup textures that are not being used
   *
   * @remarks
   * This can be used to free up GFX memory used by textures that are no longer
   * being displayed.
   *
   * This routine is also called automatically when the memory used by textures
   * exceeds the critical threshold on frame generation **OR** when the renderer
   * is idle and the memory used by textures exceeds the target threshold.
   *
   * **NOTE**: This is a heavy operation and should be used sparingly.
   * **NOTE2**: This will not cleanup textures that are currently being displayed.
   * **NOTE3**: This will not cleanup textures that are marked as `preventCleanup`.
   * **NOTE4**: This has nothing to do with the garbage collection of JavaScript.
   */
  cleanup() {
    this.stage.cleanup();
  }
  /**
   * Sets the clear color for the stage.
   *
   * @param color - The color to set as the clear color.
   */
  setClearColor(color) {
    this.stage.setClearColor(color);
  }
  /**
   * Gets the target FPS for the global render loop
   *
   * @returns The current target FPS (0 means no throttling)
   *
   * @remarks
   * This controls the maximum frame rate of the entire rendering system.
   * When 0, the system runs at display refresh rate.
   */
  get targetFPS() {
    return this.stage.options.targetFPS;
  }
  /**
   * Sets the target FPS for the global render loop
   *
   * @param fps - The target FPS to set for the global render loop.
   *              Set to 0 or a negative value to disable throttling.
   *
   * @remarks
   * This setting affects the entire rendering system immediately.
   * All animations, rendering, and frame updates will be throttled
   * to this target FPS. Provides global performance control.
   *
   * @example
   * ```typescript
   * // Set global target to 30fps for better performance
   * renderer.targetFPS = 30;
   *
   * // Disable global throttling (use display refresh rate)
   * renderer.targetFPS = 0;
   * ```
   */
  set targetFPS(fps) {
    this.stage.options.targetFPS = fps > 0 ? fps : 0;
    this.stage.updateTargetFrameTime();
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/TrFontFace.js
var TrFontFace = class extends EventEmitter {
  constructor(options) {
    super();
    __publicField(this, "fontFamily");
    __publicField(this, "descriptors");
    __publicField(this, "loaded", false);
    __publicField(this, "metrics", null);
    const { fontFamily, descriptors, metrics } = options;
    if (metrics) {
      this.metrics = {
        ascender: metrics.ascender / metrics.unitsPerEm,
        descender: metrics.descender / metrics.unitsPerEm,
        lineGap: metrics.lineGap / metrics.unitsPerEm
      };
    }
    this.fontFamily = fontFamily;
    this.descriptors = {
      style: "normal",
      weight: "normal",
      stretch: "normal",
      ...descriptors
    };
  }
  /**
   * Convert a TrFontFaceDescriptors to a FontFaceDescriptors which differ slightly
   *
   * @param descriptors
   * @returns
   */
  static convertToCssFontFaceDescriptors(descriptors) {
    return {
      style: descriptors.style,
      weight: typeof descriptors.weight === "number" ? `${descriptors.weight}` : descriptors.weight,
      stretch: descriptors.stretch,
      unicodeRange: descriptors.unicodeRange,
      featureSettings: descriptors.featureSettings,
      display: descriptors.display
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/WebTrFontFace.js
var WebTrFontFace = class extends TrFontFace {
  constructor(options) {
    super(options);
    __publicField(this, "fontFace");
    __publicField(this, "fontUrl");
    const { fontFamily, fontUrl } = options;
    const fontUrlWithoutParentheses = fontUrl.replace(/\(|\)/g, "");
    const determinedDescriptors = this.descriptors;
    let cssDescriptors = {
      style: determinedDescriptors.style,
      weight: typeof determinedDescriptors.weight === "number" ? `${determinedDescriptors.weight}` : determinedDescriptors.weight,
      stretch: determinedDescriptors.stretch,
      unicodeRange: determinedDescriptors.unicodeRange,
      featureSettings: determinedDescriptors.featureSettings,
      display: determinedDescriptors.display
    };
    for (const k in cssDescriptors) {
      const key = k;
      if (cssDescriptors[key] === void 0) {
        delete cssDescriptors[key];
      }
    }
    const fontFace = new FontFace(fontFamily, `url(${fontUrlWithoutParentheses})`, cssDescriptors);
    if (fontUrlWithoutParentheses.length > 0) {
      fontFace.load().then(() => {
        this.loaded = true;
        this.emit("loaded");
      }).catch(console.error);
    } else {
      this.loaded = true;
      this.emit("loaded");
    }
    this.fontFace = fontFace;
    this.fontUrl = fontUrl;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreRenderOp.js
var CoreRenderOp = class {
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreRenderOp.js
var WebGlCoreRenderOp = class extends CoreRenderOp {
  constructor(glw, options, buffers, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, zIndex, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
    super();
    __publicField(this, "glw");
    __publicField(this, "options");
    __publicField(this, "buffers");
    __publicField(this, "shader");
    __publicField(this, "shaderProps");
    __publicField(this, "alpha");
    __publicField(this, "clippingRect");
    __publicField(this, "dimensions");
    __publicField(this, "bufferIdx");
    __publicField(this, "zIndex");
    __publicField(this, "renderToTexture");
    __publicField(this, "parentHasRenderTexture");
    __publicField(this, "framebufferDimensions");
    __publicField(this, "length", 0);
    __publicField(this, "numQuads", 0);
    __publicField(this, "textures", []);
    __publicField(this, "maxTextures");
    this.glw = glw;
    this.options = options;
    this.buffers = buffers;
    this.shader = shader;
    this.shaderProps = shaderProps;
    this.alpha = alpha;
    this.clippingRect = clippingRect;
    this.dimensions = dimensions;
    this.bufferIdx = bufferIdx;
    this.zIndex = zIndex;
    this.renderToTexture = renderToTexture;
    this.parentHasRenderTexture = parentHasRenderTexture;
    this.framebufferDimensions = framebufferDimensions;
    this.maxTextures = shader.supportsIndexedTextures ? glw.getParameter(glw.MAX_VERTEX_TEXTURE_IMAGE_UNITS) : 1;
  }
  addTexture(texture) {
    const { textures, maxTextures } = this;
    let existingIdx = -1;
    const texturesLength = textures.length;
    for (let i = 0; i < texturesLength; i++) {
      const t = textures[i];
      if (t === texture) {
        existingIdx = i;
        break;
      }
    }
    if (existingIdx !== -1) {
      return existingIdx;
    }
    if (texturesLength >= maxTextures) {
      return 4294967295;
    }
    this.textures.push(texture);
    return texturesLength;
  }
  draw() {
    const { glw, shader, shaderProps, options } = this;
    const { shManager } = options;
    shManager.useShader(shader);
    shader.bindRenderOp(this, shaderProps);
    const quadIdx = this.bufferIdx / 32 * 6 * 2;
    if (this.clippingRect.valid) {
      const { x, y, width, height } = this.clippingRect;
      const pixelRatio = this.parentHasRenderTexture ? 1 : options.pixelRatio;
      const canvasHeight = options.canvas.height;
      const clipX = Math.round(x * pixelRatio);
      const clipWidth = Math.round(width * pixelRatio);
      const clipHeight = Math.round(height * pixelRatio);
      let clipY = Math.round(canvasHeight - clipHeight - y * pixelRatio);
      if (this.parentHasRenderTexture) {
        clipY = this.framebufferDimensions ? this.framebufferDimensions.height - this.dimensions.height : 0;
      }
      glw.setScissorTest(true);
      glw.scissor(clipX, clipY, clipWidth, clipHeight);
    } else {
      glw.setScissorTest(false);
    }
    glw.drawElements(glw.TRIANGLES, 6 * this.numQuads, glw.UNSIGNED_SHORT, quadIdx);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/RendererUtils.js
function getWebGlParameters(glw) {
  const params = {
    MAX_RENDERBUFFER_SIZE: 0,
    MAX_TEXTURE_SIZE: 0,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
    MAX_VIEWPORT_DIMS: 0,
    // Code below will replace this with an Int32Array
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0,
    MAX_TEXTURE_IMAGE_UNITS: 0,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0,
    MAX_VERTEX_ATTRIBS: 0,
    MAX_VARYING_VECTORS: 0,
    MAX_VERTEX_UNIFORM_VECTORS: 0,
    MAX_FRAGMENT_UNIFORM_VECTORS: 0
  };
  const keys = Object.keys(params);
  keys.forEach((key) => {
    params[key] = glw.getParameter(glw[key]);
  });
  return params;
}
function getWebGlExtensions(glw) {
  const extensions = {
    ANGLE_instanced_arrays: null,
    WEBGL_compressed_texture_s3tc: null,
    WEBGL_compressed_texture_astc: null,
    WEBGL_compressed_texture_etc: null,
    WEBGL_compressed_texture_etc1: null,
    WEBGL_compressed_texture_pvrtc: null,
    WEBKIT_WEBGL_compressed_texture_pvrtc: null,
    WEBGL_compressed_texture_s3tc_srgb: null,
    OES_vertex_array_object: null
  };
  const keys = Object.keys(extensions);
  keys.forEach((key) => {
    extensions[key] = glw.getExtension(key);
  });
  return extensions;
}
function createIndexBuffer(glw, size) {
  const maxQuads = ~~(size / 80);
  const indices = new Uint16Array(maxQuads * 6);
  for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
    indices[i] = j;
    indices[i + 1] = j + 1;
    indices[i + 2] = j + 2;
    indices[i + 3] = j + 2;
    indices[i + 4] = j + 1;
    indices[i + 5] = j + 3;
  }
  const buffer = glw.createBuffer();
  glw.elementArrayBufferData(buffer, indices, glw.STATIC_DRAW);
}
function isHTMLImageElement(obj) {
  return obj !== null && (typeof obj === "object" && obj.constructor && obj.constructor.name === "HTMLImageElement" || typeof HTMLImageElement !== "undefined" && obj instanceof HTMLImageElement);
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxTexture.js
var TRANSPARENT_TEXTURE_DATA = new Uint8Array([0, 0, 0, 0]);
var WebGlCoreCtxTexture = class extends CoreContextTexture {
  constructor(glw, memManager, textureSource) {
    super(memManager, textureSource);
    __publicField(this, "glw");
    __publicField(this, "_nativeCtxTexture", null);
    __publicField(this, "_w", 0);
    __publicField(this, "_h", 0);
    __publicField(this, "txCoordX1", 0);
    __publicField(this, "txCoordY1", 0);
    __publicField(this, "txCoordX2", 1);
    __publicField(this, "txCoordY2", 1);
    this.glw = glw;
  }
  /**
   * GL error check with direct state marking
   * Uses cached error result to minimize function calls
   */
  checkGLError() {
    if (this.state === "failed") {
      return true;
    }
    const error = this.glw.getError();
    if (error !== 0) {
      this.state = "failed";
      this.textureSource.setState("failed", new Error(`WebGL Error: ${error}`));
      return true;
    }
    return false;
  }
  get ctxTexture() {
    if (this.state === "freed") {
      this.load();
      return null;
    }
    assertTruthy(this._nativeCtxTexture);
    return this._nativeCtxTexture;
  }
  get w() {
    return this._w;
  }
  get h() {
    return this._h;
  }
  /**
   * Load the texture data from the Texture source and upload it to the GPU
   *
   * @remarks
   * This method is called automatically when accessing the ctxTexture property
   * if the texture hasn't been loaded yet. But it can also be called manually
   * to force the texture to be pre-loaded prior to accessing the ctxTexture
   * property.
   */
  async load() {
    if (this.state === "loading" || this.state === "loaded") {
      return Promise.resolve();
    }
    this.state = "loading";
    this.textureSource.setState("loading");
    this._nativeCtxTexture = this.createNativeCtxTexture();
    if (this._nativeCtxTexture === null) {
      this.state = "failed";
      this.textureSource.setState("failed", new Error("WebGL Texture creation failed"));
      return;
    }
    try {
      const { width, height } = await this.onLoadRequest();
      if (this.state === "freed") {
        return;
      }
      this.state = "loaded";
      this._w = width;
      this._h = height;
      this.textureSource.setState("loaded", { width, height });
      this.textureSource.freeTextureData();
    } catch (err) {
      if (this.state === "freed") {
        return;
      }
      this.state = "failed";
      this.textureSource.setState("failed");
    }
  }
  /**
   * Called when the texture data needs to be loaded and uploaded to a texture
   */
  async onLoadRequest() {
    var _a2;
    const { glw } = this;
    const textureData = this.textureSource.textureData;
    if (this.state === "failed") {
      return { width: 0, height: 0 };
    }
    if (textureData === null || this._nativeCtxTexture === null) {
      this.state = "failed";
      this.textureSource.setState("failed", new Error("No texture data available"));
      return { width: 0, height: 0 };
    }
    glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
    this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
    let width = 0;
    let height = 0;
    glw.activeTexture(0);
    if (this.checkGLError() === true) {
      return { width: 0, height: 0 };
    }
    const tdata = textureData.data;
    const format = glw.RGBA;
    const formatBytes = 4;
    const memoryPadding = 1.1;
    if (typeof ImageBitmap !== "undefined" && tdata instanceof ImageBitmap || tdata instanceof ImageData || // not using typeof HTMLImageElement due to web worker
    isHTMLImageElement(tdata)) {
      width = tdata.width;
      height = tdata.height;
      glw.bindTexture(this._nativeCtxTexture);
      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
      glw.texImage2D(0, format, format, glw.UNSIGNED_BYTE, tdata);
      if (this.checkGLError() === true) {
        return { width: 0, height: 0 };
      }
      this.setTextureMemUse(height * width * formatBytes * memoryPadding);
    } else if (tdata && "mipmaps" in tdata && tdata.mipmaps) {
      const { mipmaps, type, blockInfo } = tdata;
      uploadCompressedTexture[type](glw, this._nativeCtxTexture, tdata);
      if (this.checkGLError() === true) {
        return { width: 0, height: 0 };
      }
      width = tdata.width;
      height = tdata.height;
      this.txCoordX2 = width / (Math.ceil(width / blockInfo.width) * blockInfo.width);
      this.txCoordY2 = height / (Math.ceil(height / blockInfo.height) * blockInfo.height);
      this.setTextureMemUse(((_a2 = mipmaps[0]) == null ? void 0 : _a2.byteLength) ?? 0);
    } else if (tdata && tdata instanceof Uint8Array) {
      width = 1;
      height = 1;
      glw.bindTexture(this._nativeCtxTexture);
      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
      glw.texImage2D(0, format, width, height, 0, format, glw.UNSIGNED_BYTE, tdata);
      if (this.checkGLError() === true) {
        return { width: 0, height: 0 };
      }
      this.setTextureMemUse(width * height * formatBytes);
    } else {
      console.error(`WebGlCoreCtxTexture.onLoadRequest: Unexpected textureData returned`, textureData);
      this.state = "failed";
      this.textureSource.setState("failed", new Error("Unexpected texture data"));
      return { width: 0, height: 0 };
    }
    return {
      width,
      height
    };
  }
  /**
   * Free the WebGLTexture from the GPU
   *
   * @returns
   */
  free() {
    if (this.state === "freed") {
      return;
    }
    this.state = "freed";
    this.textureSource.setState("freed");
    this.release();
  }
  /**
   * Release the WebGLTexture from the GPU without changing state
   */
  release() {
    this._w = 0;
    this._h = 0;
    if (this._nativeCtxTexture !== null) {
      this.glw.deleteTexture(this._nativeCtxTexture);
      this.setTextureMemUse(0);
      this._nativeCtxTexture = null;
    }
    this.textureSource.freeTextureData();
  }
  /**
   * Create native context texture asynchronously
   *
   * @remarks
   * When this method resolves, the returned texture will be bound to the GL context state
   * and fully ready for use. This ensures proper GPU resource allocation timing.
   *
   * @returns Promise that resolves to the native WebGL texture or null on failure
   */
  createNativeCtxTexture() {
    const { glw } = this;
    const nativeTexture = glw.createTexture();
    if (!nativeTexture) {
      return null;
    }
    glw.activeTexture(0);
    glw.bindTexture(nativeTexture);
    glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
    glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
    glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
    glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
    const error = glw.getError();
    if (error !== 0) {
      return null;
    }
    return nativeTexture;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxSubTexture.js
var WebGlCoreCtxSubTexture = class extends WebGlCoreCtxTexture {
  constructor(glw, memManager, textureSource) {
    super(glw, memManager, textureSource);
  }
  async onLoadRequest() {
    var _a2, _b;
    const props = this.textureSource.textureData;
    assertTruthy(props, "SubTexture must have texture data");
    if (props.data instanceof Uint8Array) {
      return { width: 1, height: 1 };
    }
    return {
      width: ((_a2 = props.data) == null ? void 0 : _a2.width) || 0,
      height: ((_b = props.data) == null ? void 0 : _b.height) || 0
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/BufferCollection.js
var BufferCollection = class {
  constructor(config) {
    __publicField(this, "config");
    this.config = config;
  }
  /**
   * Get the WebGLBuffer associated with the given attribute name if it exists.
   *
   * @param attributeName
   * @returns
   */
  getBuffer(attributeName) {
    var _a2;
    return (_a2 = this.config.find((item) => item.attributes[attributeName])) == null ? void 0 : _a2.buffer;
  }
  /**
   * Get the AttributeInfo associated with the given attribute name if it exists.
   *
   * @param attributeName
   * @returns
   */
  getAttributeInfo(attributeName) {
    var _a2;
    return (_a2 = this.config.find((item) => item.attributes[attributeName])) == null ? void 0 : _a2.attributes[attributeName];
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/WebGlUtils.js
function isWebGl2(gl) {
  return self.WebGL2RenderingContext && gl instanceof self.WebGL2RenderingContext;
}

// node_modules/@lightningjs/renderer/dist/src/core/lib/WebGlContextWrapper.js
var WebGlContextWrapper = class {
  //#endregion WebGL Enums
  constructor(gl) {
    __publicField(this, "gl");
    //#region Cached WebGL State
    __publicField(this, "activeTextureUnit", 0);
    __publicField(this, "texture2dUnits");
    __publicField(this, "texture2dParams", /* @__PURE__ */ new WeakMap());
    __publicField(this, "scissorEnabled");
    __publicField(this, "scissorX");
    __publicField(this, "scissorY");
    __publicField(this, "scissorWidth");
    __publicField(this, "scissorHeight");
    __publicField(this, "blendEnabled");
    __publicField(this, "blendSrcRgb");
    __publicField(this, "blendDstRgb");
    __publicField(this, "blendSrcAlpha");
    __publicField(this, "blendDstAlpha");
    __publicField(this, "boundArrayBuffer");
    __publicField(this, "boundElementArrayBuffer");
    __publicField(this, "curProgram");
    //#endregion Cached WebGL State
    //#region Canvas
    __publicField(this, "canvas");
    //#endregion Canvas
    //#region WebGL Enums
    __publicField(this, "MAX_RENDERBUFFER_SIZE");
    __publicField(this, "MAX_TEXTURE_SIZE");
    __publicField(this, "MAX_VIEWPORT_DIMS");
    __publicField(this, "MAX_VERTEX_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_COMBINED_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_VERTEX_ATTRIBS");
    __publicField(this, "MAX_VARYING_VECTORS");
    __publicField(this, "MAX_VERTEX_UNIFORM_VECTORS");
    __publicField(this, "MAX_FRAGMENT_UNIFORM_VECTORS");
    __publicField(this, "TEXTURE_MAG_FILTER");
    __publicField(this, "TEXTURE_MIN_FILTER");
    __publicField(this, "TEXTURE_WRAP_S");
    __publicField(this, "TEXTURE_WRAP_T");
    __publicField(this, "LINEAR");
    __publicField(this, "LINEAR_MIPMAP_LINEAR");
    __publicField(this, "CLAMP_TO_EDGE");
    __publicField(this, "RGB");
    __publicField(this, "RGBA");
    __publicField(this, "UNSIGNED_BYTE");
    __publicField(this, "UNPACK_PREMULTIPLY_ALPHA_WEBGL");
    __publicField(this, "UNPACK_FLIP_Y_WEBGL");
    __publicField(this, "FLOAT");
    __publicField(this, "TRIANGLES");
    __publicField(this, "UNSIGNED_SHORT");
    __publicField(this, "ONE");
    __publicField(this, "ONE_MINUS_SRC_ALPHA");
    __publicField(this, "VERTEX_SHADER");
    __publicField(this, "FRAGMENT_SHADER");
    __publicField(this, "STATIC_DRAW");
    __publicField(this, "COMPILE_STATUS");
    __publicField(this, "LINK_STATUS");
    __publicField(this, "DYNAMIC_DRAW");
    __publicField(this, "COLOR_ATTACHMENT0");
    __publicField(this, "INVALID_ENUM");
    __publicField(this, "INVALID_OPERATION");
    this.gl = gl;
    this.activeTextureUnit = gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
    const maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.texture2dUnits = new Array(maxTextureUnits).fill(void 0).map((_, i) => {
      this.activeTexture(i);
      return gl.getParameter(gl.TEXTURE_BINDING_2D);
    });
    this.activeTexture(this.activeTextureUnit);
    this.scissorEnabled = gl.isEnabled(gl.SCISSOR_TEST);
    const scissorBox = gl.getParameter(gl.SCISSOR_BOX);
    this.scissorX = scissorBox[0];
    this.scissorY = scissorBox[1];
    this.scissorWidth = scissorBox[2];
    this.scissorHeight = scissorBox[3];
    this.blendEnabled = gl.isEnabled(gl.BLEND);
    this.blendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
    this.blendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
    this.blendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
    this.blendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
    this.boundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
    this.boundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
    this.curProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    this.canvas = gl.canvas;
    this.MAX_RENDERBUFFER_SIZE = gl.MAX_RENDERBUFFER_SIZE;
    this.MAX_TEXTURE_SIZE = gl.MAX_TEXTURE_SIZE;
    this.MAX_VIEWPORT_DIMS = gl.MAX_VIEWPORT_DIMS;
    this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    this.MAX_TEXTURE_IMAGE_UNITS = gl.MAX_TEXTURE_IMAGE_UNITS;
    this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
    this.MAX_VERTEX_ATTRIBS = gl.MAX_VERTEX_ATTRIBS;
    this.MAX_VARYING_VECTORS = gl.MAX_VARYING_VECTORS;
    this.MAX_VERTEX_UNIFORM_VECTORS = gl.MAX_VERTEX_UNIFORM_VECTORS;
    this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.MAX_FRAGMENT_UNIFORM_VECTORS;
    this.TEXTURE_MAG_FILTER = gl.TEXTURE_MAG_FILTER;
    this.TEXTURE_MIN_FILTER = gl.TEXTURE_MIN_FILTER;
    this.TEXTURE_WRAP_S = gl.TEXTURE_WRAP_S;
    this.TEXTURE_WRAP_T = gl.TEXTURE_WRAP_T;
    this.LINEAR = gl.LINEAR;
    this.LINEAR_MIPMAP_LINEAR = gl.LINEAR_MIPMAP_LINEAR;
    this.CLAMP_TO_EDGE = gl.CLAMP_TO_EDGE;
    this.RGB = gl.RGB;
    this.RGBA = gl.RGBA;
    this.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
    this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
    this.UNPACK_FLIP_Y_WEBGL = gl.UNPACK_FLIP_Y_WEBGL;
    this.FLOAT = gl.FLOAT;
    this.TRIANGLES = gl.TRIANGLES;
    this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    this.ONE = gl.ONE;
    this.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
    this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    this.TRIANGLES = gl.TRIANGLES;
    this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    this.VERTEX_SHADER = gl.VERTEX_SHADER;
    this.FRAGMENT_SHADER = gl.FRAGMENT_SHADER;
    this.STATIC_DRAW = gl.STATIC_DRAW;
    this.COMPILE_STATUS = gl.COMPILE_STATUS;
    this.LINK_STATUS = gl.LINK_STATUS;
    this.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;
    this.COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
    this.INVALID_ENUM = gl.INVALID_ENUM;
    this.INVALID_OPERATION = gl.INVALID_OPERATION;
  }
  /**
   * Returns true if the WebGL context is WebGL2
   *
   * @returns
   */
  isWebGl2() {
    return isWebGl2(this.gl);
  }
  /**
   * ```
   * gl.activeTexture(textureUnit + gl.TEXTURE0);
   * ```
   *
   * @remarks
   * **WebGL Difference**: `textureUnit` is based from 0, not `gl.TEXTURE0`.
   *
   * @param textureUnit
   */
  activeTexture(textureUnit) {
    const { gl } = this;
    if (this.activeTextureUnit !== textureUnit) {
      gl.activeTexture(textureUnit + gl.TEXTURE0);
      this.activeTextureUnit = textureUnit;
    }
  }
  /**
   * ```
   * gl.bindTexture(gl.TEXTURE_2D, texture);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   *
   * @param texture
   */
  bindTexture(texture) {
    const { gl, activeTextureUnit, texture2dUnits } = this;
    if (texture2dUnits[activeTextureUnit] === texture) {
      return;
    }
    texture2dUnits[activeTextureUnit] = texture;
    gl.bindTexture(this.gl.TEXTURE_2D, texture);
  }
  _getActiveTexture() {
    const { activeTextureUnit, texture2dUnits } = this;
    return texture2dUnits[activeTextureUnit];
  }
  /**
   * ```
   * gl.texParameteri(gl.TEXTURE_2D, pname, param);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   *
   * @param pname
   * @param param
   * @returns
   */
  texParameteri(pname, param) {
    const { gl, texture2dParams } = this;
    const activeTexture = this._getActiveTexture();
    if (!activeTexture) {
      throw new Error("No active texture");
    }
    let textureParams = texture2dParams.get(activeTexture);
    if (!textureParams) {
      textureParams = {};
      texture2dParams.set(activeTexture, textureParams);
    }
    if (textureParams[pname] === param) {
      return;
    }
    textureParams[pname] = param;
    gl.texParameteri(gl.TEXTURE_2D, pname, param);
  }
  texImage2D(level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels) {
    const { gl } = this;
    if (format) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource);
    }
  }
  /**
   * ```
   * gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, data);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   */
  compressedTexImage2D(level, internalformat, width, height, border, data) {
    const { gl } = this;
    gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalformat, width, height, border, data);
  }
  /**
   * ```
   * gl.pixelStorei(pname, param);
   * ```
   *
   * @param pname
   * @param param
   */
  pixelStorei(pname, param) {
    const { gl } = this;
    gl.pixelStorei(pname, param);
  }
  /**
   * ```
   * gl.generateMipmap(gl.TEXTURE_2D);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   */
  generateMipmap() {
    const { gl } = this;
    gl.generateMipmap(gl.TEXTURE_2D);
  }
  /**
   * ```
   * gl.createTexture();
   * ```
   *
   * @returns
   */
  createTexture() {
    const { gl } = this;
    return gl.createTexture();
  }
  /**
   * ```
   * gl.deleteTexture(texture);
   * ```
   *
   * @param texture
   */
  deleteTexture(texture) {
    const { gl } = this;
    if (texture) {
      this.texture2dParams.delete(texture);
    }
    gl.deleteTexture(texture);
  }
  /**
   * ```
   * gl.deleteFramebuffer(framebuffer);
   *
   * @param framebuffer
   */
  deleteFramebuffer(framebuffer) {
    this.gl.deleteFramebuffer(framebuffer);
  }
  /**
   * ```
   * gl.viewport(x, y, width, height);
   * ```
   */
  viewport(x, y, width, height) {
    const { gl } = this;
    gl.viewport(x, y, width, height);
  }
  /**
   * ```
   * gl.clearColor(red, green, blue, alpha);
   * ```
   *
   * @param red
   * @param green
   * @param blue
   * @param alpha
   */
  clearColor(red, green, blue, alpha) {
    const { gl } = this;
    gl.clearColor(red, green, blue, alpha);
  }
  /**
   * ```
   * gl["enable"|"disable"](gl.SCISSOR_TEST);
   * ```
   * @param enable
   */
  setScissorTest(enable2) {
    const { gl, scissorEnabled } = this;
    if (enable2 === scissorEnabled) {
      return;
    }
    if (enable2) {
      gl.enable(gl.SCISSOR_TEST);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
    this.scissorEnabled = enable2;
  }
  /**
   * ```
   * gl.scissor(x, y, width, height);
   * ```
   *
   * @param x
   * @param y
   * @param width
   * @param height
   */
  scissor(x, y, width, height) {
    const { gl, scissorX, scissorY, scissorWidth, scissorHeight } = this;
    if (x !== scissorX || y !== scissorY || width !== scissorWidth || height !== scissorHeight) {
      gl.scissor(x, y, width, height);
      this.scissorX = x;
      this.scissorY = y;
      this.scissorWidth = width;
      this.scissorHeight = height;
    }
  }
  /**
   * ```
   * gl["enable"|"disable"](gl.BLEND);
   * ```
   *
   * @param blend
   * @returns
   */
  setBlend(blend) {
    const { gl, blendEnabled } = this;
    if (blend === blendEnabled) {
      return;
    }
    if (blend) {
      gl.enable(gl.BLEND);
    } else {
      gl.disable(gl.BLEND);
    }
    this.blendEnabled = blend;
  }
  /**
   * ```
   * gl.blendFunc(src, dst);
   * ```
   *
   * @param src
   * @param dst
   */
  blendFunc(src, dst) {
    const { gl, blendSrcRgb, blendDstRgb, blendSrcAlpha, blendDstAlpha } = this;
    if (src !== blendSrcRgb || dst !== blendDstRgb || src !== blendSrcAlpha || dst !== blendDstAlpha) {
      gl.blendFunc(src, dst);
      this.blendSrcRgb = src;
      this.blendDstRgb = dst;
      this.blendSrcAlpha = src;
      this.blendDstAlpha = dst;
    }
  }
  /**
   * ```
   * gl.createBuffer();
   * ```
   *
   * @returns
   */
  createBuffer() {
    const { gl } = this;
    return gl.createBuffer();
  }
  /**
   * ```
   * gl.createFramebuffer();
   * ```
   * @returns
   */
  createFramebuffer() {
    const { gl } = this;
    return gl.createFramebuffer();
  }
  /**
   * ```
   * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
   * ```
   *
   * @param framebuffer
   */
  bindFramebuffer(framebuffer) {
    const { gl } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  }
  /**
   * ```
   * gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.FRAMEBUFFER` and textarget is always `gl.TEXTURE_2D`
   */
  framebufferTexture2D(attachment, texture, level) {
    const { gl } = this;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
  }
  /**
   * ```
   * gl.clear(gl.COLOR_BUFFER_BIT);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Clear mask is always `gl.COLOR_BUFFER_BIT`
   */
  clear() {
    const { gl } = this;
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
   * gl.bufferData(gl.ARRAY_BUFFER, data, usage);
   * ```
   *
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
   *
   * @param buffer
   * @param data
   * @param usage
   */
  arrayBufferData(buffer, data, usage) {
    const { gl, boundArrayBuffer } = this;
    if (boundArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      this.boundArrayBuffer = buffer;
    }
    gl.bufferData(gl.ARRAY_BUFFER, data, usage);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
   * gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
   * ```
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
   *
   * @param buffer
   * @param data
   * @param usage
   */
  elementArrayBufferData(buffer, data, usage) {
    const { gl, boundElementArrayBuffer } = this;
    if (boundElementArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      this.boundElementArrayBuffer = buffer;
    }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
   * gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
   * ```
   *
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.vertexAttribPointer` are combined into one function.
   *
   * @param buffer
   * @param index
   * @param size
   * @param type
   * @param normalized
   * @param stride
   * @param offset
   */
  vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
    const { gl, boundArrayBuffer } = this;
    if (boundArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      this.boundArrayBuffer = buffer;
    }
    gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
  }
  /**
   * Returns object with Attribute names as key and numbers as location values
   *
   * @param program
   * @returns object with numbers
   */
  getUniformLocations(program) {
    const gl = this.gl;
    const length = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    const result = {};
    for (let i = 0; i < length; i++) {
      const info = gl.getActiveUniform(program, i);
      let name = info.name.replace(/\[.*?\]/g, "");
      result[name] = gl.getUniformLocation(program, name);
    }
    return result;
  }
  /**
   * Returns object with Attribute names as key and numbers as location values
   * @param program
   * @returns object with numbers
   */
  getAttributeLocations(program) {
    const gl = this.gl;
    const length = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    const result = [];
    for (let i = 0; i < length; i++) {
      const { name } = gl.getActiveAttrib(program, i);
      result[gl.getAttribLocation(program, name)] = name;
    }
    return result;
  }
  /**
   * ```
   * gl.useProgram(program);
   * ```
   *
   * @param program
   * @returns
   */
  useProgram(program) {
    const { gl, curProgram } = this;
    if (curProgram === program) {
      return;
    }
    gl.useProgram(program);
    this.curProgram = program;
  }
  /**
   * Sets the value of a single float uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The value to set.
   */
  uniform1f(location, v0) {
    const { gl } = this;
    gl.uniform1f(location, v0);
  }
  /**
   * Sets the value of a float array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of values to set.
   */
  uniform1fv(location, value) {
    const { gl } = this;
    gl.uniform1fv(location, value);
  }
  /**
   * Sets the value of a single integer uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The value to set.
   */
  uniform1i(location, v0) {
    const { gl } = this;
    gl.uniform1i(location, v0);
  }
  /**
   * Sets the value of an integer array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of values to set.
   */
  uniform1iv(location, value) {
    const { gl } = this;
    gl.uniform1iv(location, value);
  }
  /**
   * Sets the value of a vec2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   */
  uniform2f(location, v0, v1) {
    const { gl } = this;
    gl.uniform2f(location, v0, v1);
  }
  /**
   * Sets the value of a vec2 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec2 values to set.
   */
  uniform2fv(location, value) {
    const { gl } = this;
    gl.uniform2fv(location, value);
  }
  /**
   * Sets the value of a ivec2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   */
  uniform2i(location, v0, v1) {
    const { gl } = this;
    gl.uniform2i(location, v0, v1);
  }
  /**
   * Sets the value of an ivec2 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec2 values to set.
   */
  uniform2iv(location, value) {
    const { gl } = this;
    gl.uniform2iv(location, value);
  }
  /**
   * Sets the value of a vec3 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   */
  uniform3f(location, v0, v1, v2) {
    const { gl } = this;
    gl.uniform3f(location, v0, v1, v2);
  }
  /**
   * Sets the value of a vec3 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec3 values to set.
   */
  uniform3fv(location, value) {
    const { gl } = this;
    gl.uniform3fv(location, value);
  }
  /**
   * Sets the value of a ivec3 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   */
  uniform3i(location, v0, v1, v2) {
    const { gl } = this;
    gl.uniform3i(location, v0, v1, v2);
  }
  /**
   * Sets the value of an ivec3 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec3 values to set.
   */
  uniform3iv(location, value) {
    const { gl } = this;
    gl.uniform3iv(location, value);
  }
  /**
   * Sets the value of a vec4 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   * @param v3 - The fourth component of the vector.
   */
  uniform4f(location, v0, v1, v2, v3) {
    const { gl } = this;
    gl.uniform4f(location, v0, v1, v2, v3);
  }
  /**
   * Sets the value of a vec4 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec4 values to set.
   */
  uniform4fv(location, value) {
    const { gl } = this;
    gl.uniform4fv(location, value);
  }
  /**
   * Sets the value of a ivec4 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   * @param v3 - The fourth component of the vector.
   */
  uniform4i(location, v0, v1, v2, v3) {
    const { gl } = this;
    gl.uniform4i(location, v0, v1, v2, v3);
  }
  /**
   * Sets the value of an ivec4 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec4 values to set.
   */
  uniform4iv(location, value) {
    const { gl } = this;
    gl.uniform4iv(location, value);
  }
  /**
   * Sets the value of a mat2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param transpose - Whether to transpose the matrix.
   * @param value - The array of mat2 values to set.
   */
  uniformMatrix2fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix2fv(location, false, value);
  }
  /**
   * Sets the value of a mat2 uniform variable.
   * @param location - The location of the uniform variable.
   * @param value - The array of mat2 values to set.
   */
  uniformMatrix3fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix3fv(location, false, value);
  }
  /**
   * Sets the value of a mat4 uniform variable.
   * @param location - The location of the uniform variable.
   * @param value - The array of mat4 values to set.
   */
  uniformMatrix4fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix4fv(location, false, value);
  }
  /**
   * ```
   * gl.getParameter(pname);
   * ```
   *
   * @param pname
   * @returns
   */
  getParameter(pname) {
    const { gl } = this;
    return gl.getParameter(pname);
  }
  /**
   * ```
   * gl.drawElements(mode, count, type, offset);
   * ```
   *
   * @param mode
   * @param count
   * @param type
   * @param offset
   */
  drawElements(mode, count2, type, offset) {
    const { gl } = this;
    gl.drawElements(mode, count2, type, offset);
  }
  /**
   * ```
   * gl.drawArrays(mode, first, count);
   * ```
   *
   * @param name
   * @returns
   */
  getExtension(name) {
    const { gl } = this;
    return gl.getExtension(name);
  }
  /**
   * ```
   * gl.getError(type);
   * ```
   *
   * @returns
   */
  getError() {
    const { gl } = this;
    return gl.getError();
  }
  /**
   * ```
   * gl.createVertexArray();
   * ```
   *
   * @returns
   */
  createVertexArray() {
    const { gl } = this;
    assertTruthy(gl instanceof WebGL2RenderingContext);
    return gl.createVertexArray();
  }
  /**
   * ```
   * gl.bindVertexArray(vertexArray);
   * ```
   *
   * @param vertexArray
   */
  bindVertexArray(vertexArray) {
    const { gl } = this;
    assertTruthy(gl instanceof WebGL2RenderingContext);
    gl.bindVertexArray(vertexArray);
  }
  /**
   * ```
   * gl.getAttribLocation(program, name);
   * ```
   *
   * @param program
   * @param name
   * @returns
   */
  getAttribLocation(program, name) {
    const { gl } = this;
    return gl.getAttribLocation(program, name);
  }
  /**
   * ```
   * gl.getUniformLocation(program, name);
   * ```
   *
   * @param program
   * @param name
   * @returns
   */
  getUniformLocation(program, name) {
    const { gl } = this;
    return gl.getUniformLocation(program, name);
  }
  /**
   * ```
   * gl.enableVertexAttribArray(index);
   * ```
   *
   * @param index
   */
  enableVertexAttribArray(index) {
    const { gl } = this;
    gl.enableVertexAttribArray(index);
  }
  /**
   * ```
   * gl.disableVertexAttribArray(index);
   * ```
   *
   * @param index
   */
  disableVertexAttribArray(index) {
    const { gl } = this;
    gl.disableVertexAttribArray(index);
  }
  /**
   * ```
   * gl.createShader(type);
   * ```
   *
   * @param type
   * @returns
   */
  createShader(type) {
    const { gl } = this;
    return gl.createShader(type);
  }
  /**
   * ```
   * gl.compileShader(shader);
   * ```
   *
   * @param shader
   * @returns
   */
  compileShader(shader) {
    const { gl } = this;
    gl.compileShader(shader);
  }
  /**
   * ```
   * gl.attachShader(program, shader);
   * ```
   *
   * @param program
   * @param shader
   */
  attachShader(program, shader) {
    const { gl } = this;
    gl.attachShader(program, shader);
  }
  /**
   * ```
   * gl.linkProgram(program);
   * ```
   *
   * @param program
   */
  linkProgram(program) {
    const { gl } = this;
    gl.linkProgram(program);
  }
  /**
   * ```
   * gl.deleteProgram(shader);
   * ```
   *
   * @param shader
   */
  deleteProgram(shader) {
    const { gl } = this;
    gl.deleteProgram(shader);
  }
  /**
   * ```
   * gl.getShaderParameter(shader, pname);
   * ```
   *
   * @param shader
   * @param pname
   */
  getShaderParameter(shader, pname) {
    const { gl } = this;
    return gl.getShaderParameter(shader, pname);
  }
  /**
   * ```
   * gl.getShaderInfoLog(shader);
   * ```
   *
   * @param shader
   */
  getShaderInfoLog(shader) {
    const { gl } = this;
    return gl.getShaderInfoLog(shader);
  }
  /**
   * ```
   * gl.createProgram();
   * ```
   *
   * @returns
   */
  createProgram() {
    const { gl } = this;
    return gl.createProgram();
  }
  /**
   * ```
   * gl.getProgramParameter(program, pname);
   * ```
   *
   * @param program
   * @param pname
   * @returns
   */
  getProgramParameter(program, pname) {
    const { gl } = this;
    return gl.getProgramParameter(program, pname);
  }
  /**
   * ```
   * gl.getProgramInfoLog(program);
   * ```
   *
   * @param program
   * @returns
   */
  getProgramInfoLog(program) {
    const { gl } = this;
    return gl.getProgramInfoLog(program);
  }
  /**
   * ```
   * gl.shaderSource(shader, source);
   * ```
   *
   * @param shader
   * @param source
   */
  shaderSource(shader, source) {
    const { gl } = this;
    gl.shaderSource(shader, source);
  }
  /**
   * ```
   * gl.deleteShader(shader);
   * ```
   *
   * @param shader
   */
  deleteShader(shader) {
    const { gl } = this;
    gl.deleteShader(shader);
  }
  /**
   * Check for WebGL errors and return error information
   * @param operation Description of the operation for error reporting
   * @returns Object with error information or null if no error
   */
  checkError(operation) {
    const error = this.getError();
    if (error !== 0) {
      let errorName = "UNKNOWN_ERROR";
      switch (error) {
        case this.INVALID_ENUM:
          errorName = "INVALID_ENUM";
          break;
        case 1281:
          errorName = "INVALID_VALUE";
          break;
        case this.INVALID_OPERATION:
          errorName = "INVALID_OPERATION";
          break;
        case 1285:
          errorName = "OUT_OF_MEMORY";
          break;
        case 37442:
          errorName = "CONTEXT_LOST_WEBGL";
          break;
      }
      const message = `WebGL ${errorName} (0x${error.toString(16)}) during ${operation}`;
      return { error, errorName, message };
    }
    return null;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxRenderTexture.js
var WebGlCoreCtxRenderTexture = class extends WebGlCoreCtxTexture {
  constructor(glw, memManager, textureSource) {
    super(glw, memManager, textureSource);
    __publicField(this, "framebuffer", null);
  }
  async onLoadRequest() {
    const { glw } = this;
    const nativeTexture = this._nativeCtxTexture = this.createNativeCtxTexture();
    if (!nativeTexture) {
      throw new Error("Failed to create native texture for RenderTexture");
    }
    const { width, height } = this.textureSource;
    this.framebuffer = glw.createFramebuffer();
    glw.texImage2D(0, glw.RGBA, width, height, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
    this.setTextureMemUse(width * height * 4);
    glw.bindFramebuffer(this.framebuffer);
    glw.framebufferTexture2D(glw.COLOR_ATTACHMENT0, nativeTexture, 0);
    glw.bindFramebuffer(null);
    return {
      width,
      height
    };
  }
  free() {
    super.free();
    this.glw.deleteFramebuffer(this.framebuffer);
    this.framebuffer = null;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreRenderer.js
var WebGlCoreRenderer = class extends CoreRenderer {
  constructor(options) {
    super(options);
    //// WebGL Native Context and Data
    __publicField(this, "glw");
    __publicField(this, "system");
    //// Persistent data
    __publicField(this, "quadBuffer");
    __publicField(this, "fQuadBuffer");
    __publicField(this, "uiQuadBuffer");
    __publicField(this, "renderOps", []);
    //// Render Op / Buffer Filling State
    __publicField(this, "curBufferIdx", 0);
    __publicField(this, "curRenderOp", null);
    __publicField(this, "rttNodes", []);
    __publicField(this, "activeRttNode", null);
    //// Default Shader
    __publicField(this, "defShaderCtrl");
    __publicField(this, "defaultShader");
    __publicField(this, "quadBufferCollection");
    __publicField(this, "clearColor", {
      raw: 0,
      normalized: [0, 0, 0, 0]
    });
    /**
     * White pixel texture used by default when no texture is specified.
     */
    __publicField(this, "quadBufferUsage", 0);
    __publicField(this, "numQuadsRendered", 0);
    /**
     * Whether the renderer is currently rendering to a texture.
     */
    __publicField(this, "renderToTextureActive", false);
    this.quadBuffer = new ArrayBuffer(this.stage.options.quadBufferSize);
    this.fQuadBuffer = new Float32Array(this.quadBuffer);
    this.uiQuadBuffer = new Uint32Array(this.quadBuffer);
    this.mode = "webgl";
    const { canvas, clearColor, bufferMemory: bufferMemory2 } = options;
    const gl = createWebGLContext(canvas, options.forceWebGL2, options.contextSpy);
    const glw = this.glw = new WebGlContextWrapper(gl);
    glw.viewport(0, 0, canvas.width, canvas.height);
    this.updateClearColor(clearColor);
    glw.setBlend(true);
    glw.blendFunc(glw.ONE, glw.ONE_MINUS_SRC_ALPHA);
    createIndexBuffer(glw, bufferMemory2);
    this.system = {
      parameters: getWebGlParameters(this.glw),
      extensions: getWebGlExtensions(this.glw)
    };
    this.shManager.renderer = this;
    this.defShaderCtrl = this.shManager.loadShader("DefaultShader");
    this.defaultShader = this.defShaderCtrl.shader;
    const quadBuffer = glw.createBuffer();
    assertTruthy(quadBuffer);
    const stride = 8 * Float32Array.BYTES_PER_ELEMENT;
    this.quadBufferCollection = new BufferCollection([
      {
        buffer: quadBuffer,
        attributes: {
          a_position: {
            name: "a_position",
            size: 2,
            // 2 components per iteration
            type: glw.FLOAT,
            // the data is 32bit floats
            normalized: false,
            // don't normalize the data
            stride,
            // 0 = move forward size * sizeof(type) each iteration to get the next position
            offset: 0
            // start at the beginning of the buffer
          },
          a_textureCoordinate: {
            name: "a_textureCoordinate",
            size: 2,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 2 * Float32Array.BYTES_PER_ELEMENT
          },
          a_color: {
            name: "a_color",
            size: 4,
            type: glw.UNSIGNED_BYTE,
            normalized: true,
            stride,
            offset: 4 * Float32Array.BYTES_PER_ELEMENT
          },
          a_textureIndex: {
            name: "a_textureIndex",
            size: 1,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 5 * Float32Array.BYTES_PER_ELEMENT
          },
          a_nodeCoordinate: {
            name: "a_nodeCoordinate",
            size: 2,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 6 * Float32Array.BYTES_PER_ELEMENT
          }
        }
      }
    ]);
  }
  reset() {
    const { glw } = this;
    this.curBufferIdx = 0;
    this.curRenderOp = null;
    this.renderOps.length = 0;
    glw.setScissorTest(false);
    glw.clear();
  }
  getShaderManager() {
    return this.shManager;
  }
  createCtxTexture(textureSource) {
    if (textureSource instanceof SubTexture) {
      return new WebGlCoreCtxSubTexture(this.glw, this.txMemManager, textureSource);
    } else if (textureSource instanceof RenderTexture) {
      return new WebGlCoreCtxRenderTexture(this.glw, this.txMemManager, textureSource);
    }
    return new WebGlCoreCtxTexture(this.glw, this.txMemManager, textureSource);
  }
  /**
   * This function adds a quad (a rectangle composed of two triangles) to the WebGL rendering pipeline.
   *
   * It takes a set of options that define the quad's properties, such as its dimensions, colors, texture, shader, and transformation matrix.
   * The function first updates the shader properties with the current dimensions if necessary, then sets the default texture if none is provided.
   * It then checks if a new render operation is needed, based on the current shader and clipping rectangle.
   * If a new render operation is needed, it creates one and updates the current render operation.
   * The function then adjusts the texture coordinates based on the texture options and adds the texture to the texture manager.
   *
   * Finally, it calculates the vertices for the quad, taking into account any transformations, and adds them to the quad buffer.
   * The function updates the length and number of quads in the current render operation, and updates the current buffer index.
   */
  addQuad(params) {
    var _a2;
    const { fQuadBuffer, uiQuadBuffer } = this;
    let texture = params.texture;
    assertTruthy(texture !== null, "Texture is required");
    if (params.shader !== this.defaultShader) {
      if (hasOwn(params.shaderProps, "$dimensions") == true) {
        const dimensions = params.shaderProps.$dimensions;
        dimensions.width = params.width;
        dimensions.height = params.height;
      }
      if (hasOwn(params.shaderProps, "$alpha") === true) {
        params.shaderProps.$alpha = params.alpha;
      }
    }
    let { curBufferIdx: bufferIdx, curRenderOp } = this;
    const targetDims = { width: params.width, height: params.height };
    if (this.reuseRenderOp(params) === false) {
      this.newRenderOp(params.shader, params.shaderProps, params.alpha, targetDims, params.clippingRect, bufferIdx, params.rtt, params.parentHasRenderTexture, params.framebufferDimensions);
      curRenderOp = this.curRenderOp;
      assertTruthy(curRenderOp);
    }
    let ctxTexture = void 0;
    let texCoordX1 = 0;
    let texCoordY1 = 0;
    let texCoordX2 = 1;
    let texCoordY2 = 1;
    if (texture.type === TextureType.subTexture) {
      const { x: tx, y: ty, width: tw, height: th } = texture.props;
      const { width: parentW = 0, height: parentH = 0 } = texture.parentTexture.dimensions || { width: 0, height: 0 };
      texCoordX1 = tx / parentW;
      texCoordX2 = texCoordX1 + tw / parentW;
      texCoordY1 = ty / parentH;
      texCoordY2 = texCoordY1 + th / parentH;
      texture = texture.parentTexture;
      ctxTexture = texture.ctxTexture;
    } else {
      ctxTexture = texture.ctxTexture;
      if (ctxTexture === void 0) {
        ctxTexture = (_a2 = this.stage.defaultTexture) == null ? void 0 : _a2.ctxTexture;
        console.warn("WebGL Renderer: Texture does not have a ctxTexture, using default texture instead");
      }
      texCoordX1 = ctxTexture.txCoordX1;
      texCoordY1 = ctxTexture.txCoordY1;
      texCoordX2 = ctxTexture.txCoordX2;
      texCoordY2 = ctxTexture.txCoordY2;
    }
    if (texture.type === TextureType.image && params.textureOptions !== null && params.textureOptions.resizeMode !== void 0 && texture.dimensions !== null) {
      const resizeMode = params.textureOptions.resizeMode;
      const { width: tw, height: th } = texture.dimensions;
      if (resizeMode.type === "cover") {
        const scaleX = params.width / tw;
        const scaleY = params.height / th;
        const scale = Math.max(scaleX, scaleY);
        const precision = 1 / scale;
        if (scale && scaleX && scaleX < scale) {
          const desiredSize = precision * params.width;
          texCoordX1 = (1 - desiredSize / tw) * (resizeMode.clipX ?? 0.5);
          texCoordX2 = texCoordX1 + desiredSize / tw;
        }
        if (scale && scaleY && scaleY < scale) {
          const desiredSize = precision * params.height;
          texCoordY1 = (1 - desiredSize / th) * (resizeMode.clipY ?? 0.5);
          texCoordY2 = texCoordY1 + desiredSize / th;
        }
      }
    }
    let flipY = 0;
    if (params.textureOptions !== null) {
      if (params.textureOptions.flipX === true) {
        [texCoordX1, texCoordX2] = [texCoordX2, texCoordX1];
      }
      flipY = +(params.textureOptions.flipY || false);
    }
    if (flipY ^ +(texture.type === TextureType.renderToTexture)) {
      [texCoordY1, texCoordY2] = [texCoordY2, texCoordY1];
    }
    const textureIdx = this.addTexture(ctxTexture, bufferIdx);
    assertTruthy(this.curRenderOp !== null);
    if (params.renderCoords) {
      fQuadBuffer[bufferIdx++] = params.renderCoords.x1;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y1;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x2;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y2;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x4;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y4;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x3;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y3;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 1;
    } else if (params.tb !== 0 || params.tc !== 0) {
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta;
      fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = params.tx + params.height * params.tb;
      fQuadBuffer[bufferIdx++] = params.ty + params.height * params.td;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta + params.height * params.tb;
      fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc + params.height * params.td;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 1;
    } else {
      const rightCornerX = params.tx + params.width * params.ta;
      const rightCornerY = params.ty + params.height * params.td;
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = rightCornerX;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = rightCornerY;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 0;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = rightCornerX;
      fQuadBuffer[bufferIdx++] = rightCornerY;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = 1;
      fQuadBuffer[bufferIdx++] = 1;
    }
    this.curRenderOp.numQuads++;
    this.curBufferIdx = bufferIdx;
  }
  /**
   * Replace the existing RenderOp with a new one that uses the specified Shader
   * and starts at the specified buffer index.
   *
   * @param shader
   * @param bufferIdx
   */
  newRenderOp(shader, shaderProps, alpha, dimensions, clippingRect, bufferIdx, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
    const curRenderOp = new WebGlCoreRenderOp(
      this.glw,
      this.options,
      this.quadBufferCollection,
      shader,
      shaderProps,
      alpha,
      clippingRect,
      dimensions,
      bufferIdx,
      0,
      // Z-Index is only used for explictly added Render Ops
      renderToTexture,
      parentHasRenderTexture,
      framebufferDimensions
    );
    this.curRenderOp = curRenderOp;
    this.renderOps.push(curRenderOp);
  }
  /**
   * Add a texture to the current RenderOp. If the texture cannot be added to the
   * current RenderOp, a new RenderOp will be created and the texture will be added
   * to that one.
   *
   * If the texture cannot be added to the new RenderOp, an error will be thrown.
   *
   * @param texture
   * @param bufferIdx
   * @param recursive
   * @returns Assigned Texture Index of the texture in the render op
   */
  addTexture(texture, bufferIdx, recursive) {
    const { curRenderOp } = this;
    assertTruthy(curRenderOp);
    const textureIdx = curRenderOp.addTexture(texture);
    if (textureIdx === 4294967295) {
      if (recursive) {
        throw new Error("Unable to add texture to render op");
      }
      this.newRenderOp(curRenderOp.shader, curRenderOp.shaderProps, curRenderOp.alpha, curRenderOp.dimensions, curRenderOp.clippingRect, bufferIdx);
      return this.addTexture(texture, bufferIdx, true);
    }
    return textureIdx;
  }
  /**
   * Test if the current Render operation can be reused for the specified parameters.
   * @param params
   * @returns
   */
  reuseRenderOp(params) {
    var _a2;
    const { shader, shaderProps, parentHasRenderTexture, rtt, clippingRect } = params;
    if (((_a2 = this.curRenderOp) == null ? void 0 : _a2.shader) !== shader) {
      return false;
    }
    if (compareRect(this.curRenderOp.clippingRect, clippingRect) === false) {
      return false;
    }
    if (parentHasRenderTexture === true || rtt === true) {
      return false;
    }
    if (this.curRenderOp.shader !== this.defaultShader && this.curRenderOp.shader.canBatchShaderProps(this.curRenderOp.shaderProps, shaderProps) === false) {
      return false;
    }
    return true;
  }
  /**
   * add RenderOp to the render pipeline
   */
  addRenderOp(renderable) {
    this.renderOps.push(renderable);
    this.curRenderOp = null;
  }
  /**
   * Render the current set of RenderOps to render to the specified surface.
   *
   * TODO: 'screen' is the only supported surface at the moment.
   *
   * @param surface
   */
  render(surface = "screen") {
    const { glw, quadBuffer } = this;
    const arr = new Float32Array(quadBuffer, 0, this.curBufferIdx);
    const buffer = this.quadBufferCollection.getBuffer("a_position") || null;
    glw.arrayBufferData(buffer, arr, glw.STATIC_DRAW);
    for (let i = 0, length = this.renderOps.length; i < length; i++) {
      this.renderOps[i].draw();
    }
    this.quadBufferUsage = this.curBufferIdx * arr.BYTES_PER_ELEMENT;
    const QUAD_SIZE_IN_BYTES = 4 * (8 * arr.BYTES_PER_ELEMENT);
    this.numQuadsRendered = this.quadBufferUsage / QUAD_SIZE_IN_BYTES;
  }
  getQuadCount() {
    return this.numQuadsRendered;
  }
  renderToTexture(node) {
    for (let i = 0; i < this.rttNodes.length; i++) {
      if (this.rttNodes[i] === node) {
        return;
      }
    }
    this.insertRTTNodeInOrder(node);
  }
  /**
   * Inserts an RTT node into `this.rttNodes` while maintaining the correct rendering order based on hierarchy.
   *
   * Rendering order for RTT nodes is critical when nested RTT nodes exist in a parent-child relationship.
   * Specifically:
   *  - Child RTT nodes must be rendered before their RTT-enabled parents to ensure proper texture composition.
   *  - If an RTT node is added and it has existing RTT children, it should be rendered after those children.
   *
   * This function addresses both cases by:
   * 1. **Checking Upwards**: It traverses the node's hierarchy upwards to identify any RTT parent
   *    already in `rttNodes`. If an RTT parent is found, the new node is placed before this parent.
   * 2. **Checking Downwards**: It traverses the node’s children recursively to find any RTT-enabled
   *    children that are already in `rttNodes`. If such children are found, the new node is inserted
   *    after the last (highest index) RTT child node.
   *
   * The final calculated insertion index ensures the new node is positioned in `rttNodes` to respect
   * both parent-before-child and child-before-parent rendering rules, preserving the correct order
   * for the WebGL renderer.
   *
   * @param node - The RTT-enabled CoreNode to be added to `rttNodes` in the appropriate hierarchical position.
   */
  insertRTTNodeInOrder(node) {
    let insertIndex = this.rttNodes.length;
    let currentNode = node;
    while (currentNode) {
      if (!currentNode.parent) {
        break;
      }
      const parentIndex = this.rttNodes.indexOf(currentNode.parent);
      if (parentIndex !== -1) {
        insertIndex = parentIndex;
        break;
      }
      currentNode = currentNode.parent;
    }
    const maxChildIndex = this.findMaxChildRTTIndex(node);
    if (maxChildIndex !== -1) {
      insertIndex = Math.max(insertIndex, maxChildIndex + 1);
    }
    this.rttNodes.splice(insertIndex, 0, node);
  }
  // Helper function to find the highest index of any RTT children of a node within rttNodes
  findMaxChildRTTIndex(node) {
    let maxIndex = -1;
    const traverseChildren = (currentNode) => {
      const currentIndex = this.rttNodes.indexOf(currentNode);
      if (currentIndex !== -1) {
        maxIndex = Math.max(maxIndex, currentIndex);
      }
      for (const child of currentNode.children) {
        traverseChildren(child);
      }
    };
    traverseChildren(node);
    return maxIndex;
  }
  renderRTTNodes() {
    const { glw } = this;
    const { txManager } = this.stage;
    for (let i = 0; i < this.rttNodes.length; i++) {
      const node = this.rttNodes[i];
      if (node === void 0 || node.hasRTTupdates === false) {
        continue;
      }
      if (node.worldAlpha === 0 || node.strictBounds === true && node.renderState === CoreNodeRenderState.OutOfBounds) {
        continue;
      }
      if (node.texture === null || node.texture.state !== "loaded") {
        continue;
      }
      this.activeRttNode = node;
      assertTruthy(node.texture, "RTT node missing texture");
      const ctxTexture = node.texture.ctxTexture;
      assertTruthy(ctxTexture instanceof WebGlCoreCtxRenderTexture);
      this.renderToTextureActive = true;
      glw.bindFramebuffer(ctxTexture.framebuffer);
      glw.viewport(0, 0, ctxTexture.w, ctxTexture.h);
      glw.clearColor(0, 0, 0, 0);
      glw.clear();
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        if (child === void 0) {
          continue;
        }
        this.stage.addQuads(child);
        child.hasRTTupdates = false;
      }
      this.render();
      this.renderOps.length = 0;
      node.hasRTTupdates = false;
    }
    const clearColor = this.clearColor.normalized;
    glw.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    glw.bindFramebuffer(null);
    glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
    this.renderToTextureActive = false;
  }
  removeRTTNode(node) {
    const index = this.rttNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this.rttNodes.splice(index, 1);
  }
  getBufferInfo() {
    const bufferInfo = {
      totalAvailable: this.stage.options.quadBufferSize,
      totalUsed: this.quadBufferUsage
    };
    return bufferInfo;
  }
  getDefShaderCtr() {
    return this.defShaderCtrl;
  }
  /**
   * Updates the WebGL context's clear color and clears the color buffer.
   *
   * @param color - The color to set as the clear color, represented as a 32-bit integer.
   */
  updateClearColor(color) {
    if (this.clearColor.raw === color) {
      return;
    }
    const glw = this.glw;
    const normalizedColor = getNormalizedRgbaComponents(color);
    glw.clearColor(normalizedColor[0], normalizedColor[1], normalizedColor[2], normalizedColor[3]);
    this.clearColor = {
      raw: color,
      normalized: normalizedColor
    };
    glw.clear();
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/SpecialCodepoints.js
var SpecialCodepoints = {
  LINE_FEED: 10,
  CARRIAGE_RETURN: 13,
  SPACE: 32,
  TAB: 9,
  ZERO_WIDTH_SPACE: 8203,
  ZERO_WIDTH_NON_JOINER: 8204,
  ZERO_WIDTH_JOINER: 8205,
  LEFT_TO_RIGHT_MARK: 8206,
  RIGHT_TO_LEFT_MARK: 8207,
  LEFT_TO_RIGHT_EMBEDDING: 8234,
  RIGHT_TO_LEFT_EMBEDDING: 8235,
  POP_DIRECTIONAL_FORMATTING: 8236,
  LEFT_TO_RIGHT_OVERRIDE: 8237,
  RIGHT_TO_LEFT_OVERRIDE: 8238,
  LINE_SEPARATOR: 8232,
  PARAGRAPH_SEPARATOR: 8233,
  OBJECT_REPLACEMENT_CHARACTER: 65532,
  REPLACEMENT_CHARACTER: 65533,
  ZERO_WIDTH_NO_BREAK_SPACE: 65279,
  LEFT_TO_RIGHT_ISOLATE: 8294,
  RIGHT_TO_LEFT_ISOLATE: 8295,
  FIRST_STRONG_ISOLATE: 8296,
  POP_DIRECTIONAL_ISOLATE: 8297,
  INHIBIT_SYMMETRIC_SWAPPING: 8298,
  ACTIVATE_SYMMETRIC_SWAPPING: 8299,
  INHIBIT_ARABIC_FORM_SHAPING: 8300,
  ACTIVATE_ARABIC_FORM_SHAPING: 8301,
  NATIONAL_DIGIT_SHAPES: 8302,
  NOMINAL_DIGIT_SHAPES: 8303,
  LEFT_TO_RIGHT_BOUNDARY: 8206,
  RIGHT_TO_LEFT_BOUNDARY: 8207
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/internal/FontShaper.js
var FontShaper = class {
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/internal/SdfFontShaper.js
var SdfFontShaper = class extends FontShaper {
  constructor(data, glyphMap) {
    super();
    __publicField(this, "data");
    __publicField(this, "glyphMap");
    __publicField(this, "kernings");
    this.data = data;
    this.glyphMap = glyphMap;
    const kernings = this.kernings = {};
    data.kernings.forEach((kerning) => {
      const second = kerning.second;
      const firsts = kernings[second] = kernings[second] || {};
      firsts[kerning.first] = kerning.amount;
    });
    this.kernings = kernings;
  }
  *shapeText(props, codepoints) {
    var _a2;
    let codepointResult;
    let lastGlyphId = void 0;
    while ((codepointResult = codepoints.peek()) && !codepointResult.done) {
      const codepoint = codepointResult.value;
      const glyph = this.glyphMap.get(codepoint);
      codepoints.next();
      if (glyph !== void 0) {
        const kerning = lastGlyphId !== void 0 ? (((_a2 = this.kernings[glyph.id]) == null ? void 0 : _a2[lastGlyphId]) || 0) + props.letterSpacing : 0;
        lastGlyphId = glyph.id;
        yield {
          mapped: true,
          glyphId: glyph.id,
          codepoint,
          cluster: codepoints.lastIndex,
          xAdvance: glyph.xadvance + kerning,
          yAdvance: 0,
          xOffset: glyph.xoffset + kerning,
          yOffset: glyph.yoffset,
          xBearing: 0,
          yBearing: 0,
          width: glyph.width,
          height: glyph.height
        };
      } else {
        if (codepoint === SpecialCodepoints.LINE_FEED) {
          lastGlyphId = void 0;
        }
        yield {
          mapped: false,
          codepoint,
          cluster: codepoints.lastIndex
        };
      }
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/SdfTrFontFace.js
var SdfTrFontFace = class extends TrFontFace {
  constructor(type, options) {
    super(options);
    __publicField(this, "type");
    __publicField(this, "texture");
    /**
     * Height of the tallest character in the font including the whitespace above it
     * in SDF/vertex units.
     */
    __publicField(this, "maxCharHeight", 0);
    __publicField(this, "shaper");
    __publicField(this, "glyphMap", /* @__PURE__ */ new Map());
    __publicField(this, "data");
    const { atlasUrl, atlasDataUrl, stage: stage2 } = options;
    this.type = type;
    const renderer3 = stage2.renderer;
    assertTruthy(renderer3 instanceof WebGlCoreRenderer, "SDF Font Faces can only be used with the WebGL Renderer");
    this.texture = stage2.txManager.createTexture("ImageTexture", {
      src: atlasUrl,
      // IMPORTANT: The SDF shader requires the alpha channel to NOT be
      // premultiplied on the atlas texture. If it is premultiplied, the
      // rendering of SDF glyphs (especially single-channel SDF fonts) will
      // be very jagged.
      premultiplyAlpha: false
    });
    stage2.txManager.loadTexture(this.texture, true);
    this.texture.preventCleanup = true;
    this.texture.on("loaded", () => {
      this.checkLoaded();
      stage2.requestRender();
    });
    fetchJson(atlasDataUrl).then((response) => {
      var _a2;
      this.data = JSON.parse(response);
      assertTruthy(this.data);
      let maxCharHeight = 0;
      this.data.chars.forEach((glyph) => {
        this.glyphMap.set(glyph.id, glyph);
        const charHeight = glyph.yoffset + glyph.height;
        if (charHeight > maxCharHeight) {
          maxCharHeight = charHeight;
        }
      });
      this.maxCharHeight = maxCharHeight;
      this.shaper = new SdfFontShaper(this.data, this.glyphMap);
      if (!this.metrics) {
        if ((_a2 = this.data) == null ? void 0 : _a2.lightningMetrics) {
          const { ascender, descender, lineGap, unitsPerEm } = this.data.lightningMetrics;
          this.metrics = {
            ascender: ascender / unitsPerEm,
            descender: descender / unitsPerEm,
            lineGap: lineGap / unitsPerEm
          };
        } else {
          throw new Error(`Font metrics not found in ${this.type} font ${this.fontFamily}. Make sure you are using the latest version of the Lightning 3 \`msdf-generator\` tool to generate your SDF fonts.`);
        }
      }
      this.checkLoaded();
    }).catch(console.error);
  }
  getAtlasEntry(glyphId) {
    const glyph = this.glyphMap.get(glyphId);
    if (glyph === void 0) {
      throw new Error(`Glyph ${glyphId} not found in font ${this.fontFamily}`);
    }
    return {
      x: glyph.x,
      y: glyph.y,
      width: glyph.width,
      height: glyph.height
    };
  }
  checkLoaded() {
    if (this.loaded)
      return;
    if (this.texture.state === "loaded" && this.data) {
      this.loaded = true;
      this.emit("loaded");
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/constants.js
var FLOATS_PER_GLYPH = 24;

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/getStartConditions.js
function getStartConditions(sdfFontSize, sdfLineHeight, fontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH) {
  const startLineIndex = Math.min(Math.max(renderWindow.firstLineIdx, 0), lineCache.length);
  const sdfStartX = 0;
  const { metrics } = fontFace;
  assertTruthy(metrics, "Font metrics not loaded");
  assertTruthy(fontFace.data, "Font data not loaded");
  const sdfBareLineHeight = (metrics.ascender - metrics.descender) * sdfFontSize;
  let sdfVerticalAlignYOffset = 0;
  if (verticalAlign === "middle") {
    sdfVerticalAlignYOffset = (sdfLineHeight - sdfBareLineHeight) / 2;
  } else if (verticalAlign === "bottom") {
    sdfVerticalAlignYOffset = sdfLineHeight - sdfBareLineHeight;
  }
  const sdfOffsetY = offsetY / fontSizeRatio;
  const sdfEncodedAscender = fontFace.data.common.base;
  const sdfConfiguredAscender = metrics.ascender * sdfFontSize;
  const sdfAscenderAdjOffset = sdfConfiguredAscender - sdfEncodedAscender;
  const sdfStartY = sdfOffsetY + sdfAscenderAdjOffset + startLineIndex * sdfLineHeight + sdfVerticalAlignYOffset;
  if (textH && sdfStartY >= textH / fontSizeRatio) {
    return;
  }
  return {
    sdfX: sdfStartX,
    sdfY: sdfStartY,
    lineIndex: startLineIndex
  };
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/PeekableGenerator.js
var PeekableIterator = class {
  constructor(iterator, indexBase = 0) {
    __publicField(this, "iterator");
    __publicField(this, "peekBuffer", []);
    __publicField(this, "_lastIndex");
    this.iterator = iterator;
    this.iterator = iterator;
    this._lastIndex = indexBase - 1;
    this.peekBuffer = [];
  }
  next() {
    const nextResult = this.peekBuffer.length > 0 ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.peekBuffer.pop()
    ) : this.iterator.next();
    if (nextResult.done) {
      this._lastIndex = -1;
    } else {
      this._lastIndex++;
    }
    return nextResult;
  }
  peek() {
    if (this.peekBuffer.length > 0) {
      return this.peekBuffer[0];
    }
    const result = this.iterator.next();
    this.peekBuffer.push(result);
    return result;
  }
  get lastIndex() {
    return this._lastIndex;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/getUnicodeCodepoints.js
function* getUnicodeCodepoints(text, start = 0) {
  let i = start;
  while (i < text.length) {
    const codePoint = text.codePointAt(i);
    if (codePoint === void 0) {
      throw new Error("Invalid Unicode code point");
    }
    yield codePoint;
    i += codePoint <= 65535 ? 1 : 2;
  }
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/measureText.js
function measureText(text, shaperProps, shaper) {
  const glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, 0), 0));
  let width = 0;
  for (const glyph of glyphs) {
    if (glyph.mapped && glyph.codepoint !== 8203) {
      width += glyph.xAdvance;
    }
  }
  return width;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/layoutText.js
function layoutText(curLineIndex, startX, startY, text, textAlign, width, height, fontSize, lineHeight, letterSpacing, vertexBuffer, contain, lineCache, rwSdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines) {
  assertTruthy(trFontFace, "Font face must be loaded");
  assertTruthy(trFontFace.loaded, "Font face must be loaded");
  assertTruthy(trFontFace.data, "Font face must be loaded");
  assertTruthy(trFontFace.shaper, "Font face must be loaded");
  const fontSizeRatio = fontSize / trFontFace.data.info.size;
  const vertexLineHeight = lineHeight / fontSizeRatio;
  const vertexW = width / fontSizeRatio;
  const vertexLSpacing = letterSpacing / fontSizeRatio;
  const startingLineCacheEntry = lineCache[curLineIndex];
  const startingCodepointIndex = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.codepointIndex) || 0;
  const startingMaxX = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.maxX) || 0;
  const startingMaxY = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.maxY) || 0;
  let maxX = startingMaxX;
  let maxY = startingMaxY;
  let curX = startX;
  let curY = startY;
  let bufferOffset = 0;
  const lastWord = {
    codepointIndex: -1,
    bufferOffset: -1,
    xStart: -1
  };
  const shaper = trFontFace.shaper;
  const shaperProps = {
    letterSpacing: vertexLSpacing
  };
  if (text.endsWith(" ")) {
    text += " ";
  }
  let glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, startingCodepointIndex), startingCodepointIndex));
  let glyphResult;
  let curLineBufferStart = -1;
  const bufferLineInfos = [];
  const vertexTruncateHeight = height / fontSizeRatio;
  const overflowSuffVertexWidth = measureText(overflowSuffix, shaperProps, shaper);
  let moreLines = true;
  while (moreLines) {
    const nextLineWillFit = (maxLines === 0 || curLineIndex + 1 < maxLines) && (contain !== "both" || scrollable || curY + vertexLineHeight + trFontFace.maxCharHeight <= vertexTruncateHeight);
    const lineVertexW = nextLineWillFit ? vertexW : vertexW - overflowSuffVertexWidth;
    let xStartLastWordBoundary = 0;
    const lineIsBelowWindowTop = curY + trFontFace.maxCharHeight >= rwSdf.y1;
    const lineIsAboveWindowBottom = curY <= rwSdf.y2;
    const lineIsWithinWindow = lineIsBelowWindowTop && lineIsAboveWindowBottom;
    while ((glyphResult = glyphs.next()) && !glyphResult.done) {
      const glyph = glyphResult.value;
      if (curLineIndex === lineCache.length) {
        lineCache.push({
          codepointIndex: glyph.cluster,
          maxY,
          maxX
        });
      } else if (curLineIndex > lineCache.length) {
        throw new Error("Unexpected lineCache length");
      }
      if (glyph.codepoint === 32 || glyph.codepoint === 10 || glyph.codepoint === 8203) {
        if (lastWord.codepointIndex !== -1) {
          lastWord.codepointIndex = -1;
          xStartLastWordBoundary = curX;
        }
      } else if (lastWord.codepointIndex === -1) {
        lastWord.codepointIndex = glyph.cluster;
        lastWord.bufferOffset = bufferOffset;
        lastWord.xStart = xStartLastWordBoundary;
      }
      if (glyph.mapped) {
        const charEndX = curX + glyph.xOffset + glyph.width;
        if (
          // We are containing the text
          contain !== "none" && // The current glyph reaches outside the contained width
          charEndX >= lineVertexW && // There is a last word that we can break to the next line
          lastWord.codepointIndex !== -1 && // Prevents infinite loop when a single word is longer than the width
          lastWord.xStart > 0
        ) {
          if (nextLineWillFit) {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, lastWord.codepointIndex), lastWord.codepointIndex));
            bufferOffset = lastWord.bufferOffset;
            break;
          } else {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
            curX = lastWord.xStart;
            bufferOffset = lastWord.bufferOffset;
            contain = "none";
          }
        } else {
          const quadX = curX + glyph.xOffset;
          const quadY = curY + glyph.yOffset;
          if (lineIsWithinWindow) {
            if (curLineBufferStart === -1) {
              curLineBufferStart = bufferOffset;
            }
            const atlasEntry = trFontFace.getAtlasEntry(glyph.glyphId);
            const u = atlasEntry.x / trFontFace.data.common.scaleW;
            const v = atlasEntry.y / trFontFace.data.common.scaleH;
            const uvWidth = atlasEntry.width / trFontFace.data.common.scaleW;
            const uvHeight = atlasEntry.height / trFontFace.data.common.scaleH;
            vertexBuffer[bufferOffset++] = quadX;
            vertexBuffer[bufferOffset++] = quadY;
            vertexBuffer[bufferOffset++] = u;
            vertexBuffer[bufferOffset++] = v;
            vertexBuffer[bufferOffset++] = quadX + glyph.width;
            vertexBuffer[bufferOffset++] = quadY;
            vertexBuffer[bufferOffset++] = u + uvWidth;
            vertexBuffer[bufferOffset++] = v;
            vertexBuffer[bufferOffset++] = quadX;
            vertexBuffer[bufferOffset++] = quadY + glyph.height;
            vertexBuffer[bufferOffset++] = u;
            vertexBuffer[bufferOffset++] = v + uvHeight;
            vertexBuffer[bufferOffset++] = quadX + glyph.width;
            vertexBuffer[bufferOffset++] = quadY + glyph.height;
            vertexBuffer[bufferOffset++] = u + uvWidth;
            vertexBuffer[bufferOffset++] = v + uvHeight;
          }
          maxY = Math.max(maxY, quadY + glyph.height);
          maxX = Math.max(maxX, quadX + glyph.width);
          curX += glyph.xAdvance;
        }
      } else {
        if (glyph.codepoint === 10) {
          if (nextLineWillFit) {
            break;
          } else {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
            contain = "none";
          }
        }
      }
    }
    if (curLineBufferStart !== -1) {
      bufferLineInfos.push({
        bufferStart: curLineBufferStart,
        bufferEnd: bufferOffset
      });
      curLineBufferStart = -1;
    }
    curX = 0;
    curY += vertexLineHeight;
    curLineIndex++;
    lastWord.codepointIndex = -1;
    xStartLastWordBoundary = 0;
    if (!forceFullLayoutCalc && contain === "both" && curY > rwSdf.y2) {
      moreLines = false;
    } else if (glyphResult && glyphResult.done) {
      moreLines = false;
    } else if (!nextLineWillFit) {
      moreLines = false;
    }
  }
  if (textAlign === "center") {
    const vertexTextW = contain === "none" ? maxX : vertexW;
    for (let i = 0; i < bufferLineInfos.length; i++) {
      const line = bufferLineInfos[i];
      const lineWidth = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart]
      );
      const xOffset = (vertexTextW - lineWidth) / 2;
      for (let j = line.bufferStart; j < line.bufferEnd; j += 4) {
        vertexBuffer[j] += xOffset;
      }
    }
  } else if (textAlign === "right") {
    const vertexTextW = contain === "none" ? maxX : vertexW;
    for (let i = 0; i < bufferLineInfos.length; i++) {
      const line = bufferLineInfos[i];
      const lineWidth = line.bufferEnd === line.bufferStart ? 0 : (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart]
      );
      const xOffset = vertexTextW - lineWidth;
      for (let j = line.bufferStart; j < line.bufferEnd; j += 4) {
        vertexBuffer[j] += xOffset;
      }
    }
  }
  assertTruthy(glyphResult);
  return {
    bufferNumFloats: bufferOffset,
    bufferNumQuads: bufferOffset / 16,
    layoutNumCharacters: glyphResult.done ? text.length - startingCodepointIndex : glyphResult.value.cluster - startingCodepointIndex + 1,
    fullyProcessed: !!glyphResult.done,
    maxX,
    maxY,
    numLines: lineCache.length
  };
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/util.js
function roundUpToMultiple(value, multiple) {
  return Math.ceil(value / multiple) * multiple;
}
function roundDownToMultiple(value, multiple) {
  return Math.floor(value / multiple) * multiple;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/setRenderWindow.js
function setRenderWindow(outRenderWindow, x, y, scrollY, lineHeight, bufferMargin, visibleWindow, fontSizeRatio) {
  const { screen, sdf } = outRenderWindow;
  if (!isBoundPositive(visibleWindow)) {
    screen.x1 = 0;
    screen.y1 = 0;
    screen.x2 = 0;
    screen.y2 = 0;
    sdf.x1 = 0;
    sdf.y1 = 0;
    sdf.x2 = 0;
    sdf.y2 = 0;
    outRenderWindow.numLines = 0;
    outRenderWindow.firstLineIdx = 0;
  } else {
    const x1 = visibleWindow.x1 - x;
    const x2 = x1 + (visibleWindow.x2 - visibleWindow.x1);
    const y1Base = visibleWindow.y1 - y + scrollY;
    const y1 = roundDownToMultiple(y1Base - bufferMargin, lineHeight || 1);
    const y2 = roundUpToMultiple(y1Base + (visibleWindow.y2 - visibleWindow.y1) + bufferMargin, lineHeight || 1);
    screen.x1 = x1;
    screen.y1 = y1;
    screen.x2 = x2;
    screen.y2 = y2;
    sdf.x1 = x1 / fontSizeRatio;
    sdf.y1 = y1 / fontSizeRatio;
    sdf.x2 = x2 / fontSizeRatio;
    sdf.y2 = y2 / fontSizeRatio;
    outRenderWindow.numLines = Math.ceil((y2 - y1) / lineHeight);
    outRenderWindow.firstLineIdx = lineHeight ? Math.floor(y1 / lineHeight) : 0;
  }
  outRenderWindow.valid = true;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TextRenderingUtils.js
function calcDefaultLineHeight(metrics, fontSize) {
  return fontSize * (metrics.ascender - metrics.descender + metrics.lineGap);
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/SdfTextRenderer.js
var tmpRect = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
var SdfTextRenderer = class extends TextRenderer {
  constructor(stage2) {
    super(stage2);
    /**
     * Map of font family names to a set of font faces.
     */
    __publicField(this, "ssdfFontFamilies", {});
    __publicField(this, "msdfFontFamilies", {});
    __publicField(this, "fontFamilyArray", [
      this.ssdfFontFamilies,
      this.msdfFontFamilies
    ]);
    __publicField(this, "sdfShader");
    __publicField(this, "rendererBounds");
    __publicField(this, "type", "sdf");
    this.sdfShader = this.stage.shManager.loadShader("SdfShader", {
      transform: new Float32Array(),
      color: 0,
      size: 0,
      scrollY: 0,
      distanceRange: 0,
      debug: false
    }).shader;
    this.rendererBounds = {
      x1: 0,
      y1: 0,
      x2: this.stage.options.appWidth,
      y2: this.stage.options.appHeight
    };
  }
  //#region Overrides
  getPropertySetters() {
    return {
      fontFamily: (state2, value) => {
        state2.props.fontFamily = value;
        this.releaseFontFace(state2);
        this.invalidateLayoutCache(state2);
      },
      fontWeight: (state2, value) => {
        state2.props.fontWeight = value;
        this.releaseFontFace(state2);
        this.invalidateLayoutCache(state2);
      },
      fontStyle: (state2, value) => {
        state2.props.fontStyle = value;
        this.releaseFontFace(state2);
        this.invalidateLayoutCache(state2);
      },
      fontStretch: (state2, value) => {
        state2.props.fontStretch = value;
        this.releaseFontFace(state2);
        this.invalidateLayoutCache(state2);
      },
      fontSize: (state2, value) => {
        state2.props.fontSize = value;
        this.invalidateLayoutCache(state2);
      },
      text: (state2, value) => {
        state2.props.text = value;
        this.invalidateLayoutCache(state2);
      },
      textAlign: (state2, value) => {
        state2.props.textAlign = value;
        this.invalidateLayoutCache(state2);
      },
      color: (state2, value) => {
        state2.props.color = value;
      },
      x: (state2, value) => {
        state2.props.x = value;
        if (state2.elementBounds.valid) {
          this.setElementBoundsX(state2);
          if (!state2.renderWindow.valid && boundsOverlap(state2.elementBounds, this.rendererBounds)) {
            this.scheduleUpdateState(state2);
          }
        }
      },
      y: (state2, value) => {
        state2.props.y = value;
        if (state2.elementBounds.valid) {
          this.setElementBoundsY(state2);
          if (!state2.renderWindow.valid && boundsOverlap(state2.elementBounds, this.rendererBounds)) {
            this.scheduleUpdateState(state2);
          }
        }
      },
      contain: (state2, value) => {
        state2.props.contain = value;
        this.invalidateLayoutCache(state2);
      },
      width: (state2, value) => {
        state2.props.width = value;
        if (state2.props.contain !== "none") {
          this.invalidateLayoutCache(state2);
        }
      },
      height: (state2, value) => {
        state2.props.height = value;
        if (state2.props.contain === "both") {
          this.invalidateLayoutCache(state2);
        }
      },
      offsetY: (state2, value) => {
        state2.props.offsetY = value;
        this.invalidateLayoutCache(state2);
      },
      scrollable: (state2, value) => {
        state2.props.scrollable = value;
        this.invalidateLayoutCache(state2);
      },
      scrollY: (state2, value) => {
        state2.props.scrollY = value;
        this.scheduleUpdateState(state2);
      },
      letterSpacing: (state2, value) => {
        state2.props.letterSpacing = value;
        this.invalidateLayoutCache(state2);
      },
      lineHeight: (state2, value) => {
        state2.props.lineHeight = value;
        state2.resLineHeight = void 0;
        this.invalidateLayoutCache(state2);
      },
      maxLines: (state2, value) => {
        state2.props.maxLines = value;
        this.invalidateLayoutCache(state2);
      },
      textBaseline: (state2, value) => {
        state2.props.textBaseline = value;
        this.invalidateLayoutCache(state2);
      },
      verticalAlign: (state2, value) => {
        state2.props.verticalAlign = value;
        this.invalidateLayoutCache(state2);
      },
      overflowSuffix: (state2, value) => {
        state2.props.overflowSuffix = value;
        this.invalidateLayoutCache(state2);
      },
      debug: (state2, value) => {
        state2.props.debug = value;
      }
    };
  }
  canRenderFont(props) {
    const { fontFamily } = props;
    return fontFamily in this.ssdfFontFamilies || fontFamily in this.msdfFontFamilies || fontFamily === "$$SDF_FAILURE_TEST$$";
  }
  isFontFaceSupported(fontFace) {
    return fontFace instanceof SdfTrFontFace;
  }
  addFontFace(fontFace) {
    assertTruthy(fontFace instanceof SdfTrFontFace);
    const familyName = fontFace.fontFamily;
    const fontFamiles = fontFace.type === "ssdf" ? this.ssdfFontFamilies : fontFace.type === "msdf" ? this.msdfFontFamilies : void 0;
    if (!fontFamiles) {
      console.warn(`Invalid font face type: ${fontFace.type}`);
      return;
    }
    let faceSet = fontFamiles[familyName];
    if (!faceSet) {
      faceSet = /* @__PURE__ */ new Set();
      fontFamiles[familyName] = faceSet;
    }
    faceSet.add(fontFace);
  }
  createState(props) {
    return {
      props,
      status: "initialState",
      updateScheduled: false,
      emitter: new EventEmitter(),
      lineCache: [],
      forceFullLayoutCalc: false,
      renderWindow: {
        screen: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0
        },
        sdf: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0
        },
        firstLineIdx: 0,
        numLines: 0,
        valid: false
      },
      elementBounds: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        valid: false
      },
      clippingRect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        valid: false
      },
      bufferNumFloats: 0,
      bufferNumQuads: 0,
      vertexBuffer: void 0,
      webGlBuffers: null,
      bufferUploaded: false,
      textH: void 0,
      textW: void 0,
      distanceRange: 0,
      trFontFace: void 0,
      isRenderable: false,
      resLineHeight: void 0,
      debugData: {
        updateCount: 0,
        layoutCount: 0,
        lastLayoutNumCharacters: 0,
        layoutSum: 0,
        drawSum: 0,
        drawCount: 0,
        bufferSize: 0
      }
    };
  }
  updateState(state2) {
    let { trFontFace } = state2;
    const { textH, lineCache, debugData, forceFullLayoutCalc } = state2;
    debugData.updateCount++;
    if (state2.status === "initialState") {
      this.setStatus(state2, "loading");
    }
    if (trFontFace === void 0) {
      trFontFace = this.resolveFontFace(state2.props);
      state2.trFontFace = trFontFace;
      if (trFontFace === void 0) {
        const msg = `SdfTextRenderer: Could not resolve font face for family: '${state2.props.fontFamily}'`;
        console.error(msg);
        this.setStatus(state2, "failed", new Error(msg));
        return;
      }
      trFontFace.texture.setRenderableOwner(state2.props.fontFamily, true);
    }
    if (trFontFace.loaded === false) {
      trFontFace.once("loaded", () => {
        this.scheduleUpdateState(state2);
      });
      return;
    }
    assertTruthy(trFontFace.data, "Font face data should be loaded");
    assertTruthy(trFontFace.metrics, "Font face metrics should be loaded");
    const { text, fontSize, x, y, contain, width, height, verticalAlign, scrollable, overflowSuffix, maxLines } = state2.props;
    const scrollY = contain === "both" && scrollable ? state2.props.scrollY : 0;
    const { renderWindow } = state2;
    const sdfFontSize = trFontFace.data.info.size;
    const fontSizeRatio = fontSize / sdfFontSize;
    let resLineHeight = state2.resLineHeight;
    if (resLineHeight === void 0) {
      const lineHeight = state2.props.lineHeight;
      if (lineHeight === void 0) {
        resLineHeight = calcDefaultLineHeight(trFontFace.metrics, fontSize);
      } else {
        resLineHeight = lineHeight;
      }
      state2.resLineHeight = resLineHeight;
    }
    const sdfLineHeight = resLineHeight / fontSizeRatio;
    state2.distanceRange = fontSizeRatio * trFontFace.data.distanceField.distanceRange;
    const neededLength = text.length * FLOATS_PER_GLYPH;
    let vertexBuffer = state2.vertexBuffer;
    if (!vertexBuffer || vertexBuffer.length < neededLength) {
      vertexBuffer = new Float32Array(neededLength * 2);
    }
    const elementBounds = state2.elementBounds;
    if (!elementBounds.valid) {
      this.setElementBoundsX(state2);
      this.setElementBoundsY(state2);
      elementBounds.valid = true;
    }
    if (!forceFullLayoutCalc && renderWindow.valid) {
      const rwScreen = renderWindow.screen;
      if (x + rwScreen.x1 <= elementBounds.x1 && x + rwScreen.x2 >= elementBounds.x2 && y - scrollY + rwScreen.y1 <= elementBounds.y1 && y - scrollY + rwScreen.y2 >= elementBounds.y2) {
        this.setStatus(state2, "loaded");
        return;
      }
      renderWindow.valid = false;
      this.setStatus(state2, "loading");
    }
    const { offsetY, textAlign } = state2.props;
    if (!renderWindow.valid) {
      const isPossiblyOnScreen = boundsOverlap(elementBounds, this.rendererBounds);
      if (!isPossiblyOnScreen) {
        return;
      }
      setRenderWindow(renderWindow, x, y, scrollY, resLineHeight, contain === "both" ? elementBounds.y2 - elementBounds.y1 : 0, elementBounds, fontSizeRatio);
    }
    const start = getStartConditions(sdfFontSize, sdfLineHeight, trFontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH);
    if (!start) {
      this.setStatus(state2, "loaded");
      return;
    }
    const { letterSpacing } = state2.props;
    const out2 = layoutText(start.lineIndex, start.sdfX, start.sdfY, text, textAlign, width, height, fontSize, resLineHeight, letterSpacing, vertexBuffer, contain, lineCache, renderWindow.sdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines);
    state2.bufferUploaded = false;
    state2.bufferNumFloats = out2.bufferNumFloats;
    state2.bufferNumQuads = out2.bufferNumQuads;
    state2.vertexBuffer = vertexBuffer;
    state2.renderWindow = renderWindow;
    debugData.lastLayoutNumCharacters = out2.layoutNumCharacters;
    debugData.bufferSize = vertexBuffer.byteLength;
    if (out2.fullyProcessed) {
      state2.textW = out2.maxX * fontSizeRatio;
      state2.textH = out2.numLines * sdfLineHeight * fontSizeRatio;
    }
    this.setStatus(state2, "loaded");
  }
  renderQuads(state2, transform, clippingRect, alpha, parentHasRenderTexture, framebufferDimensions) {
    var _a2, _b;
    if (!state2.vertexBuffer) {
      return;
    }
    const renderer3 = this.stage.renderer;
    assertTruthy(renderer3 instanceof WebGlCoreRenderer);
    const { fontSize, color, contain, scrollable, zIndex, debug } = state2.props;
    const scrollY = contain === "both" && scrollable ? state2.props.scrollY : 0;
    const { textW = 0, textH = 0, distanceRange, vertexBuffer, bufferUploaded, trFontFace, elementBounds } = state2;
    let { webGlBuffers } = state2;
    if (!webGlBuffers) {
      const glw = renderer3.glw;
      const stride = 4 * Float32Array.BYTES_PER_ELEMENT;
      const webGlBuffer = glw.createBuffer();
      assertTruthy(webGlBuffer);
      state2.webGlBuffers = new BufferCollection([
        {
          buffer: webGlBuffer,
          attributes: {
            a_position: {
              name: "a_position",
              size: 2,
              // 2 components per iteration
              type: glw.FLOAT,
              // the data is 32bit floats
              normalized: false,
              // don't normalize the data
              stride,
              // 0 = move forward size * sizeof(type) each iteration to get the next position
              offset: 0
              // start at the beginning of the buffer
            },
            a_textureCoordinate: {
              name: "a_textureCoordinate",
              size: 2,
              type: glw.FLOAT,
              normalized: false,
              stride,
              offset: 2 * Float32Array.BYTES_PER_ELEMENT
            }
          }
        }
      ]);
      state2.bufferUploaded = false;
      assertTruthy(state2.webGlBuffers);
      webGlBuffers = state2.webGlBuffers;
    }
    if (!bufferUploaded) {
      const glw = renderer3.glw;
      const buffer = (webGlBuffers == null ? void 0 : webGlBuffers.getBuffer("a_textureCoordinate")) ?? null;
      glw.arrayBufferData(buffer, vertexBuffer, glw.STATIC_DRAW);
      state2.bufferUploaded = true;
    }
    assertTruthy(trFontFace);
    if (scrollable && contain === "both") {
      assertTruthy(elementBounds.valid);
      const elementRect = convertBoundToRect(elementBounds, tmpRect);
      if (clippingRect.valid) {
        state2.clippingRect.valid = true;
        clippingRect = intersectRect(clippingRect, elementRect, state2.clippingRect);
      } else {
        state2.clippingRect.valid = true;
        clippingRect = copyRect(elementRect, state2.clippingRect);
      }
    }
    const renderOp = new WebGlCoreRenderOp(renderer3.glw, renderer3.options, webGlBuffers, this.sdfShader, {
      transform: transform.getFloatArr(),
      // IMPORTANT: The SDF Shader expects the color NOT to be premultiplied
      // for the best blending results. Which is why we use `mergeColorAlpha`
      // instead of `mergeColorAlphaPremultiplied` here.
      color: mergeColorAlpha(color, alpha),
      size: fontSize / (((_a2 = trFontFace.data) == null ? void 0 : _a2.info.size) || 0),
      scrollY,
      distanceRange,
      debug: debug.sdfShaderDebug
    }, alpha, clippingRect, { height: textH, width: textW }, 0, zIndex, false, parentHasRenderTexture, framebufferDimensions);
    const texture = (_b = state2.trFontFace) == null ? void 0 : _b.texture;
    assertTruthy(texture);
    const ctxTexture = texture.ctxTexture;
    renderOp.addTexture(ctxTexture);
    renderOp.length = state2.bufferNumFloats;
    renderOp.numQuads = state2.bufferNumQuads;
    renderer3.addRenderOp(renderOp);
  }
  setIsRenderable(state2, renderable) {
    var _a2;
    super.setIsRenderable(state2, renderable);
    (_a2 = state2.trFontFace) == null ? void 0 : _a2.texture.setRenderableOwner(state2.props.fontFamily, renderable);
  }
  destroyState(state2) {
    var _a2;
    super.destroyState(state2);
    (_a2 = state2.trFontFace) == null ? void 0 : _a2.texture.setRenderableOwner(state2.props.fontFamily, false);
  }
  //#endregion Overrides
  resolveFontFace(props) {
    return this.stage.fontManager.resolveFontFace(this.fontFamilyArray, props, "sdf");
  }
  /**
   * Release the loaded SDF font face
   *
   * @param state
   */
  releaseFontFace(state2) {
    state2.resLineHeight = void 0;
    if (state2.trFontFace) {
      state2.trFontFace.texture.setRenderableOwner(state2.props.fontFamily, false);
      state2.trFontFace = void 0;
    }
  }
  /**
   * Invalidate the layout cache stored in the state. This will cause the text
   * to be re-layed out on the next update.
   *
   * @remarks
   * This also invalidates the visible window cache.
   *
   * @param state
   */
  invalidateLayoutCache(state2) {
    state2.renderWindow.valid = false;
    state2.elementBounds.valid = false;
    state2.textH = void 0;
    state2.textW = void 0;
    state2.lineCache = [];
    this.setStatus(state2, "loading");
    this.scheduleUpdateState(state2);
  }
  setElementBoundsX(state2) {
    const { x, contain, width } = state2.props;
    const { elementBounds } = state2;
    elementBounds.x1 = x;
    elementBounds.x2 = contain !== "none" ? x + width : Infinity;
  }
  setElementBoundsY(state2) {
    const { y, contain, height } = state2.props;
    const { elementBounds } = state2;
    elementBounds.y1 = y;
    elementBounds.y2 = contain === "both" ? y + height : Infinity;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TextTextureRendererUtils.js
function isZeroWidthSpace(space) {
  return space === "" || space === "​";
}
function getWebFontMetrics(context, fontFace, fontSize) {
  if (fontFace.metrics) {
    return fontFace.metrics;
  }
  const browserMetrics = context.measureText("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
  console.warn(`Font metrics not provided for Canvas Web font ${fontFace.fontFamily}. Using fallback values. It is HIGHLY recommended you use the latest version of the Lightning 3 \`msdf-generator\` tool to extract the default metrics for the font and provide them in the Canvas Web font definition.`);
  let metrics;
  if (browserMetrics.actualBoundingBoxDescent && browserMetrics.actualBoundingBoxAscent) {
    metrics = {
      ascender: browserMetrics.actualBoundingBoxAscent / fontSize,
      descender: -browserMetrics.actualBoundingBoxDescent / fontSize,
      lineGap: 0.2
    };
  } else {
    metrics = {
      ascender: 0.8,
      descender: -0.2,
      lineGap: 0.2
    };
  }
  fontFace.metrics = metrics;
  return metrics;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/LightningTextTextureRenderer.js
var MAX_TEXTURE_DIMENSION = 2048;
function calcHeight(textBaseline, fontSize, lineHeight, numLines, offsetY) {
  const baselineOffset = textBaseline !== "bottom" ? 0.5 * fontSize : 0;
  return lineHeight * (numLines - 1) + baselineOffset + Math.max(lineHeight, fontSize) + (offsetY || 0);
}
var LightningTextTextureRenderer = class {
  constructor(canvas, context) {
    __publicField(this, "_canvas");
    __publicField(this, "_context");
    __publicField(this, "_settings");
    this._canvas = canvas;
    this._context = context;
    this._settings = this.mergeDefaults({});
  }
  set settings(v) {
    this._settings = this.mergeDefaults(v);
  }
  get settings() {
    return this._settings;
  }
  getPrecision() {
    return this._settings.precision;
  }
  setFontProperties() {
    this._context.font = this._getFontSetting();
    this._context.textBaseline = this._settings.textBaseline;
  }
  _getFontSetting() {
    const ff = [this._settings.fontFamily];
    const ffs = [];
    for (let i = 0, n2 = ff.length; i < n2; i++) {
      if (ff[i] === "serif" || ff[i] === "sans-serif") {
        ffs.push(ff[i]);
      } else {
        ffs.push(`"${ff[i]}"`);
      }
    }
    return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`;
  }
  _load() {
    if (document.fonts) {
      const fontSetting = this._getFontSetting();
      try {
        if (!document.fonts.check(fontSetting, this._settings.text)) {
          return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
            console.warn("[Lightning] Font load error", err, fontSetting);
          }).then(() => {
            if (!document.fonts.check(fontSetting, this._settings.text)) {
              console.warn("[Lightning] Font not found", fontSetting);
            }
          });
        }
      } catch (e) {
        console.warn("[Lightning] Can't check font loading for " + fontSetting);
      }
    }
  }
  calculateRenderInfo() {
    const renderInfo = {};
    const precision = this.getPrecision();
    const paddingLeft = this._settings.paddingLeft * precision;
    const paddingRight = this._settings.paddingRight * precision;
    const fontSize = this._settings.fontSize * precision;
    let offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision;
    const w = this._settings.w * precision;
    const h = this._settings.h * precision;
    let wordWrapWidth = this._settings.wordWrapWidth * precision;
    const cutSx = this._settings.cutSx * precision;
    const cutEx = this._settings.cutEx * precision;
    const cutSy = this._settings.cutSy * precision;
    const cutEy = this._settings.cutEy * precision;
    const letterSpacing = (this._settings.letterSpacing || 0) * precision;
    const textIndent = this._settings.textIndent * precision;
    const trFontFace = this._settings.trFontFace;
    this.setFontProperties();
    assertTruthy(trFontFace);
    const metrics = getWebFontMetrics(this._context, trFontFace, fontSize);
    const defLineHeight = calcDefaultLineHeight(metrics, fontSize) * precision;
    const lineHeight = this._settings.lineHeight !== null ? this._settings.lineHeight * precision : defLineHeight;
    const maxHeight = this._settings.maxHeight;
    const containedMaxLines = maxHeight !== null && lineHeight > 0 ? Math.floor(maxHeight / lineHeight) : 0;
    const setMaxLines = this._settings.maxLines;
    const calcMaxLines = containedMaxLines > 0 && setMaxLines > 0 ? Math.min(containedMaxLines, setMaxLines) : Math.max(containedMaxLines, setMaxLines);
    let width = w || 2048 / this.getPrecision();
    let innerWidth = width - paddingLeft;
    if (innerWidth < 10) {
      width += 10 - innerWidth;
      innerWidth = 10;
    }
    if (!wordWrapWidth) {
      wordWrapWidth = innerWidth;
    }
    if (this._settings.textOverflow && !this._settings.wordWrap) {
      let suffix;
      switch (this._settings.textOverflow) {
        case "clip":
          suffix = "";
          break;
        case "ellipsis":
          suffix = this._settings.overflowSuffix;
          break;
        default:
          suffix = this._settings.textOverflow;
      }
      this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
    }
    let linesInfo;
    if (this._settings.wordWrap) {
      linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
    } else {
      linesInfo = { l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: [] };
      const n2 = linesInfo.l.length;
      for (let i = 0; i < n2 - 1; i++) {
        linesInfo.n.push(i);
      }
    }
    let lines = linesInfo.l;
    if (calcMaxLines && lines.length > calcMaxLines) {
      const usedLines = lines.slice(0, calcMaxLines);
      let otherLines = null;
      if (this._settings.overflowSuffix) {
        const w2 = this._settings.overflowSuffix ? this.measureText(this._settings.overflowSuffix) : 0;
        const al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w2, letterSpacing, textIndent);
        usedLines[usedLines.length - 1] = `${al.l[0]}${this._settings.overflowSuffix}`;
        otherLines = [al.l.length > 1 ? al.l[1] : ""];
      } else {
        otherLines = [""];
      }
      let i;
      const n2 = lines.length;
      let j = 0;
      const m = linesInfo.n.length;
      for (i = calcMaxLines; i < n2; i++) {
        otherLines[j] += `${otherLines[j] ? " " : ""}${lines[i]}`;
        if (i + 1 < m && linesInfo.n[i + 1]) {
          j++;
        }
      }
      renderInfo.remainingText = otherLines.join("\n");
      renderInfo.moreTextLines = true;
      lines = usedLines;
    } else {
      renderInfo.moreTextLines = false;
      renderInfo.remainingText = "";
    }
    let maxLineWidth = 0;
    const lineWidths = [];
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
      lineWidths.push(lineWidth);
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    renderInfo.lineWidths = lineWidths;
    if (!w) {
      width = maxLineWidth + paddingLeft + paddingRight;
      innerWidth = maxLineWidth;
    }
    if (this._settings.wordWrap && w > maxLineWidth && this._settings.textAlign === "left" && lines.length === 1) {
      width = maxLineWidth + paddingLeft + paddingRight;
    }
    let height;
    if (h) {
      height = h;
    } else {
      height = calcHeight(this._settings.textBaseline, fontSize, lineHeight, lines.length, offsetY);
    }
    if (offsetY === null) {
      offsetY = fontSize;
    }
    renderInfo.w = width;
    renderInfo.h = height;
    renderInfo.lines = lines;
    renderInfo.precision = precision;
    if (!width) {
      width = 1;
    }
    if (!height) {
      height = 1;
    }
    if (cutSx || cutEx) {
      width = Math.min(width, cutEx - cutSx);
    }
    if (cutSy || cutEy) {
      height = Math.min(height, cutEy - cutSy);
    }
    renderInfo.width = width;
    renderInfo.innerWidth = innerWidth;
    renderInfo.height = height;
    renderInfo.fontSize = fontSize;
    renderInfo.cutSx = cutSx;
    renderInfo.cutSy = cutSy;
    renderInfo.cutEx = cutEx;
    renderInfo.cutEy = cutEy;
    renderInfo.lineHeight = lineHeight;
    renderInfo.defLineHeight = defLineHeight;
    renderInfo.lineWidths = lineWidths;
    renderInfo.offsetY = offsetY;
    renderInfo.paddingLeft = paddingLeft;
    renderInfo.paddingRight = paddingRight;
    renderInfo.letterSpacing = letterSpacing;
    renderInfo.textIndent = textIndent;
    renderInfo.metrics = metrics;
    return renderInfo;
  }
  draw(renderInfo, linesOverride) {
    const precision = this.getPrecision();
    const lines = (linesOverride == null ? void 0 : linesOverride.lines) || renderInfo.lines;
    const lineWidths = (linesOverride == null ? void 0 : linesOverride.lineWidths) || renderInfo.lineWidths;
    const height = linesOverride ? calcHeight(this._settings.textBaseline, renderInfo.fontSize, renderInfo.lineHeight, linesOverride.lines.length, this._settings.offsetY === null ? null : this._settings.offsetY * precision) : renderInfo.height;
    this._canvas.width = Math.min(Math.ceil(renderInfo.width + this._settings.textRenderIssueMargin), MAX_TEXTURE_DIMENSION);
    this._canvas.height = Math.min(Math.ceil(height), MAX_TEXTURE_DIMENSION);
    this.setFontProperties();
    if (renderInfo.fontSize >= 128) {
      this._context.globalAlpha = 0.01;
      this._context.fillRect(0, 0, 0.01, 0.01);
      this._context.globalAlpha = 1;
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
    }
    let linePositionX;
    let linePositionY;
    const drawLines = [];
    const { metrics } = renderInfo;
    const ascenderPx = metrics ? metrics.ascender * renderInfo.fontSize : renderInfo.fontSize;
    const bareLineHeightPx = (metrics.ascender - metrics.descender) * renderInfo.fontSize;
    for (let i = 0, n2 = lines.length; i < n2; i++) {
      linePositionX = i === 0 ? renderInfo.textIndent : 0;
      linePositionY = i * renderInfo.lineHeight + ascenderPx;
      if (this._settings.verticalAlign == "middle") {
        linePositionY += (renderInfo.lineHeight - bareLineHeightPx) / 2;
      } else if (this._settings.verticalAlign == "bottom") {
        linePositionY += renderInfo.lineHeight - bareLineHeightPx;
      }
      if (this._settings.textAlign === "right") {
        linePositionX += renderInfo.innerWidth - lineWidths[i];
      } else if (this._settings.textAlign === "center") {
        linePositionX += (renderInfo.innerWidth - lineWidths[i]) / 2;
      }
      linePositionX += renderInfo.paddingLeft;
      drawLines.push({
        text: lines[i],
        x: linePositionX,
        y: linePositionY,
        w: lineWidths[i]
      });
    }
    if (this._settings.highlight) {
      const color = this._settings.highlightColor;
      const hlHeight = this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5;
      const offset = this._settings.highlightOffset * precision;
      const hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft;
      const hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight;
      this._context.fillStyle = getRgbaString(color);
      for (let i = 0; i < drawLines.length; i++) {
        const drawLine = drawLines[i];
        this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
      }
    }
    let prevShadowSettings = null;
    if (this._settings.shadow) {
      prevShadowSettings = [
        this._context.shadowColor,
        this._context.shadowOffsetX,
        this._context.shadowOffsetY,
        this._context.shadowBlur
      ];
      this._context.shadowColor = getRgbaString(this._settings.shadowColor);
      this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
      this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
      this._context.shadowBlur = this._settings.shadowBlur * precision;
    }
    this._context.fillStyle = getRgbaString(this._settings.textColor);
    for (let i = 0, n2 = drawLines.length; i < n2; i++) {
      const drawLine = drawLines[i];
      if (renderInfo.letterSpacing === 0) {
        this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
      } else {
        const textSplit = drawLine.text.split("");
        let x = drawLine.x;
        for (let i2 = 0, j = textSplit.length; i2 < j; i2++) {
          this._context.fillText(textSplit[i2], x, drawLine.y);
          x += this.measureText(textSplit[i2], renderInfo.letterSpacing);
        }
      }
    }
    if (prevShadowSettings) {
      this._context.shadowColor = prevShadowSettings[0];
      this._context.shadowOffsetX = prevShadowSettings[1];
      this._context.shadowOffsetY = prevShadowSettings[2];
      this._context.shadowBlur = prevShadowSettings[3];
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
    }
  }
  wrapWord(word, wordWrapWidth, suffix) {
    const suffixWidth = this._context.measureText(suffix).width;
    const wordLen = word.length;
    const wordWidth = this._context.measureText(word).width;
    if (wordWidth <= wordWrapWidth) {
      return word;
    }
    let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
    let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
    if (truncWordWidth > wordWrapWidth) {
      while (cutoffIndex > 0) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth > wordWrapWidth) {
          cutoffIndex -= 1;
        } else {
          break;
        }
      }
    } else {
      while (cutoffIndex < wordLen) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth < wordWrapWidth) {
          cutoffIndex += 1;
        } else {
          cutoffIndex -= 1;
          break;
        }
      }
    }
    return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   */
  wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
    const spaceRegex = / |\u200B/g;
    const lines = text.split(/\r?\n/g);
    let allLines = [];
    const realNewlines = [];
    for (let i = 0; i < lines.length; i++) {
      const resultLines = [];
      let result = "";
      let spaceLeft = wordWrapWidth - indent;
      const words = lines[i].split(spaceRegex);
      const spaces = lines[i].match(spaceRegex) || [];
      for (let j = 0; j < words.length; j++) {
        const space = spaces[j - 1] || "";
        const word = words[j];
        const wordWidth = this.measureText(word, letterSpacing);
        const wordWidthWithSpace = isZeroWidthSpace(space) ? wordWidth : wordWidth + this.measureText(space, letterSpacing);
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            resultLines.push(result);
            result = "";
          }
          result += word;
          spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += space + word;
        }
      }
      resultLines.push(result);
      result = "";
      allLines = allLines.concat(resultLines);
      if (i < lines.length - 1) {
        realNewlines.push(allLines.length);
      }
    }
    return { l: allLines, n: realNewlines };
  }
  measureText(word, space = 0) {
    if (!space) {
      return this._context.measureText(word).width;
    }
    return word.split("").reduce((acc, char) => {
      if (isZeroWidthSpace(char)) {
        return acc;
      }
      return acc + this._context.measureText(char).width + space;
    }, 0);
  }
  mergeDefaults(settings2) {
    return {
      text: "",
      w: 0,
      h: 0,
      fontStyle: "normal",
      fontSize: 40,
      fontFamily: null,
      trFontFace: null,
      wordWrap: true,
      wordWrapWidth: 0,
      wordBreak: false,
      textOverflow: "",
      lineHeight: null,
      textBaseline: "alphabetic",
      textAlign: "left",
      verticalAlign: "top",
      offsetY: null,
      maxLines: 0,
      maxHeight: null,
      overflowSuffix: "...",
      textColor: [1, 1, 1, 1],
      paddingLeft: 0,
      paddingRight: 0,
      shadow: false,
      shadowColor: [0, 0, 0, 1],
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      shadowBlur: 5,
      highlight: false,
      highlightHeight: 0,
      highlightColor: [0, 0, 0, 1],
      highlightOffset: 0,
      highlightPaddingLeft: 0,
      highlightPaddingRight: 0,
      letterSpacing: 0,
      textIndent: 0,
      cutSx: 0,
      cutEx: 0,
      cutSy: 0,
      cutEy: 0,
      advancedRenderer: false,
      fontBaselineRatio: 0,
      precision: 1,
      textRenderIssueMargin: 0,
      ...settings2
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/CanvasTextRenderer.js
var resolvedGlobal = typeof self === "undefined" ? globalThis : self;
var _a;
var globalFontSet = ((_a = resolvedGlobal.document) == null ? void 0 : _a.fonts) || resolvedGlobal.fonts;
function getFontCssString(props) {
  const { fontFamily, fontStyle, fontWeight, fontStretch, fontSize } = props;
  return [fontStyle, fontWeight, fontStretch, `${fontSize}px`, fontFamily].join(" ");
}
var CanvasTextRenderer = class extends TextRenderer {
  constructor(stage2) {
    super(stage2);
    __publicField(this, "canvas");
    __publicField(this, "context");
    /**
     * Font family map used to store web font faces that were added to the
     * canvas text renderer.
     */
    __publicField(this, "fontFamilies", {});
    __publicField(this, "fontFamilyArray", [this.fontFamilies]);
    __publicField(this, "type", "canvas");
    __publicField(this, "loadFont", (state2) => {
      const cssString = getFontCssString(state2.props);
      const trFontFace = this.stage.fontManager.resolveFontFace(this.fontFamilyArray, state2.props, "canvas");
      assertTruthy(trFontFace, `Could not resolve font face for ${cssString}`);
      state2.fontInfo = {
        fontFace: trFontFace,
        cssString,
        // TODO: For efficiency we would use this here but it's not reliable on WPE -> document.fonts.check(cssString),
        loaded: false
      };
      if (!state2.fontInfo.loaded) {
        globalFontSet.load(cssString).then(this.onFontLoaded.bind(this, state2, cssString)).catch(this.onFontLoadError.bind(this, state2, cssString));
        return;
      }
    });
    if (typeof OffscreenCanvas !== "undefined") {
      this.canvas = new OffscreenCanvas(0, 0);
    } else {
      this.canvas = document.createElement("canvas");
    }
    let context = this.canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (!context) {
      this.canvas = document.createElement("canvas");
      context = this.canvas.getContext("2d", {
        willReadFrequently: true
      });
    }
    assertTruthy(context);
    this.context = context;
    this.addFontFace(new WebTrFontFace({
      fontFamily: "sans-serif",
      descriptors: {},
      fontUrl: ""
    }));
  }
  //#region Overrides
  getPropertySetters() {
    return {
      fontFamily: (state2, value) => {
        state2.props.fontFamily = value;
        state2.fontInfo = void 0;
        this.invalidateLayoutCache(state2);
      },
      fontWeight: (state2, value) => {
        state2.props.fontWeight = value;
        state2.fontInfo = void 0;
        this.invalidateLayoutCache(state2);
      },
      fontStyle: (state2, value) => {
        state2.props.fontStyle = value;
        state2.fontInfo = void 0;
        this.invalidateLayoutCache(state2);
      },
      fontStretch: (state2, value) => {
        state2.props.fontStretch = value;
        state2.fontInfo = void 0;
        this.invalidateLayoutCache(state2);
      },
      fontSize: (state2, value) => {
        state2.props.fontSize = value;
        state2.fontInfo = void 0;
        this.invalidateLayoutCache(state2);
      },
      text: (state2, value) => {
        state2.props.text = value;
        this.invalidateLayoutCache(state2);
      },
      textAlign: (state2, value) => {
        state2.props.textAlign = value;
        this.invalidateLayoutCache(state2);
      },
      color: (state2, value) => {
        state2.props.color = value;
        this.invalidateLayoutCache(state2);
      },
      x: (state2, value) => {
        state2.props.x = value;
      },
      y: (state2, value) => {
        state2.props.y = value;
      },
      contain: (state2, value) => {
        state2.props.contain = value;
        this.invalidateLayoutCache(state2);
      },
      width: (state2, value) => {
        state2.props.width = value;
        if (state2.props.contain !== "none") {
          this.invalidateLayoutCache(state2);
        }
      },
      height: (state2, value) => {
        state2.props.height = value;
        if (state2.props.contain === "both") {
          this.invalidateLayoutCache(state2);
        }
      },
      offsetY: (state2, value) => {
        state2.props.offsetY = value;
        this.invalidateLayoutCache(state2);
      },
      scrollY: (state2, value) => {
        state2.props.scrollY = value;
      },
      letterSpacing: (state2, value) => {
        state2.props.letterSpacing = value;
        this.invalidateLayoutCache(state2);
      },
      lineHeight: (state2, value) => {
        state2.props.lineHeight = value;
        this.invalidateLayoutCache(state2);
      },
      maxLines: (state2, value) => {
        state2.props.maxLines = value;
        this.invalidateLayoutCache(state2);
      },
      textBaseline: (state2, value) => {
        state2.props.textBaseline = value;
        this.invalidateLayoutCache(state2);
      },
      verticalAlign: (state2, value) => {
        state2.props.verticalAlign = value;
        this.invalidateLayoutCache(state2);
      },
      overflowSuffix: (state2, value) => {
        state2.props.overflowSuffix = value;
        this.invalidateLayoutCache(state2);
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  canRenderFont(props) {
    return true;
  }
  isFontFaceSupported(fontFace) {
    return fontFace instanceof WebTrFontFace;
  }
  addFontFace(fontFace) {
    assertTruthy(fontFace instanceof WebTrFontFace);
    const fontFamily = fontFace.fontFamily;
    if (fontFamily !== "sans-serif") {
      globalFontSet.add(fontFace.fontFace);
    }
    let faceSet = this.fontFamilies[fontFamily];
    if (!faceSet) {
      faceSet = /* @__PURE__ */ new Set();
      this.fontFamilies[fontFamily] = faceSet;
    }
    faceSet.add(fontFace);
  }
  createState(props, node) {
    return {
      node,
      props,
      status: "initialState",
      updateScheduled: false,
      emitter: new EventEmitter(),
      textureNode: void 0,
      lightning2TextRenderer: new LightningTextTextureRenderer(this.canvas, this.context),
      renderInfo: void 0,
      forceFullLayoutCalc: false,
      textW: 0,
      textH: 0,
      fontInfo: void 0,
      isRenderable: false,
      debugData: {
        updateCount: 0,
        layoutCount: 0,
        drawCount: 0,
        lastLayoutNumCharacters: 0,
        layoutSum: 0,
        drawSum: 0,
        bufferSize: 0
      }
    };
  }
  updateState(state2) {
    if (state2.status === "initialState") {
      this.setStatus(state2, "loading");
    }
    if (state2.status === "loaded") {
      return;
    }
    if (!state2.fontInfo) {
      return this.loadFont(state2);
    }
    if (!state2.fontInfo.loaded) {
      return;
    }
    if (!state2.renderInfo) {
      state2.renderInfo = this.calculateRenderInfo(state2);
      state2.textH = state2.renderInfo.lineHeight * state2.renderInfo.lines.length;
      state2.textW = state2.renderInfo.width;
      this.renderSingleCanvasPage(state2);
    }
  }
  renderSingleCanvasPage(state2) {
    assertTruthy(state2.renderInfo);
    const node = state2.node;
    const texture = this.stage.txManager.createTexture("ImageTexture", {
      premultiplyAlpha: true,
      src: (function(lightning2TextRenderer, renderInfo) {
        assertTruthy(renderInfo);
        lightning2TextRenderer.draw(renderInfo, {
          lines: renderInfo.lines,
          lineWidths: renderInfo.lineWidths
        });
        if (this.canvas.width === 0 || this.canvas.height === 0) {
          return null;
        }
        return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
      }).bind(this, state2.lightning2TextRenderer, state2.renderInfo)
    });
    if (state2.textureNode) {
      state2.textureNode.texture = texture;
      state2.textureNode.alpha = getNormalizedAlphaComponent(state2.props.color);
    } else {
      const textureNode = this.stage.createNode({
        parent: node,
        texture,
        autosize: true,
        // The alpha channel of the color is ignored when rasterizing the text
        // texture so we need to pass it directly to the texture node.
        alpha: getNormalizedAlphaComponent(state2.props.color)
      });
      state2.textureNode = textureNode;
    }
    this.setStatus(state2, "loaded");
  }
  calculateRenderInfo(state2) {
    var _a2;
    state2.lightning2TextRenderer.settings = {
      text: state2.props.text,
      textAlign: state2.props.textAlign,
      fontFamily: state2.props.fontFamily,
      trFontFace: (_a2 = state2.fontInfo) == null ? void 0 : _a2.fontFace,
      fontSize: state2.props.fontSize,
      fontStyle: [
        state2.props.fontStretch,
        state2.props.fontStyle,
        state2.props.fontWeight
      ].join(" "),
      textColor: getNormalizedRgbaComponents(state2.props.color),
      offsetY: state2.props.offsetY,
      wordWrap: state2.props.contain !== "none",
      wordWrapWidth: state2.props.contain === "none" ? void 0 : state2.props.width,
      letterSpacing: state2.props.letterSpacing,
      lineHeight: state2.props.lineHeight ?? null,
      maxLines: state2.props.maxLines,
      maxHeight: state2.props.contain === "both" ? state2.props.height - state2.props.offsetY : null,
      textBaseline: state2.props.textBaseline,
      verticalAlign: state2.props.verticalAlign,
      overflowSuffix: state2.props.overflowSuffix,
      w: state2.props.contain !== "none" ? state2.props.width : void 0
    };
    state2.renderInfo = state2.lightning2TextRenderer.calculateRenderInfo();
    return state2.renderInfo;
  }
  renderQuads() {
    return;
  }
  destroyState(state2) {
    if (state2.status === "destroyed") {
      return;
    }
    super.destroyState(state2);
    if (state2.textureNode) {
      state2.textureNode.destroy();
      delete state2.textureNode;
    }
    delete state2.renderInfo;
  }
  //#endregion Overrides
  /**
   * Invalidate the layout cache stored in the state. This will cause the text
   * to be re-rendered on the next update.
   *
   * @remarks
   * This also invalidates the visible window cache.
   *
   * @param state
   */
  invalidateLayoutCache(state2) {
    state2.renderInfo = void 0;
    this.setStatus(state2, "loading");
    this.scheduleUpdateState(state2);
  }
  onFontLoaded(state2, cssString) {
    var _a2;
    if (cssString !== ((_a2 = state2.fontInfo) == null ? void 0 : _a2.cssString) || !state2.fontInfo) {
      return;
    }
    state2.fontInfo.loaded = true;
    this.scheduleUpdateState(state2);
  }
  onFontLoadError(state2, cssString, error) {
    var _a2;
    if (cssString !== ((_a2 = state2.fontInfo) == null ? void 0 : _a2.cssString) || !state2.fontInfo) {
      return;
    }
    state2.fontInfo.loaded = true;
    console.error(`CanvasTextRenderer: Error loading font '${state2.fontInfo.cssString}'`, error);
    this.scheduleUpdateState(state2);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/internal/ColorUtils.js
var WHITE = {
  isWhite: true,
  a: 1,
  r: 255,
  g: 255,
  b: 255
};
function parseColor(abgr) {
  if (abgr === 4294967295) {
    return WHITE;
  }
  const a = (abgr >>> 24 & 255) / 255;
  const b = abgr >>> 16 & 255 & 255;
  const g = abgr >>> 8 & 255 & 255;
  const r = abgr & 255 & 255;
  return { isWhite: false, a, r, g, b };
}
function parseColorRgba(rgba2) {
  if (rgba2 === 4294967295) {
    return WHITE;
  }
  const r = rgba2 >>> 24 & 255;
  const g = rgba2 >>> 16 & 255 & 255;
  const b = rgba2 >>> 8 & 255 & 255;
  const a = (rgba2 & 255 & 255) / 255;
  return { isWhite: false, r, g, b, a };
}
function formatRgba({ a, r, g, b }) {
  return `rgba(${r},${g},${b},${a})`;
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/CanvasCoreTexture.js
var CanvasCoreTexture = class extends CoreContextTexture {
  constructor() {
    super(...arguments);
    __publicField(this, "image");
    __publicField(this, "tintCache");
  }
  async load() {
    this.textureSource.setState("loading");
    try {
      const size = await this.onLoadRequest();
      this.textureSource.setState("loaded", size);
      this.updateMemSize();
    } catch (err) {
      this.textureSource.setState("failed", err);
      throw err;
    }
  }
  release() {
    this.image = void 0;
    this.tintCache = void 0;
  }
  free() {
    this.release();
    this.textureSource.setState("freed");
    this.setTextureMemUse(0);
    this.textureSource.freeTextureData();
  }
  updateMemSize() {
    const mult = this.tintCache ? 8 : 4;
    if (this.textureSource.dimensions) {
      const { width, height } = this.textureSource.dimensions;
      this.setTextureMemUse(width * height * mult);
    }
  }
  hasImage() {
    return this.image !== void 0;
  }
  getImage(color) {
    var _a2;
    const image = this.image;
    assertTruthy(image, "Attempt to get unloaded image texture");
    if (color.isWhite) {
      if (this.tintCache) {
        this.tintCache = void 0;
        this.updateMemSize();
      }
      return image;
    }
    const key = formatRgba(color);
    if (((_a2 = this.tintCache) == null ? void 0 : _a2.key) === key) {
      return this.tintCache.image;
    }
    const tintedImage = this.tintTexture(image, key);
    this.tintCache = {
      key,
      image: tintedImage
    };
    this.updateMemSize();
    return tintedImage;
  }
  tintTexture(source, color) {
    const { width, height } = source;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      ctx.fillStyle = color;
      ctx.globalCompositeOperation = "copy";
      ctx.fillRect(0, 0, width, height);
      ctx.globalCompositeOperation = "multiply";
      ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
    }
    return canvas;
  }
  async onLoadRequest() {
    var _a2, _b;
    assertTruthy((_b = (_a2 = this.textureSource) == null ? void 0 : _a2.textureData) == null ? void 0 : _b.data, "Texture data is null");
    const { data } = this.textureSource.textureData;
    if (data instanceof ImageData) {
      const canvas = document.createElement("canvas");
      canvas.width = data.width;
      canvas.height = data.height;
      const ctx = canvas.getContext("2d");
      if (ctx)
        ctx.putImageData(data, 0, 0);
      this.image = canvas;
      return { width: data.width, height: data.height };
    } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || data instanceof HTMLImageElement) {
      this.image = data;
      return { width: data.width, height: data.height };
    }
    return { width: 0, height: 0 };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/internal/C2DShaderUtils.js
function getRadius(quad) {
  var _a2, _b;
  if (quad.shader instanceof UnsupportedShader) {
    const shType = quad.shader.shType;
    if (shType === ROUNDED_RECTANGLE_SHADER_TYPE) {
      return ((_a2 = quad.shaderProps) == null ? void 0 : _a2.radius) ?? 0;
    } else if (shType === "DynamicShader") {
      const effects = (_b = quad.shaderProps) == null ? void 0 : _b.effects;
      if (effects) {
        const effect2 = effects.find((effect3) => {
          var _a3;
          return effect3.type === "radius" && ((_a3 = effect3 == null ? void 0 : effect3.props) == null ? void 0 : _a3.radius);
        });
        return effect2 && effect2.type === "radius" && effect2.props.radius || 0;
      }
    }
  }
  return 0;
}
function getBorder(quad, direction = "") {
  var _a2;
  if (quad.shader instanceof UnsupportedShader) {
    const shType = quad.shader.shType;
    if (shType === "DynamicShader") {
      const effects = (_a2 = quad.shaderProps) == null ? void 0 : _a2.effects;
      if (effects && effects.length) {
        const effect2 = effects.find((effect3) => {
          return effect3.type === `border${direction}` && effect3.props && effect3.props.width;
        });
        return effect2 && effect2.props;
      }
    }
  }
  return void 0;
}
function roundRect(x, y, width, height, radius) {
  const context = Object.getPrototypeOf(this);
  if (!context.roundRect) {
    const fixOverlappingCorners = (radii2) => {
      const maxRadius = Math.min(width / 2, height / 2);
      const totalHorizontal = radii2.topLeft + radii2.topRight + radii2.bottomRight + radii2.bottomLeft;
      if (totalHorizontal > width || totalHorizontal > height) {
        const scale = maxRadius / Math.max(radii2.topLeft, radii2.topRight, radii2.bottomRight, radii2.bottomLeft);
        radii2.topLeft *= scale;
        radii2.topRight *= scale;
        radii2.bottomRight *= scale;
        radii2.bottomLeft *= scale;
      }
    };
    const radii = typeof radius === "number" ? {
      topLeft: radius,
      topRight: radius,
      bottomRight: radius,
      bottomLeft: radius
    } : { topLeft: 0, topRight: 0, bottomRight: 0, bottomLeft: 0, ...radius };
    fixOverlappingCorners(radii);
    this.moveTo(x + radii.topLeft, y);
    this.lineTo(x + width - radii.topRight, y);
    this.ellipse(x + width - radii.topRight, y + radii.topRight, radii.topRight, radii.topRight, 0, 1.5 * Math.PI, 2 * Math.PI);
    this.lineTo(x + width, y + height - radii.bottomRight);
    this.ellipse(x + width - radii.bottomRight, y + height - radii.bottomRight, radii.bottomRight, radii.bottomRight, 0, 0, 0.5 * Math.PI);
    this.lineTo(x + radii.bottomLeft, y + height);
    this.ellipse(x + radii.bottomLeft, y + height - radii.bottomLeft, radii.bottomLeft, radii.bottomLeft, 0, 0.5 * Math.PI, Math.PI);
    this.lineTo(x, y + radii.topLeft);
    this.ellipse(x + radii.topLeft, y + radii.topLeft, radii.topLeft, radii.topLeft, 0, Math.PI, 1.5 * Math.PI);
  } else {
    this.roundRect(x, y, width, height, radius);
  }
}
function strokeLine(ctx, x, y, width, height, lineWidth = 0, color, direction) {
  if (!lineWidth) {
    return;
  }
  let sx, sy = 0;
  let ex, ey = 0;
  switch (direction) {
    case "Top":
      sx = x;
      sy = y;
      ex = width + x;
      ey = y;
      break;
    case "Right":
      sx = x + width;
      sy = y;
      ex = x + width;
      ey = y + height;
      break;
    case "Bottom":
      sx = x;
      sy = y + height;
      ex = x + width;
      ey = y + height;
      break;
    case "Left":
      sx = x;
      sy = y;
      ex = x;
      ey = y + height;
      break;
  }
  ctx.beginPath();
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = formatRgba(parseColorRgba(color ?? 0));
  ctx.moveTo(sx, sy);
  ctx.lineTo(ex, ey);
  ctx.stroke();
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/CanvasCoreRenderer.js
var CanvasCoreRenderer = class extends CoreRenderer {
  constructor(options) {
    super(options);
    __publicField(this, "context");
    __publicField(this, "canvas");
    __publicField(this, "pixelRatio");
    __publicField(this, "clearColor");
    __publicField(this, "renderToTextureActive", false);
    __publicField(this, "activeRttNode", null);
    __publicField(this, "defShaderCtr");
    this.mode = "canvas";
    this.shManager.renderer = this;
    const { canvas, pixelRatio, clearColor } = options;
    this.canvas = canvas;
    this.context = canvas.getContext("2d");
    this.pixelRatio = pixelRatio;
    this.clearColor = clearColor ? getRgbaComponents(clearColor) : void 0;
    this.defShaderCtr = {
      type: "DefaultShader",
      props: {},
      shader: new UnsupportedShader("DefaultShader"),
      getResolvedProps: () => () => {
        return {};
      }
    };
  }
  reset() {
    this.canvas.width = this.canvas.width;
    const ctx = this.context;
    if (this.clearColor) {
      const [r, g, b, a] = this.clearColor;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ctx.scale(this.pixelRatio, this.pixelRatio);
  }
  render() {
  }
  addQuad(quad) {
    const ctx = this.context;
    const { tx, ty, width, height, alpha, colorTl, colorTr, colorBr, ta, tb, tc, td, clippingRect } = quad;
    let texture = quad.texture;
    let ctxTexture = void 0;
    let frame;
    const textureType = texture == null ? void 0 : texture.type;
    assertTruthy(textureType, "Texture type is not defined");
    if (textureType !== TextureType.image && textureType !== TextureType.color && textureType !== TextureType.subTexture && textureType !== TextureType.noise) {
      return;
    }
    if (texture) {
      if (texture instanceof SubTexture) {
        frame = texture.props;
        texture = texture.parentTexture;
      }
      ctxTexture = texture.ctxTexture;
      if (texture.state === "freed") {
        return;
      }
      if (texture.state !== "loaded") {
        return;
      }
    }
    const color = parseColor(colorTl);
    const hasTransform = ta !== 1;
    const hasClipping = clippingRect.width !== 0 && clippingRect.height !== 0;
    const hasGradient = colorTl !== colorTr || colorTl !== colorBr;
    const hasQuadShader = Boolean(quad.shader);
    const radius = hasQuadShader ? getRadius(quad) : 0;
    const border = hasQuadShader ? getBorder(quad) : void 0;
    if (hasTransform || hasClipping || radius) {
      ctx.save();
    }
    if (hasClipping) {
      const path = new Path2D();
      const { x, y, width: width2, height: height2 } = clippingRect;
      path.rect(x, y, width2, height2);
      ctx.clip(path);
    }
    if (hasTransform) {
      const scale = this.pixelRatio;
      ctx.setTransform(ta, tc, tb, td, tx * scale, ty * scale);
      ctx.scale(scale, scale);
      ctx.translate(-tx, -ty);
    }
    if (radius) {
      const path = new Path2D();
      roundRect.call(path, tx, ty, width, height, radius);
      ctx.clip(path);
    }
    if ((textureType === TextureType.image || textureType === TextureType.subTexture || textureType === TextureType.noise) && ctxTexture) {
      const image = ctxTexture.getImage(color);
      ctx.globalAlpha = color.a ?? alpha;
      if (frame) {
        ctx.drawImage(image, frame.x, frame.y, frame.width, frame.height, tx, ty, width, height);
      } else {
        try {
          ctx.drawImage(image, tx, ty, width, height);
        } catch (error) {
        }
      }
      ctx.globalAlpha = 1;
    } else if (textureType === TextureType.color && hasGradient) {
      let endX = tx;
      let endY = ty;
      let endColor;
      if (colorTl === colorTr) {
        endX = tx;
        endY = ty + height;
        endColor = parseColor(colorBr);
      } else {
        endX = tx + width;
        endY = ty;
        endColor = parseColor(colorTr);
      }
      const gradient = ctx.createLinearGradient(tx, ty, endX, endY);
      gradient.addColorStop(0, formatRgba(color));
      gradient.addColorStop(1, formatRgba(endColor));
      ctx.fillStyle = gradient;
      ctx.fillRect(tx, ty, width, height);
    } else if (textureType === TextureType.color) {
      ctx.fillStyle = formatRgba(color);
      ctx.fillRect(tx, ty, width, height);
    }
    if (border && border.width) {
      const borderWidth = border.width;
      const borderInnerWidth = border.width / 2;
      const borderColor = formatRgba(parseColorRgba(border.color ?? 0));
      ctx.beginPath();
      ctx.lineWidth = borderWidth;
      ctx.strokeStyle = borderColor;
      ctx.globalAlpha = alpha;
      if (radius) {
        roundRect.call(ctx, tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth, radius);
        ctx.stroke();
      } else {
        ctx.strokeRect(tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth);
      }
      ctx.globalAlpha = 1;
    } else if (hasQuadShader) {
      const borderTop = getBorder(quad, "Top");
      const borderRight = getBorder(quad, "Right");
      const borderBottom = getBorder(quad, "Bottom");
      const borderLeft = getBorder(quad, "Left");
      if (borderTop) {
        strokeLine(ctx, tx, ty, width, height, borderTop.width, borderTop.color, "Top");
      }
      if (borderRight) {
        strokeLine(ctx, tx, ty, width, height, borderRight.width, borderRight.color, "Right");
      }
      if (borderBottom) {
        strokeLine(ctx, tx, ty, width, height, borderBottom.width, borderBottom.color, "Bottom");
      }
      if (borderLeft) {
        strokeLine(ctx, tx, ty, width, height, borderLeft.width, borderLeft.color, "Left");
      }
    }
    if (hasTransform || hasClipping || radius) {
      ctx.restore();
    }
  }
  createCtxTexture(textureSource) {
    return new CanvasCoreTexture(this.txMemManager, textureSource);
  }
  getShaderManager() {
    return this.shManager;
  }
  getDefShaderCtr() {
    return this.defShaderCtr;
  }
  renderRTTNodes() {
  }
  removeRTTNode(node) {
  }
  renderToTexture(node) {
  }
  getBufferInfo() {
    return null;
  }
  getQuadCount() {
    return null;
  }
  /**
   * Updates the clear color of the canvas renderer.
   *
   * @param color - The color to set as the clear color.
   */
  updateClearColor(color) {
    this.clearColor = color ? getRgbaComponents(color) : void 0;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/Inspector.js
var stylePropertyMap = {
  alpha: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "opacity", value: `${v}` };
  },
  x: (x) => {
    return { prop: "left", value: `${x}px` };
  },
  y: (y) => {
    return { prop: "top", value: `${y}px` };
  },
  width: (w) => {
    if (w === 0) {
      return { prop: "width", value: "auto" };
    }
    return { prop: "width", value: `${w}px` };
  },
  height: (h) => {
    if (h === 0) {
      return { prop: "height", value: "auto" };
    }
    return { prop: "height", value: `${h}px` };
  },
  fontSize: (fs) => {
    if (fs === 0) {
      return null;
    }
    return { prop: "font-size", value: `${fs}px` };
  },
  lineHeight: (lh) => {
    if (lh === 0) {
      return null;
    }
    return { prop: "line-height", value: `${lh}px` };
  },
  zIndex: () => "z-index",
  fontFamily: () => "font-family",
  fontStyle: () => "font-style",
  fontWeight: () => "font-weight",
  fontStretch: () => "font-stretch",
  letterSpacing: () => "letter-spacing",
  textAlign: () => "text-align",
  overflowSuffix: () => "overflow-suffix",
  maxLines: () => "max-lines",
  contain: () => "contain",
  verticalAlign: () => "vertical-align",
  clipping: (v) => {
    if (v === false) {
      return null;
    }
    return { prop: "overflow", value: v ? "hidden" : "visible" };
  },
  rotation: (v) => {
    if (v === 0) {
      return null;
    }
    return { prop: "transform", value: `rotate(${v}rad)` };
  },
  scale: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scale(${v})` };
  },
  scaleX: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scaleX(${v})` };
  },
  scaleY: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scaleY(${v})` };
  },
  color: (v) => {
    if (v === 0) {
      return null;
    }
    return { prop: "color", value: convertColorToRgba(v) };
  }
};
var convertColorToRgba = (color) => {
  const a = (color & 255) / 255;
  const b = color >> 8 & 255;
  const g = color >> 16 & 255;
  const r = color >> 24 & 255;
  return `rgba(${r},${g},${b},${a})`;
};
var domPropertyMap = {
  id: "test-id"
};
var textureTypeNames = {
  [TextureType.generic]: "generic",
  [TextureType.color]: "color",
  [TextureType.image]: "image",
  [TextureType.noise]: "noise",
  [TextureType.renderToTexture]: "renderToTexture",
  [TextureType.subTexture]: "subTexture"
};
var knownProperties = /* @__PURE__ */ new Set([
  ...Object.keys(stylePropertyMap),
  ...Object.keys(domPropertyMap),
  // ...gradientColorPropertyMap,
  "src",
  "parent",
  "data",
  "text",
  "texture"
]);
var Inspector = class {
  constructor(canvas, settings2) {
    __publicField(this, "root", null);
    __publicField(this, "canvas", null);
    __publicField(this, "height", 1080);
    __publicField(this, "width", 1920);
    __publicField(this, "scaleX", 1);
    __publicField(this, "scaleY", 1);
    __publicField(this, "textureMetrics", /* @__PURE__ */ new Map());
    if (isProductionEnvironment)
      return;
    if (!settings2) {
      throw new Error("settings is required");
    }
    this.height = Math.ceil(settings2.appHeight ?? 1080 / (settings2.deviceLogicalPixelRatio ?? 1));
    this.width = Math.ceil(settings2.appWidth ?? 1920 / (settings2.deviceLogicalPixelRatio ?? 1));
    this.scaleX = settings2.deviceLogicalPixelRatio ?? 1;
    this.scaleY = settings2.deviceLogicalPixelRatio ?? 1;
    this.canvas = canvas;
    this.root = document.createElement("div");
    this.setRootPosition();
    document.body.appendChild(this.root);
    const mutationObserver = new MutationObserver(this.setRootPosition.bind(this));
    mutationObserver.observe(canvas, {
      attributes: true,
      childList: false,
      subtree: false
    });
    const resizeObserver = new ResizeObserver(this.setRootPosition.bind(this));
    resizeObserver.observe(canvas);
    window.addEventListener("resize", this.setRootPosition.bind(this));
    console.warn("Inspector is enabled, this will impact performance");
  }
  setRootPosition() {
    if (this.root === null || this.canvas === null) {
      return;
    }
    const rect = this.canvas.getBoundingClientRect();
    const top = document.documentElement.scrollTop + rect.top;
    const left = document.documentElement.scrollLeft + rect.left;
    this.root.id = "root";
    this.root.style.left = `${left}px`;
    this.root.style.top = `${top}px`;
    this.root.style.width = `${this.width}px`;
    this.root.style.height = `${this.height}px`;
    this.root.style.position = "absolute";
    this.root.style.transformOrigin = "0 0 0";
    this.root.style.transform = `scale(${this.scaleX}, ${this.scaleY})`;
    this.root.style.overflow = "hidden";
    this.root.style.zIndex = "65534";
  }
  createDiv(id, properties) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.id = id.toString();
    for (const key in properties) {
      this.updateNodeProperty(
        div,
        // really typescript? really?
        key,
        properties[key],
        properties
      );
    }
    return div;
  }
  createNode(node) {
    const div = this.createDiv(node.id, node.props);
    div.node = node;
    node.div = div;
    node.on("inViewport", () => div.setAttribute("state", "inViewport"));
    node.on("inBounds", () => div.setAttribute("state", "inBounds"));
    node.on("outOfBounds", () => div.setAttribute("state", "outOfBounds"));
    return this.createProxy(node, div);
  }
  createTextNode(node) {
    const div = this.createDiv(node.id, node.props);
    div.node = node;
    node.div = div;
    return this.createProxy(node, div);
  }
  createProxy(node, div) {
    const textureListeners = /* @__PURE__ */ new Map();
    const setupTextureListeners = (texture) => {
      textureListeners.forEach((listeners, oldTexture) => {
        oldTexture.off("loaded", listeners.onLoaded);
        oldTexture.off("failed", listeners.onFailed);
        oldTexture.off("freed", listeners.onFreed);
      });
      textureListeners.clear();
      if (texture) {
        if (!this.textureMetrics.has(texture)) {
          this.textureMetrics.set(texture, {
            previousState: texture.state,
            loadedCount: 0,
            failedCount: 0,
            freedCount: 0
          });
        }
        const onLoaded = () => {
          const metrics = this.textureMetrics.get(texture);
          if (metrics) {
            metrics.previousState = metrics.previousState !== texture.state ? metrics.previousState : "loading";
            metrics.loadedCount++;
          }
          this.updateTextureAttributes(div, texture);
        };
        const onFailed = () => {
          const metrics = this.textureMetrics.get(texture);
          if (metrics) {
            metrics.previousState = metrics.previousState !== texture.state ? metrics.previousState : "loading";
            metrics.failedCount++;
          }
          this.updateTextureAttributes(div, texture);
        };
        const onFreed = () => {
          const metrics = this.textureMetrics.get(texture);
          if (metrics) {
            metrics.previousState = metrics.previousState !== texture.state ? metrics.previousState : texture.state;
            metrics.freedCount++;
          }
          this.updateTextureAttributes(div, texture);
        };
        texture.on("loaded", onLoaded);
        texture.on("failed", onFailed);
        texture.on("freed", onFreed);
        textureListeners.set(texture, { onLoaded, onFailed, onFreed });
      }
    };
    knownProperties.forEach((property) => {
      let originalProp = Object.getOwnPropertyDescriptor(node, property);
      if (originalProp === void 0) {
        const proto = Object.getPrototypeOf(node);
        originalProp = Object.getOwnPropertyDescriptor(proto, property);
      }
      if (originalProp === void 0) {
        return;
      }
      Object.defineProperty(node, property, {
        get() {
          var _a2;
          return (_a2 = originalProp == null ? void 0 : originalProp.get) == null ? void 0 : _a2.call(node);
        },
        set: (value) => {
          var _a2;
          (_a2 = originalProp == null ? void 0 : originalProp.set) == null ? void 0 : _a2.call(node, value);
          this.updateNodeProperty(div, property, value, node.props);
          if (property === "texture") {
            const textureValue = value && typeof value === "object" && "state" in value ? value : null;
            setupTextureListeners(textureValue);
          }
        },
        configurable: true,
        enumerable: true
      });
    });
    const originalDestroy = node.destroy;
    Object.defineProperty(node, "destroy", {
      value: () => {
        textureListeners.forEach((listeners, texture) => {
          texture.off("loaded", listeners.onLoaded);
          texture.off("failed", listeners.onFailed);
          texture.off("freed", listeners.onFreed);
          this.textureMetrics.delete(texture);
        });
        textureListeners.clear();
        this.destroyNode(node.id);
        originalDestroy.call(node);
      }
    });
    if (node.texture) {
      setupTextureListeners(node.texture);
    }
    const originalAnimate = node.animate;
    Object.defineProperty(node, "animate", {
      value: (props, settings2) => {
        const animationController = originalAnimate.call(node, props, settings2);
        const originalStart = animationController.start.bind(animationController);
        animationController.start = () => {
          this.animateNode(div, props, settings2);
          return originalStart();
        };
        return animationController;
      }
    });
    return node;
  }
  destroyNode(id) {
    const div = document.getElementById(id.toString());
    div == null ? void 0 : div.remove();
  }
  updateTextureAttributes(div, texture) {
    div.setAttribute("data-texture-state", texture.state);
    div.setAttribute("data-texture-type", textureTypeNames[texture.type] || "unknown");
    if (texture.dimensions) {
      div.setAttribute("data-texture-width", String(texture.dimensions.width));
      div.setAttribute("data-texture-height", String(texture.dimensions.height));
    } else {
      div.removeAttribute("data-texture-width");
      div.removeAttribute("data-texture-height");
    }
    div.setAttribute("data-texture-owners", String(texture.renderableOwners.length));
    div.setAttribute("data-texture-retry-count", String(texture.retryCount));
    if (texture.maxRetryCount !== null) {
      div.setAttribute("data-texture-max-retry-count", String(texture.maxRetryCount));
    } else {
      div.removeAttribute("data-texture-max-retry-count");
    }
    const metrics = this.textureMetrics.get(texture);
    if (metrics) {
      div.setAttribute("data-texture-previous-state", metrics.previousState);
      div.setAttribute("data-texture-loaded-count", String(metrics.loadedCount));
      div.setAttribute("data-texture-failed-count", String(metrics.failedCount));
      div.setAttribute("data-texture-freed-count", String(metrics.freedCount));
    } else {
      div.removeAttribute("data-texture-previous-state");
      div.removeAttribute("data-texture-loaded-count");
      div.removeAttribute("data-texture-failed-count");
      div.removeAttribute("data-texture-freed-count");
    }
    if (texture.error) {
      div.setAttribute("data-texture-error", texture.error.code || texture.error.message);
    } else {
      div.removeAttribute("data-texture-error");
    }
  }
  updateNodeProperty(div, property, value, props) {
    var _a2;
    if (this.root === null || value === void 0 || value === null) {
      return;
    }
    if (property === "parent") {
      const parentId = value.id;
      if (parentId === 1) {
        this.root.appendChild(div);
        return;
      }
      const parent = document.getElementById(parentId.toString());
      parent == null ? void 0 : parent.appendChild(div);
      return;
    }
    if (property === "text") {
      div.innerHTML = String(value);
      div.style.opacity = "0.001";
      div.style.pointerEvents = "none";
      div.style.userSelect = "none";
      return;
    }
    if (property === "src" && value) {
      div.setAttribute(`data-src`, String(value));
      return;
    }
    if (property === "rtt" && value) {
      div.setAttribute("data-rtt", String(value));
      return;
    }
    if (property === "texture") {
      if (value && typeof value === "object" && "state" in value) {
        const texture = value;
        this.updateTextureAttributes(div, texture);
      } else {
        div.removeAttribute("data-texture-state");
        div.removeAttribute("data-texture-type");
        div.removeAttribute("data-texture-width");
        div.removeAttribute("data-texture-height");
        div.removeAttribute("data-texture-owners");
        div.removeAttribute("data-texture-error");
      }
      return;
    }
    if (stylePropertyMap[property]) {
      const mappedStyleResponse = (_a2 = stylePropertyMap[property]) == null ? void 0 : _a2.call(stylePropertyMap, value);
      if (mappedStyleResponse === null) {
        return;
      }
      if (typeof mappedStyleResponse === "string") {
        div.style.setProperty(mappedStyleResponse, String(value));
        return;
      }
      if (typeof mappedStyleResponse === "object") {
        let value2 = mappedStyleResponse.value;
        if (property === "x") {
          const mount = props.mountX;
          const width = props.width;
          if (mount) {
            value2 = `${parseInt(value2) - width * mount}px`;
          }
        } else if (property === "y") {
          const mount = props.mountY;
          const height = props.height;
          if (mount) {
            value2 = `${parseInt(value2) - height * mount}px`;
          }
        }
        div.style.setProperty(mappedStyleResponse.prop, value2);
      }
      return;
    }
    if (domPropertyMap[property]) {
      const domProperty = domPropertyMap[property];
      if (!domProperty) {
        return;
      }
      div.setAttribute(String(domProperty), String(value));
      return;
    }
    if (property === "data") {
      for (const key in value) {
        const keyValue = value[key];
        if (keyValue === void 0) {
          div.removeAttribute(`data-${key}`);
        } else {
          div.setAttribute(`data-${key}`, String(keyValue));
        }
      }
      return;
    }
  }
  // simple animation handler
  animateNode(div, props, settings2) {
    const {
      duration = 1e3,
      delay = 0
      // easing = 'linear',
      // repeat = 0,
      // loop = false,
      // stopMethod = false,
    } = settings2;
    const { x, y, width, height, alpha = 1, rotation = 0, scale = 1, color, mountX, mountY } = props;
    function animate() {
      setTimeout(() => {
        div.style.top = `${y - height * mountY}px`;
        div.style.left = `${x - width * mountX}px`;
        div.style.width = `${width}px`;
        div.style.height = `${height}px`;
        div.style.opacity = `${alpha}`;
        div.style.rotate = `${rotation}rad`;
        div.style.scale = `${scale}`;
        div.style.color = convertColorToRgba(color);
      }, duration);
    }
    setTimeout(animate, delay);
  }
};

// node_modules/@lightningjs/blits/src/constants.js
var DEFAULT_HOLD_TIMEOUT_MS = 50;
var DEFAULT_KEYMAP = {
  ArrowLeft: "left",
  ArrowRight: "right",
  ArrowUp: "up",
  ArrowDown: "down",
  Enter: "enter",
  " ": "space",
  Backspace: "back",
  Escape: "escape",
  37: "left",
  39: "right",
  38: "up",
  40: "down",
  13: "enter",
  32: "space",
  8: "back",
  27: "escape"
};
var SCREEN_RESOLUTIONS = {
  hd: 0.66666667,
  "720p": 0.66666667,
  720: 0.66666667,
  fhd: 1,
  fullhd: 1,
  "1080p": 1,
  1080: 1,
  "4k": 2,
  "2160p": 2,
  2160: 2
};
var RENDER_QUALITIES = {
  low: 0.66666667,
  medium: 0.85,
  high: 1,
  retina: 2
};

// node_modules/@lightningjs/blits/src/engines/L3/fontLoader.js
var fontLoader_default = () => {
  const stage2 = renderer.stage;
  settings_default.get("fonts", []).forEach((font) => {
    if (font.type === "sdf" || font.type === "msdf") {
      if (!font.png && font.file) {
        font.png = font.file.replace(/\.[^.]+$/, `.${font.type}.png`);
      }
      if (!font.json && font.file) {
        font.json = font.file.replace(/\.[^.]+$/, `.${font.type}.json`);
      }
      stage2.fontManager.addFontFace(
        new SdfTrFontFace(font.type, {
          fontFamily: font.family,
          descriptors: {},
          atlasUrl: font.png,
          atlasDataUrl: font.json,
          stage: stage2,
          metrics: font.metrics
        })
      );
    } else if (font.type === "web") {
      stage2.fontManager.addFontFace(
        new WebTrFontFace({
          fontFamily: font.family,
          fontUrl: font.file,
          descriptors: {},
          metrics: font.metrics
        })
      );
    }
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/shaderLoader.js
var shaderLoader_default = () => {
  const stage2 = renderer.stage;
  settings_default.get("shaders", []).forEach((shader) => {
    stage2.shManager.registerShaderType(shader.name, shader.type);
  });
  settings_default.get("effects", []).forEach((effect2) => {
    stage2.shManager.registerShaderType(effect2.name, effect2.type);
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/launch.js
var renderer = {};
var renderEngine = (settings2) => {
  const renderMode = "renderMode" in settings2 ? settings2.renderMode : "webgl";
  if (renderMode === "webgl") return WebGlCoreRenderer;
  if (renderMode === "canvas") return CanvasCoreRenderer;
};
var textRenderEngines = (settings2) => {
  const renderMode = "renderMode" in settings2 ? settings2.renderMode : "webgl";
  if (renderMode === "webgl") return [SdfTextRenderer, CanvasTextRenderer];
  if (renderMode === "canvas") return [CanvasTextRenderer];
};
var textureMemorySettings = (settings2) => {
  const gpuMemory = {
    ...{
      max: 200,
      target: 0.8,
      cleanupInterval: 5e3,
      baseline: 25,
      strict: false
    },
    ..."gpuMemory" in settings2 === true ? settings2.gpuMemory : {}
  };
  return {
    criticalThreshold: gpuMemory.max * 1024 * 1024,
    // convert from mb to bytes
    targetThresholdLevel: gpuMemory.target,
    cleanupInterval: gpuMemory.cleanupInterval,
    baselineMemoryAllocation: gpuMemory.baseline * 1024 * 1024,
    // convert from mb to bytes
    doNotExceedCriticalThreshold: gpuMemory.strict
  };
};
var launch_default = (App, target, settings2 = {}) => {
  renderer = new RendererMain(
    {
      ...{
        appWidth: settings2.w || 1920,
        appHeight: settings2.h || 1080,
        fpsUpdateInterval: settings2.fpsInterval || 1e3,
        devicePhysicalPixelRatio: RENDER_QUALITIES[settings2.renderQuality] || settings2.renderQuality || 1,
        deviceLogicalPixelRatio: settings2.pixelRatio || SCREEN_RESOLUTIONS[settings2.screenResolution] || SCREEN_RESOLUTIONS[window.innerHeight] || 1,
        numImageWorkers: "webWorkersLimit" in settings2 ? settings2.webWorkersLimit : window.navigator.hardwareConcurrency || 2,
        clearColor: settings2.canvasColor && colors_default.normalize(settings2.canvasColor) || 0,
        inspector: settings2.inspector === true ? Inspector : void 0,
        boundsMargin: settings2.viewportMargin || 0,
        renderEngine: renderEngine(settings2),
        fontEngines: textRenderEngines(settings2),
        canvas: settings2.canvas,
        textureProcessingTimeLimit: settings2.textureProcessingTimeLimit,
        textureMemory: textureMemorySettings(settings2),
        createImageBitmapSupport: "auto",
        targetFPS: "maxFPS" in settings2 ? settings2.maxFPS : 0
      },
      ...settings2.advanced || {}
    },
    target
  );
  const initApp = () => {
    let app = App();
    app.quit = () => {
      Log.info("Closing App");
      app.destroy();
      app = null;
      renderer = null;
    };
  };
  shaderLoader_default();
  fontLoader_default();
  initApp();
  return renderer;
};

// node_modules/@lightningjs/blits/src/engines/L3/element.js
var createPaddingObject = (padding, direction) => {
  if (padding === void 0) {
    return { start: 0, end: 0, oppositeStart: 0, oppositeEnd: 0 };
  }
  if (typeof padding === "number") {
    return { start: padding, end: padding, oppositeStart: padding, oppositeEnd: padding };
  }
  if (isObjectString(padding) === true) {
    padding = parseToObject(padding);
  }
  if (typeof padding === "object") {
    const {
      top = void 0,
      right = void 0,
      bottom = void 0,
      left = void 0,
      x = 0,
      y = 0
    } = padding;
    return direction === "vertical" ? {
      start: top !== void 0 ? top : y,
      end: bottom !== void 0 ? bottom : y,
      oppositeStart: left !== void 0 ? left : x,
      oppositeEnd: right !== void 0 ? right : x
    } : {
      start: left !== void 0 ? left : x,
      end: right !== void 0 ? right : x,
      oppositeStart: top !== void 0 ? top : y,
      oppositeEnd: bottom !== void 0 ? bottom : y
    };
  }
  return { start: 0, end: 0, oppositeStart: 0, oppositeEnd: 0 };
};
var layoutFn = function(config) {
  const position = config.direction === "vertical" ? "y" : "x";
  const oppositePosition = config.direction === "vertical" ? "x" : "y";
  const oppositeMount = config.direction === "vertical" ? "mountX" : "mountY";
  const dimension = config.direction === "vertical" ? "height" : "width";
  const oppositeDimension = config.direction === "vertical" ? "width" : "height";
  const padding = createPaddingObject(config.padding, config.direction);
  let offset = padding.start;
  const children = this.node.children;
  const childrenLength = children.length;
  const elementChildren = this.children;
  let otherDimension = 0;
  const gap = config.gap || 0;
  for (let i = 0; i < childrenLength; i++) {
    if (elementChildren[i] !== void 0 && elementChildren[i].props.raw.show === false) {
      continue;
    }
    const node = children[i];
    node[position] = offset;
    node[oppositePosition] = padding.oppositeStart;
    if (dimension === "width") {
      offset += node.width + (node.width !== ("text" in node ? 1 : 0) ? gap : 0);
    } else {
      offset += "text" in node ? node.width > 1 ? node.height + gap : 0 : node.height !== 0 ? node.height + gap : 0;
    }
    otherDimension = Math.max(
      otherDimension,
      node[oppositeDimension] + padding.oppositeStart + padding.oppositeEnd
    );
  }
  this.node[dimension] = offset - gap + padding.end;
  this.node[oppositeDimension] = otherDimension;
  const align = {
    start: 0,
    end: 1,
    center: 0.5
  }[config["align-items"] || "start"];
  if (align !== 0) {
    for (let i = 0; i < childrenLength; i++) {
      const node = children[i];
      node[oppositePosition] = otherDimension * align;
      node[oppositeMount] = align;
    }
  }
  if (config["@updated"] !== void 0) {
    config["@updated"]({ w: this.node.width, h: this.node.height }, this);
  }
  if (this.config.parent && this.config.parent.props.__layout === true) {
    this.config.parent.triggerLayout(this.config.parent.props);
  }
};
var isTransition = (value) => {
  return value !== null && typeof value === "object" && "transition" in value === true;
};
var isObjectString = (str) => {
  return typeof str === "string" && str.startsWith("{") && str.endsWith("}");
};
var parseToObject = (str) => {
  return JSON.parse(str.replace(/'/g, '"').replace(/([{,]\s*)([\w-_]+)(\s*:)/g, '$1"$2"$3'));
};
var parsePercentage = function(v, base) {
  if (typeof v !== "string") {
    return v;
  } else if (v.indexOf("%") === v.length - 1) {
    return this.element.config.parent && (this.element.config.parent.node[base] || 0) * (parseFloat(v) / 100) || 0;
  }
  return v;
};
var unpackTransition = (v) => {
  if (typeof v !== "object" || v === null) return v;
  if (v.constructor === Object) {
    if ("value" in v === true) {
      return v.value;
    }
    if ("transition" in v === true) {
      return unpackTransition(v.transition);
    }
  }
  return v;
};
var colorMap = {
  top: "colorTop",
  bottom: "colorBottom",
  left: "colorLeft",
  right: "colorRight"
};
var textDefaults = null;
var inspectorEnabled = null;
var propsTransformer = {
  set parent(v) {
    this.props["parent"] = v === "root" ? renderer.root : v.node;
  },
  set rotation(v) {
    this.props["rotation"] = v * (Math.PI / 180);
  },
  set w(v) {
    this.props["width"] = parsePercentage.call(this, v, "width");
  },
  set width(v) {
    this.props["width"] = parsePercentage.call(this, v, "width");
  },
  set h(v) {
    this.props["height"] = parsePercentage.call(this, v, "height");
  },
  set height(v) {
    this.props["height"] = parsePercentage.call(this, v, "height");
  },
  set x(v) {
    this.props["x"] = parsePercentage.call(this, v, "width");
  },
  set y(v) {
    this.props["y"] = parsePercentage.call(this, v, "height");
  },
  set z(v) {
    this.props["zIndex"] = v;
  },
  set zIndex(v) {
    this.props["zIndex"] = v;
  },
  set color(v) {
    if (typeof v === "string" && v.startsWith("{") === false) {
      this.props["color"] = colors_default.normalize(v);
    } else if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      this.props["color"] = 0;
      Object.entries(v).forEach((color) => {
        this.props[colorMap[color[0]]] = colors_default.normalize(color[1]);
      });
    }
  },
  set src(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      this.props["src"] = v.src;
      this.props["imageType"] = v.type;
    } else {
      this.props["src"] = v;
    }
    if (this.raw["color"] === void 0) {
      this.props["color"] = this.props["src"] ? 4294967295 : 0;
    }
    if (!("w" in this.raw) && !("w" in this.raw) && !("h" in this.raw) && !("height" in this.raw)) {
      this.props["autosize"] = true;
    }
  },
  set texture(v) {
    this.props["texture"] = v;
    if (this.raw["color"] === void 0 && (v === null || v === void 0)) {
      this.props["color"] = 0;
    } else if (this.raw["color"] === void 0) {
      this.props["color"] = 4294967295;
    }
  },
  set fit(v) {
    const resizeMode = {};
    if (v === "cover" || v === "contain") {
      this.props["textureOptions"] = { resizeMode: { type: v } };
      return;
    }
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      resizeMode["type"] = v.type || "cover";
      if (typeof v.position === "number") {
        resizeMode["clipY"] = resizeMode["clipX"] = v.position;
      }
      if (typeof v.position === "object") {
        resizeMode["clipX"] = "x" in v.position === true ? v.position.x : null;
        resizeMode["clipY"] = "y" in v.position === true ? v.position.y : null;
      }
      this.props["textureOptions"] = { resizeMode };
    }
  },
  set rtt(v) {
    this.props["rtt"] = v;
    if (this.raw["color"] === void 0) {
      this.props["color"] = v === true ? 4294967295 : 0;
    }
  },
  set mount(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["mountX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["mountY"] = v.y;
      }
    } else {
      this.props["mountX"] = v;
      this.props["mountY"] = v;
    }
  },
  set pivot(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["pivotX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["pivotY"] = v.y;
      }
    } else {
      this.props["pivotX"] = v;
      this.props["pivotY"] = v;
    }
  },
  set scale(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["scaleX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["scaleY"] = v.y;
      }
    } else {
      this.props["scaleX"] = v;
      this.props["scaleY"] = v;
    }
  },
  set show(v) {
    if (v) {
      this.props["alpha"] = this.raw["alpha"] !== void 0 ? this.raw["alpha"] : 1;
    } else {
      this.props["alpha"] = 0;
    }
  },
  set alpha(v) {
    if (this.raw["show"] === void 0 || this.raw["show"] == true) {
      this.props["alpha"] = v;
    }
  },
  set shader(v) {
    const target = this.element.node !== void 0 ? this.element.node : this.props;
    if (v === null) {
      target["shader"] = null;
      return;
    }
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if (target.shader !== void 0 && target.shader.type === v.type) {
        for (const prop in v.props) {
          target.shader.props[prop] = v.props[prop];
        }
        return;
      }
      target["shader"] = renderer.createShader(v.type, v.props);
    }
  },
  set effects(v) {
    for (let i = 0; i < v.length; i++) {
      if (v[i].props && v[i].props.color) {
        v[i].props.color = colors_default.normalize(v[i].props.color);
      }
    }
    if (this.element.node === void 0) {
      this.props["shader"] = renderer.createShader("DynamicShader", {
        effects: v.map((effect2) => {
          return renderer.createEffect(effect2.type, effect2.props);
        })
      });
    }
  },
  set clipping(v) {
    this.props["clipping"] = v;
  },
  set overflow(v) {
    this.props["clipping"] = !!!v;
  },
  set font(v) {
    this.props["fontFamily"] = v;
  },
  set size(v) {
    this.props["fontSize"] = v;
  },
  set wordwrap(v) {
    Log.warn("The wordwrap attribute is deprecated, use maxwidth instead");
    this.props["width"] = v;
    this.props["contain"] = "width";
  },
  set maxwidth(v) {
    this.props["width"] = v;
    this.props["contain"] = "width";
  },
  set maxheight(v) {
    this.props["height"] = v;
    this.props["contain"] = "both";
  },
  set contain(v) {
    this.props["contain"] = v;
  },
  set maxlines(v) {
    this.props["maxLines"] = v;
  },
  set textoverflow(v) {
    this.props["overflowSuffix"] = v === false ? " " : v === true ? void 0 : v;
  },
  set letterspacing(v) {
    this.props["letterSpacing"] = v || 1;
  },
  set lineheight(v) {
    this.props["lineHeight"] = v;
  },
  set align(v) {
    this.props["textAlign"] = v;
  },
  set content(v) {
    this.props["text"] = "" + v;
  },
  set placement(v) {
    let x, y;
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        x = v.x;
      }
      if ("y" in v === true) {
        y = v.y;
      }
    } else {
      v === "center" || v === "right" ? x = v : y = v;
    }
    if (x === "center") {
      this.x = "50%";
      this.props["mountX"] = 0.5;
    } else if (x === "right") {
      this.x = "100%";
      this.props["mountX"] = 1;
    }
    if (y === "middle") {
      this.y = "50%";
      this.props["mountY"] = 0.5;
    } else if (y === "bottom") {
      this.y = "100%";
      this.props["mountY"] = 1;
    }
  },
  set "inspector-data"(v) {
    if (inspectorEnabled === false) {
      return;
    }
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      this.props["data"] = v;
    }
  }
};
var Element = {
  /**
   * Populates the element with data
   * @param {import('../../component.js').BlitsElementProps} data
   */
  populate(data) {
    const props = data;
    props["node"] = this.config.node;
    if (props[symbols_default.isSlot] === true) {
      this[symbols_default.isSlot] = true;
    }
    this.props.element = this;
    this.props["parent"] = props["parent"] || this.config.parent;
    delete props.parent;
    this.props.raw = data;
    const propKeys = Object.keys(props);
    const length = propKeys.length;
    for (let i = 0; i < length; i++) {
      const key = propKeys[i];
      const value = props[key];
      if (value !== void 0) {
        this.props[key] = unpackTransition(value);
      }
    }
    if (this.props.props["color"] === void 0 && "__textnode" in props === false) {
      this.props.props["color"] = 0;
    }
    this.node = props.__textnode ? renderer.createTextNode({ ...textDefaults, ...this.props.props }) : renderer.createNode(this.props.props);
    if (props["@loaded"] !== void 0 && typeof props["@loaded"] === "function") {
      this.node.on("loaded", (el, { type, dimensions }) => {
        props["@loaded"]({ w: dimensions.width, h: dimensions.height, type }, this);
      });
    }
    if (props["@error"] !== void 0 && typeof props["@error"] === "function") {
      this.node.on("failed", (el, error) => {
        props["@error"](error, this);
      });
    }
    if (props.__layout === true) {
      this.triggerLayout = layoutFn.bind(this);
    }
    if (this.config.parent.props !== void 0 && this.config.parent.props.__layout === true) {
      this.config.parent.triggerLayout(this.config.parent.props);
      this.node.on("loaded", () => {
        this.config.parent.triggerLayout(this.config.parent.props);
      });
    }
  },
  /**
   * Set an individual property on the node
   *
   * @this {import('../../component').BlitsElement} this
   *
   * @param {import('../..//component.js').BlitsElementProps} prop
   * @param {any} value
   * @returns {void}
   */
  set(prop, value) {
    if (value === void 0) return;
    if (this.props.raw[prop] === value) return;
    this.props.raw[prop] = value;
    this.props.props = {};
    this.props[prop] = unpackTransition(value);
    const propsKeys = Object.keys(this.props.props);
    if (propsKeys.length === 1) {
      if (isTransition(value) === true) {
        return this.animate(propsKeys[0], this.props.props[propsKeys[0]], value.transition);
      }
      this.node[propsKeys[0]] = this.props.props[propsKeys[0]];
    } else {
      for (let i = 0; i < propsKeys.length; i++) {
        if (isTransition(value) === true) {
          this.animate(propsKeys[i], this.props.props[propsKeys[i]], value.transition);
        } else {
          this.node[propsKeys[i]] = this.props.props[propsKeys[i]];
        }
      }
    }
    if (this.config.parent.props && this.config.parent.props.__layout === true) {
      this.config.parent.triggerLayout(this.config.parent.props);
    }
  },
  animate(prop, value, transition) {
    if (this.scheduledTransitions[prop] !== void 0 && this.scheduledTransitions[prop].f.state === "scheduled") {
      this.scheduledTransitions[prop].f.stop();
    }
    if (this.node[prop] === value) return;
    const props = {};
    props[prop] = value;
    const f = this.node.animate(props, {
      duration: typeof transition === "object" ? "duration" in transition ? transition.duration : 300 : 300,
      easing: typeof transition === "object" ? "easing" in transition ? transition.easing : "ease" : "ease",
      delay: typeof transition === "object" ? "delay" in transition ? transition.delay : 0 : 0
    });
    const startValue = this.node[prop];
    this.scheduledTransitions[prop] = {
      v: props[prop],
      f
    };
    if (transition.start !== void 0 && typeof transition.start === "function") {
      f.once("animating", () => {
        transition.start.call(this.component, this, prop, startValue);
      });
    }
    if (this.config.parent.props && this.config.parent.props.__layout === true) {
      f.on("tick", () => {
        this.config.parent.triggerLayout(this.config.parent.props);
      });
    }
    if (transition.progress !== void 0 && typeof transition.progress === "function") {
      let prevProgress = 0;
      f.on("tick", (_node, { progress }) => {
        transition.progress.call(this.component, this, prop, progress, prevProgress);
        prevProgress = progress;
      });
    }
    f.once("stopped", () => {
      if (this.scheduledTransitions[prop] !== void 0 && this.scheduledTransitions[prop].canceled === true) {
        return;
      }
      if (this.node !== void 0 && transition.end && typeof transition.end === "function") {
        transition.end.call(this.component, this, prop, this.node[prop]);
      }
      delete this.scheduledTransitions[prop];
    });
    f.start();
  },
  destroy() {
    if (this.node === null) return;
    Log.debug("Deleting Node", this.nodeId);
    const transitionProps = Object.keys(this.scheduledTransitions);
    for (let i = 0; i < transitionProps.length; i++) {
      const transition = this.scheduledTransitions[transitionProps[i]];
      if (transition !== void 0) {
        transition.canceled = true;
        if (transition.f !== void 0) transition.f.stop();
      }
    }
    this.scheduledTransitions = {};
    this.component = null;
    delete this.component;
    this.config = null;
    delete this.config;
    this.props.raw = {};
    this.props.element = null;
    this.props.props = null;
    this.props = {};
    delete this.props;
    this.triggerLayout = null;
    delete this.triggerLayout;
    this.forComponent = null;
    delete this.forComponent;
    this.node.destroy();
    this.node = null;
  },
  get nodeId() {
    return this.node && this.node.id;
  },
  get ref() {
    return this.props.ref || null;
  },
  get parent() {
    return this.node && this.node.parent;
  },
  get children() {
    const allChildren = this.component[symbols_default.getChildren]();
    const directChildren = [];
    const l = allChildren.length;
    for (let i = 0; i < l; i++) {
      const child = allChildren[i];
      if (child !== void 0 && child.parent === (this[symbols_default.isSlot] ? this.node.children[0] : this.node)) {
        directChildren.push(child);
      }
    }
    return directChildren;
  }
};
var element_default = (config, component) => {
  if (textDefaults === null) {
    textDefaults = {
      fontSize: 32,
      fontFamily: settings_default.get("defaultFont", "sans-serif")
    };
  }
  if (inspectorEnabled === null) {
    inspectorEnabled = settings_default.get("inspector", false);
  }
  return Object.assign(Object.create(Element), {
    props: Object.assign(Object.create(propsTransformer), { props: {} }),
    scheduledTransitions: {},
    config,
    component
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/index.js
var L3_default = {
  Element: element_default,
  Launch: launch_default
};

// node_modules/@lightningjs/blits/package.json
var package_default = {
  name: "@lightningjs/blits",
  version: "1.45.2",
  description: "Blits: The Lightning 3 App Development Framework",
  bin: "bin/index.js",
  exports: {
    ".": "./index.js",
    "./vite": "./vite/index.js",
    "./transitions": "./src/router/transitions/index.js",
    "./precompiler": "./src/lib/precompiler/precompiler.js",
    "./plugins": {
      types: "./src/plugins/index.d.ts",
      default: "./src/plugins/index.js"
    },
    "./plugins/language": {
      types: "./src/plugins/language.d.ts",
      default: "./src/plugins/language.js"
    },
    "./plugins/theme": {
      types: "./src/plugins/theme.d.ts",
      default: "./src/plugins/theme.js"
    },
    "./plugins/appstate": {
      types: "./src/plugins/appstate.d.ts",
      default: "./src/plugins/appstate.js"
    },
    "./plugins/storage": {
      types: "./src/plugins/storage/storage.d.ts",
      default: "./src/plugins/storage/storage.js"
    },
    "./symbols": "./src/lib/symbols.js",
    "./blitsFileConverter": "./src/lib/blitsfileconverter/blitsfileconverter.js"
  },
  scripts: {
    test: "c8 node scripts/runTests.js",
    "test:ci": "c8 npm run test:run",
    "test:run": "node -r global-jsdom/register ./node_modules/.bin/tape '{,!(node_modules|packages)/**/}*.test.js' | tap-diff",
    lint: "node scripts/lint.js",
    "lint:fix": "node scripts/lint.js fix",
    prepublishOnly: "node scripts/prepublishOnly.js",
    postpublish: "node scripts/postpublish.js",
    prepare: "husky",
    "pack-preview": "npm pack --dry-run",
    release: "npm publish --access public"
  },
  types: "./index.d.ts",
  "lint-staged": {
    "*.js": [
      "eslint --fix"
    ]
  },
  type: "module",
  author: "Michiel van der Geest <hello@michielvandergeest.com>",
  license: "Apache-2.0",
  devDependencies: {
    "@babel/eslint-parser": "^7.26.5",
    "@babel/plugin-syntax-import-assertions": "^7.26.0",
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.33.0",
    c8: "^9.1.0",
    eslint: "^9.33.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "fast-glob": "^3.3.3",
    "global-jsdom": "24.0.0",
    globals: "^16.3.0",
    husky: "^9.1.7",
    jsdom: "24.0.0",
    "lint-staged": "^15.5.0",
    prettier: "^3.6.2",
    sinon: "^21.0.0",
    "tap-diff": "^0.1.1",
    tape: "^5.5.0"
  },
  dependencies: {
    "@lightningjs/msdf-generator": "^1.2.0",
    "@lightningjs/renderer": "^2.20.2",
    "magic-string": "^0.30.21"
  },
  repository: {
    type: "git",
    url: "https://github.com/lightning-js/blits.git"
  }
};

// node_modules/@lightningjs/blits/src/launch.js
var renderer2 = {};
var stage = {};
async function rendererVersion() {
  let rendererPackageInfo;
  try {
    rendererPackageInfo = await import("./package-HDNFHN43.js");
    if (rendererPackageInfo !== void 0) {
      return rendererPackageInfo.version;
    }
  } catch (e) {
    return package_default.dependencies["@lightningjs/renderer"];
  }
}
var launch_default2 = (App, target, settings2) => {
  settings_default.set(settings2);
  initLog();
  rendererVersion().then((v) => {
    Log.info("Blits Version ", package_default.version);
    Log.info("Renderer Version ", v);
  });
  stage.element = L3_default.Element;
  renderer2 = L3_default.Launch(App, target, settings2);
};

// node_modules/@lightningjs/blits/src/router/transitions/fadeInOut.js
var fadeInOut_default = {
  before: {
    prop: "alpha",
    value: 0
  },
  in: {
    prop: "alpha",
    value: 1,
    duration: 200
  },
  out: {
    prop: "alpha",
    value: 0,
    duration: 100
  }
};

// node_modules/@lightningjs/blits/src/announcer/speechSynthesis.js
var syn = window.speechSynthesis;
var isAndroid = /android/i.test((window.navigator || {}).userAgent || "");
var utterances = /* @__PURE__ */ new Map();
var initialized = false;
var infinityTimer = null;
var clear = () => {
  if (infinityTimer) {
    clearTimeout(infinityTimer);
    infinityTimer = null;
  }
};
var resumeInfinity = (target) => {
  if (!target || infinityTimer) {
    return clear();
  }
  syn.pause();
  setTimeout(() => {
    syn.resume();
  }, 0);
  infinityTimer = setTimeout(() => {
    resumeInfinity(target);
  }, 5e3);
};
var defaultUtteranceProps = {
  lang: "en-US",
  pitch: 1,
  rate: 1,
  voice: null,
  volume: 1
};
var initialize = () => {
  const voices = syn.getVoices();
  defaultUtteranceProps.voice = voices[0] || null;
  initialized = true;
};
var speak = (options) => {
  const utterance = new SpeechSynthesisUtterance(options.message);
  const id = options.id;
  utterance.lang = options.lang || defaultUtteranceProps.lang;
  utterance.pitch = options.pitch || defaultUtteranceProps.pitch;
  utterance.rate = options.rate || defaultUtteranceProps.rate;
  utterance.voice = options.voice || defaultUtteranceProps.voice;
  utterance.volume = options.volume || defaultUtteranceProps.volume;
  utterances.set(id, utterance);
  if (isAndroid === false) {
    utterance.onstart = () => {
      resumeInfinity(utterance);
    };
    utterance.onresume = () => {
      resumeInfinity(utterance);
    };
  }
  return new Promise((resolve, reject) => {
    utterance.onend = () => {
      clear();
      utterances.delete(id);
      resolve();
    };
    utterance.onerror = (e) => {
      clear();
      utterances.delete(id);
      reject(e);
    };
    syn.speak(utterance);
  });
};
var speechSynthesis_default = {
  speak(options) {
    if (syn !== void 0) {
      if (initialized === false) {
        initialize();
      }
      return speak(options);
    } else {
      Log.error("speechSynthesis web API not available");
      return Promise.reject({ error: "unavailable" });
    }
  },
  cancel() {
    if (syn !== void 0) {
      syn.cancel();
      clear();
    }
  }
  // @todo
  // getVoices() {
  //   return syn.getVoices()
  // },
};

// node_modules/@lightningjs/blits/src/announcer/announcer.js
var active = false;
var count = 0;
var queue = [];
var isProcessing = false;
var currentId = null;
var debounce = null;
var globalDefaultOptions = {};
var noopAnnouncement = {
  then() {
  },
  done() {
  },
  cancel() {
  },
  remove() {
  },
  stop() {
  }
};
var enable = () => {
  active = true;
};
var disable = () => {
  active = false;
};
var toggle = (v) => {
  active = v ? true : false;
};
var speak2 = (message, politeness = "off", options = {}) => {
  if (active === false) return noopAnnouncement;
  return addToQueue(message, politeness, false, options);
};
var pause = (delay) => {
  if (active === false) return noopAnnouncement;
  return addToQueue(void 0, void 0, delay);
};
var addToQueue = (message, politeness, delay = false, options = {}) => {
  const id = count++;
  let resolveFn;
  const done = new Promise((resolve) => {
    resolveFn = resolve;
  });
  done.remove = done.cancel = () => {
    const index = queue.findIndex((item) => item.id === id);
    if (index !== -1) queue.splice(index, 1);
    Log.debug(`Announcer - removed from queue: "${message}" (id: ${id})`);
    resolveFn("canceled");
  };
  done.stop = () => {
    if (id === currentId) {
      speechSynthesis_default.cancel();
      isProcessing = false;
      resolveFn("interupted");
    }
  };
  if (delay === false) {
    politeness === "assertive" ? queue.unshift({ message, resolveFn, id, options }) : queue.push({ message, resolveFn, id, options });
  } else {
    queue.push({ delay, resolveFn, id });
  }
  Log.debug(`Announcer - added to queue: "${message}" (id: ${id})`);
  setTimeout(() => {
    processQueue();
  }, 100);
  return done;
};
var processQueue = async () => {
  if (isProcessing === true || queue.length === 0) return;
  isProcessing = true;
  const { message, resolveFn, delay, id, options = {} } = queue.shift();
  currentId = id;
  if (delay) {
    setTimeout(() => {
      isProcessing = false;
      currentId = null;
      resolveFn("finished");
      processQueue();
    }, delay);
  } else {
    if (debounce !== null) clearTimeout(debounce);
    debounce = setTimeout(() => {
      Log.debug(`Announcer - speaking: "${message}" (id: ${id})`);
      speechSynthesis_default.speak({
        message,
        id,
        ...globalDefaultOptions,
        ...options
      }).then(() => {
        Log.debug(`Announcer - finished speaking: "${message}" (id: ${id})`);
        currentId = null;
        isProcessing = false;
        resolveFn("finished");
        processQueue();
      }).catch((e) => {
        currentId = null;
        isProcessing = false;
        Log.debug(`Announcer - error ("${e.error}") while speaking: "${message}" (id: ${id})`);
        resolveFn(e.error);
        processQueue();
      });
      debounce = null;
    }, 200);
  }
};
var polite = (message, options = {}) => speak2(message, "polite", options);
var assertive = (message, options = {}) => speak2(message, "assertive", options);
var stop = () => {
  speechSynthesis_default.cancel();
};
var clear2 = () => {
  isProcessing = false;
  queue.length = 0;
};
var configure = (options = {}) => {
  globalDefaultOptions = { ...globalDefaultOptions, ...options };
};
var announcer_default = {
  speak: speak2,
  polite,
  assertive,
  stop,
  enable,
  disable,
  toggle,
  clear: clear2,
  pause,
  configure
};

// node_modules/@lightningjs/blits/src/router/router.js
var currentRoute;
var state = reactive(
  {
    path: "",
    navigating: false,
    data: null,
    params: null,
    hash: ""
  },
  settings_default.get("reactivityMode"),
  true
);
var history = [];
var overrideOptions = {};
var navigationData = {};
var navigatingBack = false;
var navigatingBackTo = void 0;
var previousFocus;
var preventHashChangeNavigation = false;
var getHash = (hash) => {
  if (!hash) hash = "/";
  const hashParts = hash.replace(/^#/, "").split("?");
  return {
    path: hashParts[0],
    queryParams: new URLSearchParams(hashParts[1]),
    hash
  };
};
var normalizePath = (path) => {
  return path.replace(/^\/+|\/+$/g, "").toLowerCase();
};
var isObject = (v) => typeof v === "object" && v !== null;
var isString = (v) => typeof v === "string";
var queryParamsToObject = (queryParams) => {
  if (!queryParams) return {};
  const object = {};
  const queryParamsEntries = [...queryParams.entries()];
  for (let i = 0; i < queryParamsEntries.length; i++) {
    object[queryParamsEntries[i][0]] = queryParamsEntries[i][1];
  }
  return object;
};
var matchHash = ({ hash, path, queryParams }, routes = []) => {
  const originalPath = path.replace(/^\/+|\/+$/g, "");
  const originalNormalizedPath = normalizePath(path);
  const override = {
    hash,
    queryParams: queryParamsToObject(queryParams),
    path
  };
  let matchingRoute = false;
  let i = 0;
  while (!matchingRoute && i < routes.length) {
    const route = routes[i];
    const normalizedPath = normalizePath(route.path);
    if (normalizePath(normalizedPath) === originalNormalizedPath) {
      matchingRoute = makeRouteObject(route, override);
    } else if (normalizedPath.indexOf(":") > -1) {
      const dynamicRouteParts = [...normalizedPath.matchAll(/:([^\s/]+)/gi)];
      let dynamicRoutePartsRegex = normalizedPath;
      dynamicRouteParts.reverse().forEach((part) => {
        dynamicRoutePartsRegex = dynamicRoutePartsRegex.substring(0, part.index) + "([^\\s/]+)" + dynamicRoutePartsRegex.substring(part.index + part[0].length);
      });
      dynamicRoutePartsRegex = "^" + dynamicRoutePartsRegex;
      const match = originalPath.match(new RegExp(`${dynamicRoutePartsRegex}`, "i"));
      if (match) {
        override.params = dynamicRouteParts.reverse().reduce((acc, part, index) => {
          acc[part[1]] = match[index + 1];
          return acc;
        }, {});
        matchingRoute = makeRouteObject(route, override);
      }
    } else if (normalizedPath.endsWith("*")) {
      const regex = new RegExp(normalizedPath.replace(/\/?\*/, "/?([^\\s]*)"), "i");
      const match = originalNormalizedPath.match(regex);
      if (match) {
        override.params = {};
        if (match[1]) override.params.path = match[1];
        matchingRoute = makeRouteObject(route, override);
      }
    }
    i++;
  }
  return matchingRoute;
};
var defaultOptions = {
  inHistory: true,
  keepAlive: false,
  passFocus: true,
  reuseComponent: false
};
var makeRouteObject = (route, overrides) => {
  const cleanRoute = {
    hash: overrides.hash,
    path: route.path,
    component: route.component,
    transition: "transition" in route ? route.transition : fadeInOut_default,
    options: { ...defaultOptions, ...route.options, ...overrideOptions },
    announce: route.announce || false,
    hooks: route.hooks || {},
    data: { ...route.data, ...navigationData, ...overrides.queryParams },
    params: overrides.params || {},
    meta: route.meta || {}
  };
  return cleanRoute;
};
var navigate = async function() {
  announcer_default.stop();
  announcer_default.clear();
  state.navigating = true;
  let reuse = false;
  if (preventHashChangeNavigation === false && this.parent[symbols_default.routes]) {
    let previousRoute = currentRoute;
    let route = matchHash(getHash(document.location.hash), this.parent[symbols_default.routes]);
    currentRoute = route;
    if (route) {
      const currentPath = currentRoute.path;
      let beforeEachResult;
      if (this.parent[symbols_default.routerHooks]) {
        const hooks = this.parent[symbols_default.routerHooks];
        if (hooks.beforeEach) {
          try {
            beforeEachResult = await hooks.beforeEach.call(this.parent, route, previousRoute);
            if (isString(beforeEachResult)) {
              currentRoute = previousRoute;
              to(beforeEachResult);
              return;
            }
          } catch (error) {
            Log.error('Error or Rejected Promise in "BeforeEach" Hook', error);
            if (history.length > 0) {
              preventHashChangeNavigation = true;
              currentRoute = previousRoute;
              window.history.back();
              navigatingBack = false;
              state.navigating = false;
              return;
            }
          }
          if (isObject(beforeEachResult) === true && beforeEachResult.path !== currentPath) {
            currentRoute = previousRoute;
            to(beforeEachResult.path, beforeEachResult.data, beforeEachResult.options);
            return;
          }
          if (beforeEachResult === false && history.length > 0) {
            preventHashChangeNavigation = true;
            currentRoute = previousRoute;
            window.history.back();
            navigatingBack = false;
            state.navigating = false;
            return;
          }
        }
      }
      let beforeHookOutput;
      if (route.hooks.before) {
        try {
          beforeHookOutput = await route.hooks.before.call(this.parent, route, previousRoute);
          if (isString(beforeHookOutput)) {
            currentRoute = previousRoute;
            to(beforeHookOutput);
            return;
          }
        } catch (error) {
          Log.error('Error or Rejected Promise in "Before" Hook', error);
          if (history.length > 0) {
            preventHashChangeNavigation = true;
            currentRoute = previousRoute;
            window.history.back();
            navigatingBack = false;
            state.navigating = false;
            return;
          }
        }
        if (isObject(beforeHookOutput) === true && beforeHookOutput.path !== currentPath) {
          currentRoute = previousRoute;
          to(beforeHookOutput.path, beforeHookOutput.data, beforeHookOutput.options);
          return;
        }
        if (beforeHookOutput === false && history.length > 0) {
          preventHashChangeNavigation = true;
          currentRoute = previousRoute;
          window.history.back();
          navigatingBack = false;
          state.navigating = false;
          return;
        }
      }
      if (previousRoute !== void 0 && previousRoute.options.inHistory === true && navigatingBack === false) {
        history.push(previousRoute);
      }
      if (typeof route.transition === "function") {
        route.transition = route.transition(previousRoute, route);
      }
      let holder;
      let view;
      let focus;
      if (navigatingBack === true && navigatingBackTo !== void 0) {
        view = navigatingBackTo.view;
        focus = navigatingBackTo.focus;
        navigatingBackTo = null;
      }
      const props = {
        ...this[symbols_default.props],
        ...route.params,
        ...route.data
      };
      if (previousRoute && route.options.reuseComponent === true && route.options.keepAlive !== true && route.component === previousRoute.component) {
        reuse = true;
        view = this[symbols_default.children][this[symbols_default.children].length - 1];
        for (const prop in props) {
          view[symbols_default.props][prop] = props[prop];
        }
      }
      if (route.announce) {
        if (typeof route.announce === "string") {
          route.announce = {
            message: route.announce
          };
        }
        announcer_default.speak(route.announce.message, route.announce.politeness);
      }
      state.path = route.path;
      state.params = route.params || {};
      state.hash = route.hash;
      state.data = null;
      state.data = route.data || {};
      if (!view) {
        holder = stage.element({ parent: this[symbols_default.children][0] });
        holder.populate({});
        holder.set("w", "100%");
        holder.set("h", "100%");
        view = await route.component({ props }, holder, this);
        if (view[Symbol.toStringTag] === "Module") {
          if (view.default && typeof view.default === "function") {
            view = view.default({ props }, holder, this);
          } else {
            Log.error("Dynamic import doesn't have a default export or default is not a function");
          }
        }
        if (typeof view === "function") {
          view = /** @type {BlitsComponentFactory} */
          view({ props }, holder, this);
        }
      } else {
        holder = view[symbols_default.holder];
        let hasAlphaProp = false;
        if (route.transition.before) {
          if (Array.isArray(route.transition.before)) {
            for (let i = 0; i < route.transition.before.length; i++) {
              if (route.transition.before[i].prop === "alpha") {
                hasAlphaProp = true;
                break;
              }
            }
          } else if (route.transition.before.prop === "alpha") {
            hasAlphaProp = true;
          }
        }
        if (hasAlphaProp === false) {
          holder.set("alpha", 1);
        }
      }
      if (reuse === false) {
        this[symbols_default.children].push(view);
      }
      previousFocus = focus_default.get();
      const children = this[symbols_default.children];
      this.activeView = children[children.length - 1];
      if (route.options.passFocus !== false) {
        focus ? focus.$focus() : (
          /** @type {BlitsComponent} */
          view.$focus()
        );
      }
      if (route.transition.before) {
        if (Array.isArray(route.transition.before)) {
          for (let i = 0; i < route.transition.before.length; i++) {
            holder.set(route.transition.before[i].prop, route.transition.before[i].value);
          }
        } else {
          holder.set(route.transition.before.prop, route.transition.before.value);
        }
      }
      let shouldAnimate = false;
      if (previousRoute !== void 0 && reuse === false) {
        shouldAnimate = true;
        const oldView = this[symbols_default.children].splice(1, 1).pop();
        if (oldView) {
          removeView(previousRoute, oldView, route.transition.out, navigatingBack);
        }
      }
      if (route.transition.in) {
        if (Array.isArray(route.transition.in)) {
          for (let i = 0; i < route.transition.in.length; i++) {
            i === route.transition.length - 1 ? await setOrAnimate(holder, route.transition.in[i], shouldAnimate) : setOrAnimate(holder, route.transition.in[i], shouldAnimate);
          }
        } else {
          await setOrAnimate(holder, route.transition.in, shouldAnimate);
        }
      }
    } else {
      Log.error(`Route ${route.hash} not found`);
      const routerHooks = this.parent[symbols_default.routerHooks];
      if (routerHooks && typeof routerHooks.error === "function") {
        routerHooks.error.call(this.parent, `Route ${route.hash} not found`);
      }
    }
  }
  navigatingBack = false;
  state.navigating = false;
  preventHashChangeNavigation = false;
};
var removeView = async (route, view, transition, navigatingBack2) => {
  if (transition) {
    if (Array.isArray(transition)) {
      for (let i = 0; i < transition.length; i++) {
        i === transition.length - 1 ? await setOrAnimate(view[symbols_default.holder], transition[i]) : setOrAnimate(view[symbols_default.holder], transition[i]);
      }
    } else {
      await setOrAnimate(view[symbols_default.holder], transition);
    }
  }
  if (navigatingBack2 === false && route.options && route.options.keepAlive === true && route.options.inHistory === true) {
    const historyItem = history[history.length - 1];
    if (historyItem !== void 0) {
      historyItem.view = view;
      historyItem.focus = previousFocus;
    }
  }
  if (route.options && (route.options.keepAlive !== true || navigatingBack2 === true)) {
    view.destroy();
    view = null;
  }
  previousFocus = null;
  route = null;
};
var setOrAnimate = (node, transition, shouldAnimate = true) => {
  return new Promise((resolve) => {
    if (shouldAnimate === true) {
      let existingEndCallback = transition.end;
      transition.end = (...args) => {
        existingEndCallback && existingEndCallback(args);
        existingEndCallback = null;
        resolve();
      };
      if (node !== void 0) node.set(transition.prop, { transition });
      else resolve();
    } else {
      node !== void 0 && node.set(transition.prop, transition.value);
      resolve();
    }
  });
};
var to = (location, data = {}, options = {}) => {
  navigationData = data;
  overrideOptions = options;
  window.location.hash = location;
};
var back = function() {
  const route = history.pop();
  if (route && currentRoute !== route) {
    navigatingBack = true;
    navigatingBackTo = route;
    to(route.hash, route.data, route.options);
    return true;
  }
  const backtrack = currentRoute && currentRoute.options.backtrack || false;
  if (backtrack === false) {
    return false;
  }
  const hashEnd = /(\/:?[\w%\s-]+)$/;
  let path = currentRoute.path;
  let level = path.split("/").length;
  if (level <= 1) {
    return false;
  }
  while (level--) {
    if (!hashEnd.test(path)) {
      return false;
    }
    path = path.replace(hashEnd, "");
    const route2 = matchHash(getHash(path), this.parent[symbols_default.routes]);
    if (route2 && backtrack) {
      to(route2.path, route2.data, route2.options);
      return true;
    }
  }
  return false;
};
var router_default = {
  navigate,
  to,
  back
};

// node_modules/@lightningjs/blits/src/focus.js
var focusedComponent = null;
var focusChain = [];
var setFocusTimeout;
var keyUpCallbacks = /* @__PURE__ */ new Map();
var focus_default = {
  _hold: false,
  set hold(v) {
    this._hold = v;
  },
  get hold() {
    return this._hold;
  },
  get() {
    return focusedComponent;
  },
  set(component, event) {
    clearTimeout(setFocusTimeout);
    if (component === focusedComponent) return;
    if (focusedComponent === null) {
      focusChain = getAncestors([component]);
    }
    if (focusedComponent !== null) {
      if (focusChain[focusChain.length - 1] === component.parent) {
        focusChain.push(component);
      } else {
        const newFocusChain = getAncestors([component]);
        let i2 = focusChain.length;
        while (i2--) {
          if (newFocusChain.indexOf(focusChain[i2]) > -1) break;
          focusChain[i2].lifecycle.state = "unfocus";
        }
        focusChain = newFocusChain;
      }
    }
    let i = 0;
    while (i < focusChain.length - 1) {
      focusChain[i].lifecycle.state = "focus";
      i++;
    }
    setFocusTimeout = setTimeout(
      () => setFocus(component, event),
      this.hold === true ? settings_default.get("holdTimeout", DEFAULT_HOLD_TIMEOUT_MS) : 0
    );
  },
  input(key, event) {
    if (state.navigating === true) return;
    const componentWithInputEvent = getComponentWithInputEvent(focusedComponent, key);
    if (componentWithInputEvent === null) return;
    const inputEvents = componentWithInputEvent[symbols_default.inputEvents];
    let cb;
    if (inputEvents[key]) {
      cb = inputEvents[key].call(componentWithInputEvent, event);
    } else if (inputEvents.any) {
      cb = inputEvents.any.call(componentWithInputEvent, event);
    }
    if (cb !== void 0) {
      keyUpCallbacks.set(event.code, cb);
    }
  }
};
var getAncestors = (components) => {
  if (components[0].parent !== void 0) {
    components.unshift(components[0].parent);
    return getAncestors(components);
  }
  return components;
};
var getComponentWithInputEvent = (component, key) => {
  if (component[symbols_default.inputEvents] && (typeof component[symbols_default.inputEvents][key] === "function" || typeof component[symbols_default.inputEvents].any === "function")) {
    return component;
  } else if (component.parent !== void 0) {
    return getComponentWithInputEvent(component.parent, key);
  } else return null;
};
var setFocus = (component, event) => {
  Log.info(
    "\nFocus chain:\n",
    focusChain.map((c, index) => "	".repeat(index) + "↳ " + c.componentId).join("\n")
  );
  focusedComponent = component;
  component.lifecycle.state = "focus";
  if (event instanceof KeyboardEvent) {
    const internalEvent = new KeyboardEvent("keydown", event);
    internalEvent[symbols_default.internalEvent] = true;
    document.dispatchEvent(internalEvent);
  }
};

// node_modules/@lightningjs/blits/src/lib/eventListeners.js
var eventsMap = /* @__PURE__ */ new Map();
var callbackCache = /* @__PURE__ */ new Map();
function isProxy(obj) {
  return obj && typeof obj === "object" && obj[symbols_default.isProxy] === true;
}
function deepUnproxyClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  const raw = isProxy(obj) ? getRaw(obj) : obj;
  const result = Array.isArray(raw) ? [] : {};
  for (const key of Object.keys(raw)) {
    const value = raw[key];
    result[key] = value && typeof value === "object" ? deepUnproxyClone(value) : value;
  }
  return result;
}
var eventListeners_default = {
  /**
   * Registers a listener callback for a specific event on a component.
   *
   * @param {object} component - The component instance to register the listener for.
   * @param {string} event - The name of the event to listen for.
   * @param {Function} cb - The callback function to execute when the event is emitted.
   * @param {number} [priority=0] - The priority of the listener (higher runs first).
   * @returns {void}
   */
  registerListener(component, event, cb, priority = 0) {
    let componentsMap = eventsMap.get(event);
    if (componentsMap === void 0) {
      componentsMap = /* @__PURE__ */ new Map();
      eventsMap.set(event, componentsMap);
    }
    let components = componentsMap.get(component);
    if (components === void 0) {
      components = /* @__PURE__ */ new Set();
      componentsMap.set(component, components);
    }
    components.add({ cb, priority });
    callbackCache.delete(event);
  },
  /**
   * Deregisters a listener for a specific event on a component.
   *
   * @param {object} component - The component instance to deregister the listener for.
   * @param {string} event - The name of the event to stop listening for.
   * @returns {void}
   */
  deregisterListener(component, event) {
    let componentsMap = eventsMap.get(event);
    if (componentsMap === void 0) {
      return;
    }
    if (componentsMap.has(component)) {
      componentsMap.delete(component);
      eventsMap.set(event, componentsMap);
      callbackCache.delete(event);
    }
  },
  /**
   * Executes all registered listeners for a given event, in priority order.
   *
   * @param {string} event - The name of the event to emit.
   * @param {any} params - The parameters to pass to the event listeners.
   * @param byReference - whether or not to pass the data by reference.
   * The default behaviour is passing the data object by reference (`true`).
   * When explicitely passing `false` the object will be recursively cloned
   * and cleaned from any potential reactivity before emitting
   * @returns {boolean} True if all listeners executed without stopping propagation, false if any listener returned false.
   */
  executeListeners(event, params, byReference) {
    if (byReference === false) {
      params = deepUnproxyClone(params);
    }
    const componentsMap = eventsMap.get(event);
    if (componentsMap === void 0 || componentsMap.size === 0) {
      return true;
    }
    if (callbackCache.has(event) === false) {
      const allCallbacks = [];
      for (const [component, components] of componentsMap) {
        for (const callbackObj of components) {
          allCallbacks.push({ ...callbackObj, component });
        }
      }
      allCallbacks.sort((a, b) => b.priority - a.priority);
      callbackCache.set(event, allCallbacks);
    }
    const callbacks = callbackCache.get(event);
    for (let i = 0; i < callbacks.length; i++) {
      const { cb, component } = callbacks[i];
      const result = cb.call(component, params);
      if (result === false) {
        return false;
      }
    }
    return true;
  },
  /**
   * Removes all listeners for a given component from all events.
   *
   * @param {object} component - The component instance to remove listeners for.
   * @returns {void}
   */
  removeListeners(component) {
    for (const [event, componentsMap] of eventsMap) {
      if (componentsMap.has(component)) {
        componentsMap.delete(component);
        callbackCache.delete(event);
        if (componentsMap.size === 0) {
          eventsMap.delete(event);
        }
      }
    }
  }
};

// node_modules/@lightningjs/blits/src/application.js
var keyMap = {};
var Application = (config) => {
  config.hooks = config.hooks || {};
  let keyDownHandler;
  let keyUpHandler;
  let holdTimeout;
  let lastInputTime = 0;
  let lastInputKey = null;
  config.hooks[symbols_default.destroy] = function() {
    document.removeEventListener("keydown", keyDownHandler);
    document.removeEventListener("keyup", keyUpHandler);
  };
  config.hooks[symbols_default.init] = function() {
    this.$announcer.toggle(settings_default.get("announcer", false));
    const announcerOptions = settings_default.get("announcerOptions", null);
    if (announcerOptions && typeof announcerOptions === "object") {
      this.$announcer.configure(announcerOptions);
    }
    keyMap = { ...DEFAULT_KEYMAP, ...settings_default.get("keymap", {}) };
    const throttleMs = settings_default.get("inputThrottle", 0);
    keyDownHandler = async (e) => {
      const currentTime = performance.now();
      const key = keyMap[e.key] || keyMap[e.keyCode] || e.key || e.keyCode;
      const sameKey = lastInputKey === key;
      lastInputKey = key;
      if (throttleMs === 0 || e[symbols_default.internalEvent] === true || sameKey === false) {
        return await processInput.call(this, e, key);
      }
      if (currentTime - lastInputTime < throttleMs) {
        return;
      }
      lastInputTime = currentTime;
      await processInput.call(this, e, key);
    };
    const processInput = async function(e, key) {
      if (this[symbols_default.inputEvents] !== void 0 && this[symbols_default.inputEvents].intercept !== void 0) {
        e = await this[symbols_default.inputEvents].intercept.call(this, e);
        if (e instanceof KeyboardEvent === false) return;
      }
      focus_default.input(key, e);
      clearTimeout(holdTimeout);
      holdTimeout = setTimeout(
        () => {
          focus_default.hold = true;
        },
        settings_default.get("holdTimeout", DEFAULT_HOLD_TIMEOUT_MS)
      );
    };
    keyUpHandler = (e) => {
      const cb = keyUpCallbacks.get(e.code);
      if (cb !== void 0 && typeof cb === "function") {
        keyUpCallbacks.delete(e.code);
        cb();
      }
      clearTimeout(holdTimeout);
      focus_default.hold = false;
    };
    document.addEventListener("keydown", keyDownHandler);
    document.addEventListener("keyup", keyUpHandler);
    setTimeout(() => focus_default.set(this));
  };
  return component_default("App", config);
};
var application_default = Application;

// node_modules/@lightningjs/blits/src/component/base/methods.js
var methods_default = {
  focus: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(e) {
      Log.warn("this.focus is deprecated, use this.$focus instead");
      return this.$focus(e);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $focus: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(e) {
      if (this.lifecycle.state === "focus") {
        this.lifecycle.state = "refocus";
      }
      focus_default.set(this, e);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $input: {
    /**
     * Handle a keyboard event on this component without changing focus
     * @this {import('../../component').BlitsComponent}
     * @param {KeyboardEvent} event - The keyboard event to handle
     * @returns {boolean} - Returns true if this component or a parent component handled the event, false otherwise
     */
    value: function(event) {
      if (event === null || event === void 0 || event instanceof KeyboardEvent === false)
        return false;
      const key = keyMap[event.key] || keyMap[event.keyCode] || event.key || event.keyCode;
      const componentWithInputEvent = getComponentWithInputEvent(this, key);
      if (componentWithInputEvent === null) return false;
      const inputEvents = componentWithInputEvent[symbols_default.inputEvents] || {};
      let cb;
      if (inputEvents[key]) {
        cb = inputEvents[key].call(componentWithInputEvent, event);
      } else if (inputEvents.any) {
        cb = inputEvents.any.call(componentWithInputEvent, event);
      }
      if (cb !== void 0 && event.code) {
        keyUpCallbacks.set(event.code, cb);
      }
      return true;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  unfocus: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function() {
      this[symbols_default.state].hasFocus = false;
      this.lifecycle.state = "unfocus";
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  destroy: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function() {
      this.eol = true;
      this.lifecycle.state = "destroy";
      if (this.hasFocus === true) this.parent.$focus();
      for (let key in this[symbols_default.state]) {
        if (Array.isArray(this[symbols_default.state][key])) {
          this[symbols_default.state][key] = [];
        }
      }
      this.$clearTimeouts();
      this.$clearIntervals();
      eventListeners_default.removeListeners(this);
      const rendererEventListenersLength = this[symbols_default.rendererEventListeners].length;
      if (rendererEventListenersLength > 0) {
        for (let i = 0; i < rendererEventListenersLength; i++) {
          const eventListener = this[symbols_default.rendererEventListeners][i];
          renderer2.off(eventListener.event, eventListener.cb);
        }
      }
      this[symbols_default.rendererEventListeners] = null;
      deleteChildren(this[symbols_default.children]);
      this[symbols_default.children].length = 0;
      removeGlobalEffects(this[symbols_default.effects]);
      this[symbols_default.state] = {};
      this[symbols_default.props] = {};
      this[symbols_default.computed] = null;
      this.lifecycle = {};
      this[symbols_default.effects].length = 0;
      this.parent = null;
      this.rootParent = null;
      this[symbols_default.wrapper] = null;
      this[symbols_default.originalState] = null;
      this[symbols_default.slots].length = 0;
      delete this[symbols_default.computed];
      delete this.parent;
      delete this.rootParent;
      delete this[symbols_default.wrapper];
      delete this[symbols_default.originalState];
      delete this[symbols_default.children];
      delete this[symbols_default.slots];
      delete this.componentId;
      delete this[symbols_default.id];
      delete this.ref;
      delete this[symbols_default.state].hasFocus;
      this[symbols_default.holder].destroy();
      this[symbols_default.holder] = null;
      delete this[symbols_default.holder];
      this[symbols_default.cleanup]();
      delete this[symbols_default.cleanup];
      delete this[symbols_default.effects];
      Log.debug(`Destroyed component ${this.componentId}`);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  [symbols_default.removeGlobalEffects]: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(effects = []) {
      removeGlobalEffects(effects);
    },
    writable: false,
    enumerable: false,
    configurable: false
  },
  select: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(ref) {
      Log.warn("this.select is deprecated, use this.$select instead");
      return this.$select(ref);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $select: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(ref) {
      if (this.eol === true) return;
      let selected = null;
      this[symbols_default.children].forEach((child) => {
        if (Array.isArray(child)) {
          child.forEach((c) => {
            if (c["ref"] === ref) selected = c;
          });
        } else if (Object.getPrototypeOf(child) === Object.prototype) {
          Object.keys(child).forEach((k) => {
            if (child[k]["ref"] === ref) selected = child[k];
          });
        } else {
          if (child["ref"] === ref) selected = child;
        }
      });
      return selected;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  trigger: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(key) {
      Log.warn("this.trigger is deprecated, use this.$trigger instead");
      return this.$trigger(key);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $trigger: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(key) {
      let target = this[symbols_default.originalState];
      if (key.indexOf(".") > -1) {
        const keys = key.split(".");
        key = keys.pop(keys);
        for (let i = 0; i < keys.length; i++) {
          target = target[keys[i]];
        }
      }
      trigger(target, key, true);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  shader: {
    /**
     * @this {import('../../component').BlitsComponent}
     */
    value: function(type, args) {
      return {
        type,
        props: args
      };
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};
var deleteChildren = function(children) {
  for (let i = 0; i < children.length; i++) {
    if (!children[i]) return;
    if (children[i].destroy && typeof children[i].destroy === "function") {
      children[i].destroy();
    } else if (Object.getPrototypeOf(children[i]) === Object.prototype) {
      deleteChildren(Object.values(children[i]));
    }
    children[i] = null;
  }
  children.length = 0;
};

// node_modules/@lightningjs/blits/src/component/base/timeouts_intervals.js
var timeouts_intervals_default = {
  $setTimeout: {
    value: function(fn, ms, ...params) {
      if (this.eol === true) return;
      const timeoutId = setTimeout(
        () => {
          this.$clearTimeout(timeoutId);
          fn.apply(null, params);
        },
        ms,
        params
      );
      this[symbols_default.timeouts].push(timeoutId);
      return timeoutId;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearTimeout: {
    value: function(timeoutId) {
      const index = this[symbols_default.timeouts].indexOf(timeoutId);
      if (index > -1) {
        this[symbols_default.timeouts].splice(index, 1);
        clearTimeout(timeoutId);
      }
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearTimeouts: {
    value: function() {
      for (let i = 0; i < this[symbols_default.timeouts].length; i++) {
        clearTimeout(this[symbols_default.timeouts][i]);
      }
      this[symbols_default.timeouts] = [];
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $setInterval: {
    value: function(fn, ms, ...params) {
      if (this.eol === true) return;
      const intervalId = setInterval(() => fn.apply(null, params), ms, params);
      this[symbols_default.intervals].push(intervalId);
      return intervalId;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearInterval: {
    value: function(intervalId) {
      const index = this[symbols_default.intervals].indexOf(intervalId);
      if (index > -1) {
        this[symbols_default.intervals].splice(index, 1);
        clearInterval(intervalId);
      }
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearIntervals: {
    value: function() {
      for (let i = 0; i < this[symbols_default.intervals].length; i++) {
        clearInterval(this[symbols_default.intervals][i]);
      }
      this[symbols_default.intervals] = [];
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/events.js
var events_default = {
  /**
   * Emits an event to all registered listeners for the given event name.
   *
   * @param {string} event - The name of the event to emit.
   * @param {any} params - The parameters to pass to the event listeners.
   * @param byReference - whether or not to pass the data by reference.
   * The default behaviour is passing the data object by reference (`true`).
   * When explicitely passing `false` the object will be recursively cloned
   * and cleaned from any potential reactivity before emitting
   * @returns {boolean} True if all listeners executed, false otherwise.
   */
  $emit: {
    value: function(event, params, byReference = true) {
      if (this.eol === true) return;
      return eventListeners_default.executeListeners(event, params, byReference);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  /**
   * Registers a listener callback for a specific event.
   *
   * @param {string} event - The name of the event to listen for.
   * @param {Function} callback - The callback function to execute when the event is emitted.
   * @param {number} [priority=0] - The priority of the listener (higher runs first).
   * @returns {void}
   */
  $listen: {
    value: function(event, callback, priority = 0) {
      if (this.eol === true) return;
      eventListeners_default.registerListener(this, event, callback, priority);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  /**
   * Deregisters a listener for a specific event.
   *
   * @param {string} event - The name of the event to stop listening for.
   * @returns {void}
   */
  $unlisten: {
    value: function(event) {
      eventListeners_default.deregisterListener(this, event);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  /**
   * Removes all listeners for this component from all events.
   *
   * @returns {void}
   */
  $clearListeners: {
    value: function() {
      eventListeners_default.removeListeners(this);
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/router.js
var router_default2 = {
  $router: {
    value: {
      to,
      back,
      get currentRoute() {
        return currentRoute;
      },
      get routes() {
        return this[symbols_default.routes];
      },
      get navigating() {
        return state.navigating;
      },
      state
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/announcer.js
var announcer_default2 = {
  $announcer: {
    value: announcer_default,
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/utils.js
var utils_default = {
  $size: {
    value: function(dimensions = { w: 0, h: 0 }) {
      this[symbols_default.holder].set("w", dimensions.w || 0);
      this[symbols_default.holder].set("h", dimensions.h || 0);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  [symbols_default.renderer]: {
    value: () => renderer2,
    writable: false,
    enumerable: true,
    configurable: false
  },
  [symbols_default.getChildren]: {
    value() {
      const parent = this.rootParent || this.parent;
      return (this[symbols_default.children] || []).concat(
        parent && parent[symbols_default.getChildren]().map((child) => {
          if (Object.getPrototypeOf(child) === Object.prototype) {
            return Object.values(child).map((c) => {
              c.forComponent = c[Symbol.for("config")] && c[Symbol.for("config")].parent.component;
              return c;
            });
          }
          return child;
        }).flat().filter((child) => {
          if (child && child.component) {
            return child.component && child.component.componentId === this.componentId || child.forComponent && child.forComponent.componentId === this.componentId;
          }
        }) || []
      );
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/index.js
var shared = { ...events_default, ...router_default2, ...announcer_default2 };
var base_default = Object.defineProperties(
  {
    [symbols_default["launched"]]: false
  },
  { ...methods_default, ...timeouts_intervals_default, ...shared, ...utils_default }
);

// node_modules/@lightningjs/blits/src/component/setup/props.js
var baseProp = {
  cast: (v) => v,
  required: false
};
var props_default = (component, props = []) => {
  if (props.indexOf("ref") === -1) {
    props.push("ref");
  }
  component[symbols_default.propKeys] = [];
  const propsLength = props.length;
  for (let i = 0; i < propsLength; i++) {
    const prop = { ...baseProp, ...typeof props[i] === "object" ? props[i] : { key: props[i] } };
    component[symbols_default.propKeys].push(prop.key);
    Object.defineProperty(component, prop.key, {
      get() {
        const value = prop.cast(
          this[symbols_default.props] !== void 0 && prop.key in this[symbols_default.props] ? this[symbols_default.props][prop.key] : "default" in prop ? prop.default : void 0
        );
        if (prop.required === true && value === void 0) {
          Log.warn(`${prop.key} is required`);
        }
        return value;
      },
      set(v) {
        Log.warn(
          `Warning! Avoid mutating props directly (prop "${prop.key}" in component "${this.componentId}")`
        );
        this[symbols_default.props][prop.key] = v;
      }
    });
  }
};

// node_modules/@lightningjs/blits/src/component/setup/methods.js
var methods_default2 = (component, methods) => {
  component[symbols_default.methodKeys] = [];
  for (let method in methods) {
    if (component[symbols_default.propKeys] && component[symbols_default.propKeys].indexOf(method) > -1) {
      Log.error(`${method} already exists as a prop`);
    } else {
      if (typeof methods[method] !== "function") {
        Log.warn(`${method} is not a function`);
      }
      component[symbols_default.methodKeys].push(method);
      component[method] = methods[method];
    }
  }
};

// node_modules/@lightningjs/blits/src/component/setup/state.js
var state_default = (component, state2 = () => {
}) => {
  Object.defineProperty(component, symbols_default.stateKeys, {
    value: [],
    enumerable: false,
    configurable: false,
    writable: false
  });
  const stateKeys = Object.keys(state2.apply(component) || {});
  if (stateKeys.indexOf("hasFocus") > -1) {
    Log.warn(
      "State `hasFocus` already exists as a built-in Component variable (to indicate whether the component currently has focus). Avoid using your own `hasFocus` key in the Component state"
    );
  } else {
    stateKeys.push(["hasFocus"]);
  }
  const stateKeysLength = stateKeys.length;
  for (let i = 0; i < stateKeysLength; i++) {
    const key = stateKeys[i];
    if (component[symbols_default.propKeys] !== void 0 && component[symbols_default.propKeys].indexOf(key) > -1) {
      Log.error(`State ${key} already exists as a prop`);
    }
    if (component[symbols_default.methodKeys] !== void 0 && component[symbols_default.methodKeys].indexOf(key) > -1) {
      Log.error(`State ${key} already exists as a method`);
    }
    component[symbols_default.stateKeys].push(key);
    Object.defineProperty(component, key, {
      get() {
        return this[symbols_default.state][key];
      },
      set(v) {
        this[symbols_default.state][key] = v;
      }
    });
  }
};

// node_modules/@lightningjs/blits/src/component/setup/computed.js
var computed_default = (component, computeds) => {
  component[symbols_default.computedKeys] = [];
  for (let computed in computeds) {
    if (component[symbols_default.stateKeys] && component[symbols_default.stateKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a state variable`);
    } else if (component[symbols_default.propKeys] && component[symbols_default.propKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a prop`);
    } else if (component[symbols_default.methodKeys] && component[symbols_default.methodKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a method`);
    } else {
      if (typeof computeds[computed] !== "function") {
        Log.warn(`${computed} is not a function`);
      }
      component[symbols_default.computedKeys].push(computed);
      Object.defineProperty(component, computed, {
        get() {
          return computeds[computed].apply(this);
        }
      });
    }
  }
};

// node_modules/@lightningjs/blits/src/component/setup/input.js
var input_default = (component, input) => {
  component[symbols_default.inputEvents] = [];
  Object.keys(input).forEach((key) => {
    if (typeof input[key] !== "function") {
      Log.warn(`${input[key]} is not a function`);
    }
    component[symbols_default.inputEvents][key] = input[key];
  });
};

// node_modules/@lightningjs/blits/src/component/setup/routes.js
var routes_default = (component, data) => {
  let routes = data;
  if (Array.isArray(data) === false) {
    component[symbols_default.routerHooks] = data.hooks;
    routes = data.routes;
  }
  component[symbols_default.routes] = [];
  const l = routes.length;
  for (let i = 0; i < l; i++) {
    component[symbols_default.routes][i] = routes[i];
    component[symbols_default.routes][i].options = {
      ...{
        inHistory: true
      },
      ...routes[i].options
    };
  }
};

// node_modules/@lightningjs/blits/src/component/setup/watch.js
var watch_default = (component, watchers) => {
  component[symbols_default.watchKeys] = [];
  component[symbols_default.watchers] = {};
  for (let watch in watchers) {
    if (typeof watchers[watch] !== "function") {
      console.warn(`${watch} is not a function`);
    }
    component[symbols_default.watchKeys].push(watch);
    component[symbols_default.watchers][watch] = function(v, old) {
      watchers[watch].call(this, v, old);
    };
  }
};

// node_modules/@lightningjs/blits/src/component/setup/index.js
var counter3 = 0;
function setup_default(component, config) {
  component[symbols_default.identifier] = ++counter3;
  registerHooks(config.hooks, component[symbols_default.identifier]);
  props_default(component, config.props);
  if (config.methods) methods_default2(component, config.methods);
  state_default(component, config.state);
  if (config.computed) computed_default(component, config.computed);
  if (config.watch) watch_default(component, config.watch);
  const routerConfig = config.router !== void 0 ? config.router : config.routes;
  if (routerConfig !== void 0) routes_default(component, routerConfig);
  if (config.input) input_default(component, config.input);
  return component;
}

// node_modules/@lightningjs/blits/src/components/Circle.js
var Circle_default = () => component_default("Circle", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2, Log2) {
      const elms = [];
      const elementConfigs = [];
      const forloops = [];
      const props = [];
      const created = [];
      const effects = {};
      const skips2 = [];
      let componentType;
      let rootComponent = component;
      let propData;
      let slotComponent;
      let inSlot = false;
      let slotChildCounter = 0;
      let cmps = [];
      elementConfigs[0] = {};
      elms[0] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[0]["color"] = component.color;
      elementConfigs[0]["w"] = component.size;
      elementConfigs[0]["h"] = component.size;
      elementConfigs[0]["effects"] = [component.shader("radius", { radius: component.radius })];
      elms[0].populate(elementConfigs[0]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      return {
        elms,
        cleanup: () => {
          rootComponent = null;
          propData = null;
          slotComponent = null;
          parent = null;
          component = null;
          cmps.length = 0;
          elms.length = 0;
          components.length = 0;
          elementConfigs.length = 0;
          forloops.length = 0;
          props.length = 0;
          skips2.length = 0;
        }
      };
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("color", component.color);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("w", component.size);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("h", component.size);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("effects", [component.shader("radius", { radius: component.radius })]);
      }
    ],
    context: {}
  },
  props: [{ key: "size", default: 40 }, "color"],
  computed: {
    radius() {
      return this.size / 2;
    }
  }
});

// node_modules/@lightningjs/blits/src/components/RouterView.js
var hashchangeHandler = null;
var RouterView_default = () => component_default("RouterView", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2, Log2) {
      const elms = [];
      const elementConfigs = [];
      const forloops = [];
      const props = [];
      const created = [];
      const effects = {};
      const skips2 = [];
      let componentType;
      let rootComponent = component;
      let propData;
      let slotComponent;
      let inSlot = false;
      let slotChildCounter = 0;
      let cmps = [];
      elementConfigs[0] = {};
      elms[0] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[0]["w"] = parent.node.width * (100 / 100);
      elementConfigs[0]["height"] = parent.node.height * (100 / 100);
      elms[0].populate(elementConfigs[0]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      return {
        elms,
        cleanup: () => {
          rootComponent = null;
          propData = null;
          slotComponent = null;
          parent = null;
          component = null;
          cmps.length = 0;
          elms.length = 0;
          components.length = 0;
          elementConfigs.length = 0;
          forloops.length = 0;
          props.length = 0;
          skips2.length = 0;
        }
      };
    },
    effects: [],
    context: {}
  },
  state() {
    return {
      activeView: null
    };
  },
  hooks: {
    async ready() {
      if (this.parent[symbols_default.routerHooks] && this.parent[symbols_default.routerHooks].init) {
        await this.parent[symbols_default.routerHooks].init.apply(this.parent);
      }
      hashchangeHandler = () => router_default.navigate.apply(this);
      router_default.navigate.apply(this);
      window.addEventListener("hashchange", hashchangeHandler);
    },
    destroy() {
      window.removeEventListener("hashchange", hashchangeHandler, false);
    },
    focus() {
      if (this.activeView && focus_default.get() === this) {
        this.activeView.$focus();
      }
    }
  },
  input: {
    back(e) {
      const navigating = router_default.back.call(this);
      if (navigating === false) {
        this.parent.$focus(e);
      }
    }
  }
});

// node_modules/@lightningjs/blits/src/components/Sprite.js
var Sprite_default = () => component_default("Sprite", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2, Log2) {
      const elms = [];
      const elementConfigs = [];
      const forloops = [];
      const props = [];
      const created = [];
      const effects = {};
      const skips2 = [];
      let componentType;
      let rootComponent = component;
      let propData;
      let slotComponent;
      let inSlot = false;
      let slotChildCounter = 0;
      let cmps = [];
      elementConfigs[0] = {};
      elms[0] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[0]["w"] = parent.node.width * (100 / 100);
      elementConfigs[0]["h"] = parent.node.height * (100 / 100);
      elementConfigs[0]["texture"] = component.texture;
      elementConfigs[0]["color"] = component.color;
      elementConfigs[0]["effects"] = component.effects;
      elms[0].populate(elementConfigs[0]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      return {
        elms,
        cleanup: () => {
          rootComponent = null;
          propData = null;
          slotComponent = null;
          parent = null;
          component = null;
          cmps.length = 0;
          elms.length = 0;
          components.length = 0;
          elementConfigs.length = 0;
          forloops.length = 0;
          props.length = 0;
          skips2.length = 0;
        }
      };
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("texture", component.texture);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("color", component.color);
      }
    ],
    context: {}
  },
  props: ["image", "map", "frame", "color", "effects"],
  state() {
    return {
      spriteTexture: null,
      currentSrc: null
    };
  },
  computed: {
    texture() {
      if (this.image === void 0 || this.image === null) {
        return null;
      }
      const renderer3 = this[symbols_default.renderer]();
      if (renderer3 === null || renderer3 === void 0 || renderer3.createTexture === void 0) {
        return null;
      }
      if (this.spriteTexture === void 0 || this.spriteTexture === null || this.currentSrc !== this.image) {
        this.spriteTexture = renderer3.createTexture("ImageTexture", {
          src: this.image
        });
        this.currentSrc = this.image;
      }
      let options = null;
      if (this.map !== null && this.map !== void 0 && this.frame !== null && this.frame !== void 0) {
        if (this.map.frames !== null && this.map.frames !== void 0 && this.frame in this.map.frames) {
          options = Object.assign({}, this.map.defaults || {}, this.map.frames[this.frame]);
        } else if (this.frame in this.map) {
          options = this.map[this.frame];
        }
      }
      if ((options === null || options === void 0) && typeof this.frame === "object") {
        options = this.frame;
      }
      if (options !== null && options !== void 0) {
        return renderer3.createTexture("SubTexture", {
          texture: this.spriteTexture,
          x: options.x,
          y: options.y,
          width: options.w,
          height: options.h
        });
      }
      return this.spriteTexture;
    }
  }
});

// node_modules/@lightningjs/blits/public/assets/fps_sprite.base64.js
var fps_sprite_base64_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAaMAAAAbCAYAAADRe+BYAAAAAXNSR0IArs4c6QAAGn9JREFUeF7tXQ1UVdWePxcWFg7ZA0sym5n0Tmk1z4+0YeVU4yo1h1jvPVBo1ETU8QvTdJlhsmKpi0he5jyXX0CKIWkpl3OlME3RGcdJixVEas+nJtq0sMwXN/kIgbxn1m+791n/ezifF0hr7lmrVV3O2Wfv/977//v//h/7uKTQFZJASAIhCYQkEJLADZaAy+j9iqIMkCRpliRJGeSeWkmSClwuV25X9VtRlOGSJI3m7wq6bd5Osqa/6OZSSZJKXC4X+h7UpSgKZABZQCbiKuHt4t+dvri8z5GG3E77rChKtCRJ9TY647ht0aaiKJAx5LCK/4Y5m23jneotiqJgvg84eCaYd6Cf4h/xqgo+ZwUO3h1wK5cx1oIYP/5eJUlSrsvl6tRakGUZbYr9tjQpKanL9lmw4w09F5LAzyUBXTDiih3KAspN76pwuVxjgu2koijYzGibbmg0tzQYoOPt5Zv0xydJ0hiXywWlYfviAAE5UBDSPu9YUep1QFEUvAdKWlyOAYPP26c2BhhM25ivXZo+4lWOxx8EGEHRw6iwdXHjQbu26LMwTlJsNUZusrEeHMuC9kGWZRgSYs/VJiUluZ32MXR/SAK/VAkYgREsdKaAKysr58fFxd0Di23Xrl1ScjKMTUl69913906cODHe6cDNFAVvcyAUHCxNO21rGIVv7969ufHx8djQGatWrZIyMq4bmj6frz4mJuYRSZJsMyQNQJS43e4/19bWThk+fPiA/Px8afhwkDpJKikpKUhJSXHEDujY9MDU7XZLtbWsq1BItvrMWQsAQxozZoxUUQEiYHrZapuzAYCcAOWSnJycv2RmZjZThiRJklMZGDIkyHfWLNgskkRkgXVh+g4N0NUuWLCgYN26dcMHDBiQjPUr5qyoqOjttLS0KVYC0syTui/q6+tX9O7duyU6OnoV2h09+rodEexakGUZG4vNnbiWL18uHT9+HCBsay84Gcv/13s9Hs/osLAwlZW7XK6KxMRES8Pa6/Ue4GuLic7v94+ZMGGC5Qb7OeXcXWMrLS3Nd7lcs+zKKtgxdwAjupnPnDlTNHDgwN9RhlRfXy9FR0dDuUsxMTGYDMuJ1GxooAO0eNWgQYNaX3jhhcfnzp2bhHuWLl0q5eayfWd7AyqKoro2uIJ5jr7vwIEDqqKIi4trqKysfJK7VUxlRl1ebW1tX99yyy3tlCFB+aBtroCklJQUS0Wp90L+Hii5ABYaJBhBtowRjBgxQqqqsiSCdsEISpJZIZcuXVp01113PaPHkKyAQmf8umCE9XXu3Dm2zgCoAFZ+YXGYMiS6HjZt2iSnp6eztYVLZ87gVrPFkCjQX758+d0+ffr8k1gP6Oenn34qDRgwgBkQbrfb8VqQZVnIGCyerYX9+/dLeXl5MERuSoYky7JiU/GoLE+r1A2eh4cEIKG7gD0ez4CwsDCsxwD2qygKmGlFUlKSobtUq7A5sLgnTJhgaPDx91EX+i8CjLpqbHSeXS7XCKN5sbkWDG/TAyNVuSckJHyzZ8+evvxpbNoSRVHgDmMmK1d4toFD0wumOGH9wgruBBip7q2YmBgGkiBCXDGiv6qCnj17tlRQUGBrc5PYgJSZmTk1JyfnAd5/LPTZBESowoTV7igeoSiKUEK1ly5dCo+Njf17vKezYERkAU0etAVHjZPm5uaiqKioxylD4uMNun0DgFbnbNq0aXveeustgB8TixVLpOuTsEPMeYqiKFgXTKkQkLM1ZxTkNPuCrf8rV678qVevXi+QfWGrXdxfXl4e3dbWxmJ933zzzbHz588/OnLkSKmpqUlKT0/Hv9U51CjGDq482hZk1aNHjxEJCQlsU3D2JYxB/MRiXTQG6Pf7TRUzna9uBCPxmg5xM1mW1bVhovxKkpKSdI0MPTAqLi6WvF6voWGt907OWtGFTu2vzipw+nx3jU0wo6+++qpu0aJF/bg+cURC7IxTD4xUK5goRNUipco9JSUFbgks9Bg7L9MBo+EbN24M7wwzIm3S4K+qCKgSIcpphB12xNumSQEqkFElDTYHVgewtmtp42ZqbX/99dfTzp07VzBq1KiIToCRaii4XOrUOhlrh2mk8nv66acr9u/fL+JatpWtk7VBmaLf778QHh5+O2cKtli4jvGB17O+0jkrKCiQYJzYnTMKcnpuQ+pqdWL0cJBQFeybb7557Nq1a4/OmTOHiS0vLw8MKYBpERYlaS1VjbsvNykpiS1MCyWOdc1csMGCUVKSSkDNprvW6/XWCncXUejqM2PHjpXE2PFjdXX10uzsbOYu0Shb39mzZ7MyMjL+BkYt5mTKlCnS4MGDWVunTp0qy8zM/IO2M3oKGyx8yZIlbNvpGTuyLMNFfd0nz69fChh18dgoE+6UXtFbJHpgpDINsulU9DfY7EF3jG7iYNx0ZFA0AQDg6KOK7erVqy2RkZGR/H4nihRgdD14cZ1xCaUGxT/A7/dfue+++27n8R1bCpMDEdoVcRgE1OH2SxaxhyCZEZMBxrpt27ZIEXPhfQdQMjeGQ3BgG7G9vb0pPj4+Cm2KuCFvJ6ikE6M+0PWgcbPZskDpnGNOYDBVVVWNURQFCheGFlMqRL625syAcdF9gTXCKD5Zx7b2hVB2iqL8MHXq1N+gjW3btjERcWWCdQdFyRiO1+udxfsjcateBSuakQcFi+fvvffeD9asWSPiu779+/e/lZeX9wRkAcUPABDX3Llz4Yo1VMx03igz6iowQvsUkI4fPy4tX76csU8Kwh6PZ/uOHTsm0/5ERUVJGzdulPBvXDNmzCjz+XwBgETBCOOMjY1l93JZdfDyeL3e4YqisKSgpqam+qioKGZ43+xg1E1jE8aurT3jRM/gXrtgpFoMBmDEXHhOX86Vst4mDtb1F9AFatVv3br18PTp0/+F32BLsdHGqDIiv1ekpqZuKy4uvq45rrs8bGV9kb75EhMTs3bv3r2OxreCBCM1wG4yFylOUpAVRWHWUEtLy9XIyMhbDdqtgoUezPxrn1EUhY0BivmOO+6Q6uvroZxtuVZFW8gqrKurK+vXrx9cCtqrdv369fnz588XSQG24jt03RNWRfeFyswJGFkaPVTZnT9//sTixYt/iw5v2LDhWN++fR8lilJti7riuLJWvRMiI6+xsVEFtldffbXsgQce+D3a2rdvn1xQUBBAY15//XUGzri6AIwMy0XQPo0ZGSl0Oj64KlNTU/FoCgdaxuBIP1WXPH7Pz88vvfPOO9n4Vq9eLR09ejRgT1Iw8nq9UmJiIhs3/ru4uBhuy4B1TMF93759344bN+4u3K/Xd85KA8oJYPwhlkXjWBp21sHVKsuyuo9RNpGYmGjL9d9dY6P9SUpKYvNL3cUYn6IoyHjNQKID2XCOyhO6CowsN52RoupCZhTwCtruTz/9VBMREYFYDNhIUG5FPTACW5gxY0ZzcXExzCu0i4VsmflG3UU8KwtZXQOqq6svDRs2jJlqQYIR3D0Zp0+fDp88eXKvqqoq9KkkIyNjFjILcTU3N7c9+eSTz1ZWVu62Ag9t7RMSItLT05EEMn7o0KGLNm/eHC+y04LNrqR9oG7L3bt3y4mJiUJpOlpfkK/f738zLCzsXu0YwWRnzpz5fWFhocgMtIxDoQ1togkHHGbUUKMH9zph+FTZbdiwofbgwYPol2/Lli0ro6Oj/8NIUVKWAGXd1NQ0AgpVWPFQnAUFBVCcPlmWsSYZI+T34j9VJU4B4mYAI3ROh3VV8PExNzF3XzKQ0jGEsc9pUhDzlHAlqmbTgVUOGTKEufbAJDB2vofVxAkB7j/88EPF+++/PxquQD0wEnEVkz0VoJg196t/o6wX4zKKfem9h4JRV47NCox4yAPrtkMpEIBq/PjxtrJsf5VgpEnv9Y0cOXLXsWPHhEA6y7ryR48ezZS7UMRz5sw5kZ+fD3eAJRBxxSYsHzAKUF6AiK+xsfHPUVFR/xwsGJEF2oEh0VRpriwt2SwFI7i8kLDiu54hwhYdssfgBsLFs8g6WJZWgKcBI9XVOnDgwK/PnDnzt1yJqC4qq/ZorVVTU9Op+Ph46ciRIw+gr5CBcIOmpqZeKi4uRualbbclBUudfqhxFx4zYrhklZYtlJ3f729IS0vrBSYAJVReXj5bJDUQdqC6/ajS4gxgqSzLeJZZHcJFB9esLMvMWqVsScTRONipacs3AxhRpUpiHj6v17tUuCcJIBkZE2r8lAKWVmE3NzerMSrOdlQmRe997733Prxy5crTemDk9XrB5JmLFvt50aJF2y9cuBDvdruTX3zxRdUVuGrVqvmVlZXrcR/YX0tLy/+Gh4dHYX7nzZt34Z133nm4ra1NgKjv+eefb7p48SL2AC5Lg6w7xob9oQEj1hmPx+MOCwtTMwyPHj0qFRYWFtXX168cMWLE6wsWLEgS7tL09PQV33777XKrvfurAyNt4eeMGTNyCgsLl3FBdEpZ8jbYIqeK+LPPPrv28MMPT7TjqqTunldeeSU9Ozt7I28XGw1WH7P8gmFGZLIZQ+LgiEVcpRO8D4hD6C0UCkaaFGvIkbXb0tJy4tZbb/1HPM8z+CwVsMG71DTv48ePVwwZMkQkSjhqj9aGpaamphYXF2MTMBZEU8YvXLjg79+//7/ZmTPa39OnT//hiy++2JmYmNgDv6N+LTo6+mVaxE3S6k37TpMNvvzyy7+89NJLg/i7mKFA2Y/W5URdWTwFvMrr9SJOOhqxjdTUVJFUBPcWq186ffp0w8svv9yLv0NlC13BjEwUTYAbyspNx2WCPcYMHsKAmK7XnFIhtbe3/xgREbHS7/eXmKVni/5pXVlgW1u2bGmJiIiI1KbSE/biS01NdT333HO/EfE16qaTZRl9ZWtsyZIlQ8+dO4d1xS64AQWA8bGoa4IaFHh3ZGTk3scff/xf8dwnn3wi5+bmCs+ArcSo7hibHTAirBJ6gTEkjFm4QPnatXSH282m040Z8Ww6W6httFi70k2nPTli/fr1GSQ2YNuNZoXg4u/Nzc0Xe/bsyVLfefaaKdtwcFyP2oUDBw6kjh07tthun0zkjEXCLJmSkhIW2Ley3Gl/CRiBAcBCZ24PnSwzR/Ed0V/aTkpKSnVJScnD/G+23GikHRbjunr1al1kZKSIGang2djY+D8a9mnJEHVk2qFAVRSEX7lyBSAXxksMTK1ZCjZW8wvLc/Xq1QEuZvG8SAEXSQ8ffPDBic2bNyP2xO4XLi+iNALm6EaBkdWYz58/v3Px4sXP8vtUQ3LatGn5Dz744CwR5yLtwNNQYBZjoQqbg4/0xhtvnOjfv/9vCQNl7lfBWuvq6vbMnz//GZrsYRDvUuPfnHGneL3eZE2yCbqrrumdO3f+V0REhIhls6EoinJh/PjxIovUtt7qrrFZMSMetxTTwEpfOBtnLJ0YFKoBpDf3pnVGBGwoGKmp38QCtKSQ3Q1G3IpH1guzqD766KOcxx57TDAi/GQrs4koNXFmHn4S7rSAYYhgOwEjU+alc/6c1X5Ehp0tMOLMR6Sf4rimgIJBg7RmS2uFxyCG8yJn9Dcgk4YyEVLbZLrotIOmcvnuu++qY2NjBRBZ9k+nLQZGFy9ebOnXr5/InqTrV5stGhR4kvMUkylLPnLkSOUTTzyBgljTNaepB7JcB7iBx3tU8KTMCjECYYFnZGQ0nD17FgyIyY+mJvM2AuawK8DIRjYdk7PNotdcj8fTtmPHjudJHEKrY5DOnYF4Dyxw4RLie7EiIiIiRdRXUeHqKewJEyaUTZo0iSV4CCtelmXIiDHKDRs27Dl48OAz8+bNa33qqaduwW96YJSVlfV2bGxsXN++ff9Bb0J55iP+pI6FJrCIZwoLCzeXl5f/O/9/256B7hqbAzBS9xItJbCI76miMj2BwSBriJ2fxY/XUV0BTt0dROl3OptOe2bY559/vm7o0KGIB4iAWjDZc1Ds4py3DmfxUQV64sSJ1sGDB7NFqpehqLMwdQ80NcimE4+bjkETz+hwRhplHiTAbkn/deq0VEWmiSn91e1238E765TNqP7911577ciyZctQWIsrmHlTa0K4q5PWhqmB7aampvbbbruN1XTZKaY1QwsKyMOGDfugpqYGadSmblC6WQmT6fAa6u7gykydMw5oLMYAqx4KuaGhoTYtLU0kZwgLX83044ohAIApWHVBzMhIVB3ASK/OyOBhoyxVcTDycIASAFHUGV2+fPnU7NmzH9S2p6eweVwNbUULBsrBCL/5ONBG5+Tk1A4aNIjJloJReXl5VVtbG4ycgFok7bsJGAUADJU/Ya943JGh1B1js+OmI8xI1Q0GYGRKWozOplM3NGdH4vQFlRWtXbv2xMKFC1kaqlPWQSeps2467blptbW1f3S73TNNLCozvRLwN8p8uMWbybOnsOigQNniW7hw4V/Xrl0rFLFpait/geoyoy/sDBihHdpfnt32Co8XqUWVyACMjY2N4m4kS+ZBs8jwzMSJE5s+/PDD2zgQqXU7mZmZp8gpFbaZEW2fH7skArZB1TLQmByy/yZNmoREiL/j71EPevV4PHXJycnCjecIPMWcaU9z52vvJf53U9lSBUSSDTqsTQAqUq9xkWC+Kl+tq+/QoUOH169fD7eP6tKjabgALQDS0aNHWRvaLDAKRvw5duaV3llsBnVGwaR2G+1JgBDWgVWSifBiZGzatCla1A5lZWVVnjx5cpxwKeMlVGETJYokD8iLHWQJGWzatIn1iRfPMta0devW6ttvv52xdgpGpaWlySKlGQkMa9asOYWkGbBnWjOlB0Z6ZxISJuHIGOuOsd0MYIQiR/gyr1ePdbzAFLAAYGk6Qm9tU10ARnaOB1Ff6yJHE1ihEmJQ165dOxQeHi6Cvh0eqaury7/nnntEpl6nEiSohR1MAgP629TUtCcqKup6JV/Hy5eQkPCfe/bsEYFRWy4Aq1O2OyMDCh55eXmVc+fOFS6uzrh+aSZVBym0trYevvvuu4fwGiZHqf4mspjtcrlgSYvEC0OAo66Z77//vm7mzJkCFHXnQwe41Pu0yoy46ALYhCZl2HDpUzAqLS1V60b0UnS7EIwsla5mnIYpz+vWrSvv168fOz6KK/UAo8ZIYXu9XtTKME8IQEowrJUrV1bU1NRgTpHNJxKBAsBIlmVWAI9n09LSahoaGoYKAdsAI5H56vvxxx979ezZM1xk1zU2Nva30lH0790xthsORhggLN+cnJz/XrZsGS0cFN8zAhBdP77bRvqqmUBvZjDicohesWLFl1OmTIlBbIBcBTt27KiZPHnyDELPg1ag/F16p184strBANDfBQsWxCB7jFxLR40aFXP48GFhuVtm09GHy8rKhp09e/bo4sWLaeFrRWVlZVlcXFxaMDKgrKgzRa566ys7O/vtuLi4ySKVm99TVV9fX967d2+kzwvQsGSHtH0NGDGr3e12R+I0d3JmnynIUzZSWlpat337drHHdOOa1OUhMudEcSZ11RHmhC53UPBZWVlTwsLCtglFC5der169cIIGTnRg8jBiRgZFnurxMCRmFAwzsgQjTYzN16NHD7deTIjGpHj8B8NS5WqgsBlg0dgIHmpvbz/57LPPskxRpOhzI4LJSZNNB8Yd3dra2jpx4kThrkebSLfH/SyQr2VGdF5ramq2f/zxx5PFUUh8nh3pk+4Y200BRnwCADqm3zVyemq3CTDRTBRbFrumLUcMyWZsR7zCSg5ssdo9fcEMnPnf6NFGjsCIzBs2iNF3mNj3nRyczye6bPVRvM7IgM5fMPOvJ1ZThiQynqgbx8bcWMnCiQKhcUk7rJqekaYFLno2oxnbo/uMjYWewECKYum6o3KkRw/9bGCEflLlDeA9dOjQsb17947E3wBWra2tq4S7rKGhgdVt8clS58RCYQfokLKysi+LiopEMgKKilfpnKsHEINMmXFOAAdZjAEfYaRg5PF4SkidTu3UqVPDGhsb783Ly/P36dMnDG1xlovCbXHQrehfLXebBtQ1dsfYuhqMPB5PBf+EB3RTQCGw3fiG9rh2xpCsCvocbGzcejODEfonzqjTfvEVckBQ2cqv7UQcnQUj2l8sYEqR2Jdv7Rbo6nRa7wvAGLuQg5NxintpxbwjxmbjZVi7mDP64UIofsigM98JosAs4hqQAVMcNi+q5O0AMFWWWkZH+9PBKOBuLgT5MW7ci7ZGI74i4iN1dXUN8+fPFwqcghFtW2UxP6ebTshz+/btf4qMjGSno5tcvqysrLMnT54ULl81A9FMYWs/FUGAmRkKRjVSvL7LyGhXi6H5kUPo9lKv1ztaABs9oikhIWHz9OnTWSYdZ7oU/E2PCeqOsXU1GPFTNMSHUANq0OyAkc19FbotJIGQBG5GCXAlK8oe6NEzOARUTcQpKir6qqysjH3ChJ/EbwqsNwKM0LGHHnoo9/77739Jm9INpt/Y2Fg+depU1P6JM9ICYtpmChttC8DR1M4wQ8GsYBcyrqqqOvDII48wb0R7ezsKaVf06NGjQJykITLlZs2aJY8bN47FbTWuQFbD5/V6dwmg4myKsWDBDFHUvGTJkphLly7hfhgHjCF119gcpHZbZtNRZrRz5876nTt3IpGGyTcERjej9gj1KSSBLpQAXFjt7e2qgtNruqGh4d20tDRxcoAdlyFthn5awK5OoezfMmak02fqljSSlpk7Wsts6fd5tNmu2uxQo76bufNVhqRx6dO2qIuX9k87H/S4Lz23cHeMjZE14voX80xlpZcBS9k87Sv1hDGDwe7C6cKtEWoqJIGQBG6EBHJzc5+vr69/Iy4ujh1lxK+S6urqquzsbLgzRZ2Mk7gXmrkRYIT3QhGKWiPqirbjhjVT2GhbgISegjUDUvQJCph+dgZuU7jb2AcUSQYyVch6BgB9D3XjqrEjyozInHbX2LoSjCAnjI/FjkLM6EZohNA7QxK4cRKAwlZrrQy64Si78MYNJfTmX5sEQszo1zajofGEJGAtAfHNHVGegSeQ2CD+sW4hdEdIAl0sgRAYdbFAQ82FJBCSQEgCIQk4l0AIjJzLLPRESAIhCYQkEJJAF0vg/wBMng85iZWBHAAAAABJRU5ErkJggg==";

// node_modules/@lightningjs/blits/src/components/FPScounter.js
var FPScounter_default = () => component_default("FPScounter", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2, Log2) {
      const elms = [];
      const elementConfigs = [];
      const forloops = [];
      const props = [];
      const created = [];
      const effects = {};
      const skips2 = [];
      let componentType;
      let rootComponent = component;
      let propData;
      let slotComponent;
      let inSlot = false;
      let slotChildCounter = 0;
      let cmps = [];
      elementConfigs[0] = {};
      elms[0] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elms[0].populate(elementConfigs[0]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[0];
      elementConfigs[1] = {};
      elms[1] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[1]["y"] = 15;
      elementConfigs[1]["x"] = 20;
      elms[1].populate(elementConfigs[1]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[1];
      elementConfigs[2] = {};
      elms[2] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elms[2].populate(elementConfigs[2]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[3] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[2];
      elementConfigs[3] = {};
      elms[3] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[3]["image"] = component.image;
      elementConfigs[3]["w"] = 43;
      elementConfigs[3]["h"] = 25;
      elementConfigs[3]["map"] = component.sprite;
      elementConfigs[3]["frame"] = "fps";
      skips2[3] = [];
      if (typeof cmps[3] !== "undefined") {
        for (let key in cmps[3][Symbol.for("config")].props) {
          delete elementConfigs[3][cmps[3][Symbol.for("config")].props[key]];
          skips2[3].push(cmps[3][Symbol.for("config")].props[key]);
        }
      }
      elms[3].populate(elementConfigs[3]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[3];
      props[4] = {};
      props[4]["image"] = component.image;
      props[4]["w"] = 43;
      props[4]["h"] = 25;
      props[4]["map"] = component.sprite;
      props[4]["frame"] = "fps";
      componentType = props[4]["is"] || "Sprite";
      components[4];
      if (typeof componentType === "string") {
        components[4] = context.components && context.components[componentType] || components[componentType];
        if (!components[4]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[4] = componentType;
      }
      elms[4] = components[4].call(null, { props: props[4] }, elms[3], component);
      if (elms[4][Symbol.for("slots")][0]) {
        parent = elms[4][Symbol.for("slots")][0];
        slotComponent = elms[4];
        inSlot = true;
      } else {
        parent = elms[4][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[2];
      elementConfigs[5] = {};
      elms[5] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[5]["x"] = 58;
      elementConfigs[5]["y"] = 2;
      elms[5].populate(elementConfigs[5]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[6] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      elementConfigs[6] = {};
      elms[6] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[6]["image"] = component.image;
      elementConfigs[6]["x"] = 0;
      elementConfigs[6]["h"] = 20;
      elementConfigs[6]["w"] = 20;
      elementConfigs[6]["map"] = component.sprite;
      elementConfigs[6]["frame"] = component.fps[0];
      skips2[6] = [];
      if (typeof cmps[6] !== "undefined") {
        for (let key in cmps[6][Symbol.for("config")].props) {
          delete elementConfigs[6][cmps[6][Symbol.for("config")].props[key]];
          skips2[6].push(cmps[6][Symbol.for("config")].props[key]);
        }
      }
      elms[6].populate(elementConfigs[6]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[6];
      props[7] = {};
      props[7]["image"] = component.image;
      props[7]["x"] = 0;
      props[7]["h"] = 20;
      props[7]["w"] = 20;
      props[7]["map"] = component.sprite;
      propData = component.fps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[7]["frame"] = propData;
      componentType = props[7]["is"] || "Sprite";
      components[7];
      if (typeof componentType === "string") {
        components[7] = context.components && context.components[componentType] || components[componentType];
        if (!components[7]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[7] = componentType;
      }
      elms[7] = components[7].call(null, { props: props[7] }, elms[6], component);
      if (elms[7][Symbol.for("slots")][0]) {
        parent = elms[7][Symbol.for("slots")][0];
        slotComponent = elms[7];
        inSlot = true;
      } else {
        parent = elms[7][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[8] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      elementConfigs[8] = {};
      elms[8] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[8]["image"] = component.image;
      elementConfigs[8]["x"] = 18;
      elementConfigs[8]["h"] = 20;
      elementConfigs[8]["w"] = 20;
      elementConfigs[8]["map"] = component.sprite;
      elementConfigs[8]["frame"] = component.fps[1];
      skips2[8] = [];
      if (typeof cmps[8] !== "undefined") {
        for (let key in cmps[8][Symbol.for("config")].props) {
          delete elementConfigs[8][cmps[8][Symbol.for("config")].props[key]];
          skips2[8].push(cmps[8][Symbol.for("config")].props[key]);
        }
      }
      elms[8].populate(elementConfigs[8]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[8];
      props[9] = {};
      props[9]["image"] = component.image;
      props[9]["x"] = 18;
      props[9]["h"] = 20;
      props[9]["w"] = 20;
      props[9]["map"] = component.sprite;
      propData = component.fps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[9]["frame"] = propData;
      componentType = props[9]["is"] || "Sprite";
      components[9];
      if (typeof componentType === "string") {
        components[9] = context.components && context.components[componentType] || components[componentType];
        if (!components[9]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[9] = componentType;
      }
      elms[9] = components[9].call(null, { props: props[9] }, elms[8], component);
      if (elms[9][Symbol.for("slots")][0]) {
        parent = elms[9][Symbol.for("slots")][0];
        slotComponent = elms[9];
        inSlot = true;
      } else {
        parent = elms[9][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[10] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      elementConfigs[10] = {};
      elms[10] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[10]["image"] = component.image;
      elementConfigs[10]["x"] = 36;
      elementConfigs[10]["h"] = 20;
      elementConfigs[10]["w"] = 20;
      elementConfigs[10]["map"] = component.sprite;
      elementConfigs[10]["frame"] = component.fps[2];
      skips2[10] = [];
      if (typeof cmps[10] !== "undefined") {
        for (let key in cmps[10][Symbol.for("config")].props) {
          delete elementConfigs[10][cmps[10][Symbol.for("config")].props[key]];
          skips2[10].push(cmps[10][Symbol.for("config")].props[key]);
        }
      }
      elms[10].populate(elementConfigs[10]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[10];
      props[11] = {};
      props[11]["image"] = component.image;
      props[11]["x"] = 36;
      props[11]["h"] = 20;
      props[11]["w"] = 20;
      props[11]["map"] = component.sprite;
      propData = component.fps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[11]["frame"] = propData;
      componentType = props[11]["is"] || "Sprite";
      components[11];
      if (typeof componentType === "string") {
        components[11] = context.components && context.components[componentType] || components[componentType];
        if (!components[11]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[11] = componentType;
      }
      elms[11] = components[11].call(null, { props: props[11] }, elms[10], component);
      if (elms[11][Symbol.for("slots")][0]) {
        parent = elms[11][Symbol.for("slots")][0];
        slotComponent = elms[11];
        inSlot = true;
      } else {
        parent = elms[11][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[1];
      elementConfigs[12] = {};
      elms[12] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[12]["x"] = 150;
      elms[12].populate(elementConfigs[12]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[13] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[12];
      elementConfigs[13] = {};
      elms[13] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[13]["image"] = component.image;
      elementConfigs[13]["y"] = 2;
      elementConfigs[13]["w"] = 48;
      elementConfigs[13]["h"] = 25;
      elementConfigs[13]["map"] = component.sprite;
      elementConfigs[13]["frame"] = "avg";
      skips2[13] = [];
      if (typeof cmps[13] !== "undefined") {
        for (let key in cmps[13][Symbol.for("config")].props) {
          delete elementConfigs[13][cmps[13][Symbol.for("config")].props[key]];
          skips2[13].push(cmps[13][Symbol.for("config")].props[key]);
        }
      }
      elms[13].populate(elementConfigs[13]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[13];
      props[14] = {};
      props[14]["image"] = component.image;
      props[14]["y"] = 2;
      props[14]["w"] = 48;
      props[14]["h"] = 25;
      props[14]["map"] = component.sprite;
      props[14]["frame"] = "avg";
      componentType = props[14]["is"] || "Sprite";
      components[14];
      if (typeof componentType === "string") {
        components[14] = context.components && context.components[componentType] || components[componentType];
        if (!components[14]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[14] = componentType;
      }
      elms[14] = components[14].call(null, { props: props[14] }, elms[13], component);
      if (elms[14][Symbol.for("slots")][0]) {
        parent = elms[14][Symbol.for("slots")][0];
        slotComponent = elms[14];
        inSlot = true;
      } else {
        parent = elms[14][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[12];
      elementConfigs[15] = {};
      elms[15] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[15]["x"] = 63;
      elementConfigs[15]["y"] = 2;
      elms[15].populate(elementConfigs[15]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[16] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      elementConfigs[16] = {};
      elms[16] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[16]["image"] = component.image;
      elementConfigs[16]["x"] = 0;
      elementConfigs[16]["h"] = 20;
      elementConfigs[16]["w"] = 20;
      elementConfigs[16]["map"] = component.sprite;
      elementConfigs[16]["frame"] = component.avgFps[0];
      skips2[16] = [];
      if (typeof cmps[16] !== "undefined") {
        for (let key in cmps[16][Symbol.for("config")].props) {
          delete elementConfigs[16][cmps[16][Symbol.for("config")].props[key]];
          skips2[16].push(cmps[16][Symbol.for("config")].props[key]);
        }
      }
      elms[16].populate(elementConfigs[16]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[16];
      props[17] = {};
      props[17]["image"] = component.image;
      props[17]["x"] = 0;
      props[17]["h"] = 20;
      props[17]["w"] = 20;
      props[17]["map"] = component.sprite;
      propData = component.avgFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[17]["frame"] = propData;
      componentType = props[17]["is"] || "Sprite";
      components[17];
      if (typeof componentType === "string") {
        components[17] = context.components && context.components[componentType] || components[componentType];
        if (!components[17]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[17] = componentType;
      }
      elms[17] = components[17].call(null, { props: props[17] }, elms[16], component);
      if (elms[17][Symbol.for("slots")][0]) {
        parent = elms[17][Symbol.for("slots")][0];
        slotComponent = elms[17];
        inSlot = true;
      } else {
        parent = elms[17][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[18] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      elementConfigs[18] = {};
      elms[18] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[18]["image"] = component.image;
      elementConfigs[18]["x"] = 18;
      elementConfigs[18]["h"] = 20;
      elementConfigs[18]["w"] = 20;
      elementConfigs[18]["map"] = component.sprite;
      elementConfigs[18]["frame"] = component.avgFps[1];
      skips2[18] = [];
      if (typeof cmps[18] !== "undefined") {
        for (let key in cmps[18][Symbol.for("config")].props) {
          delete elementConfigs[18][cmps[18][Symbol.for("config")].props[key]];
          skips2[18].push(cmps[18][Symbol.for("config")].props[key]);
        }
      }
      elms[18].populate(elementConfigs[18]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[18];
      props[19] = {};
      props[19]["image"] = component.image;
      props[19]["x"] = 18;
      props[19]["h"] = 20;
      props[19]["w"] = 20;
      props[19]["map"] = component.sprite;
      propData = component.avgFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[19]["frame"] = propData;
      componentType = props[19]["is"] || "Sprite";
      components[19];
      if (typeof componentType === "string") {
        components[19] = context.components && context.components[componentType] || components[componentType];
        if (!components[19]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[19] = componentType;
      }
      elms[19] = components[19].call(null, { props: props[19] }, elms[18], component);
      if (elms[19][Symbol.for("slots")][0]) {
        parent = elms[19][Symbol.for("slots")][0];
        slotComponent = elms[19];
        inSlot = true;
      } else {
        parent = elms[19][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[20] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      elementConfigs[20] = {};
      elms[20] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[20]["image"] = component.image;
      elementConfigs[20]["x"] = 36;
      elementConfigs[20]["h"] = 20;
      elementConfigs[20]["w"] = 20;
      elementConfigs[20]["map"] = component.sprite;
      elementConfigs[20]["frame"] = component.avgFps[2];
      skips2[20] = [];
      if (typeof cmps[20] !== "undefined") {
        for (let key in cmps[20][Symbol.for("config")].props) {
          delete elementConfigs[20][cmps[20][Symbol.for("config")].props[key]];
          skips2[20].push(cmps[20][Symbol.for("config")].props[key]);
        }
      }
      elms[20].populate(elementConfigs[20]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[20];
      props[21] = {};
      props[21]["image"] = component.image;
      props[21]["x"] = 36;
      props[21]["h"] = 20;
      props[21]["w"] = 20;
      props[21]["map"] = component.sprite;
      propData = component.avgFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[21]["frame"] = propData;
      componentType = props[21]["is"] || "Sprite";
      components[21];
      if (typeof componentType === "string") {
        components[21] = context.components && context.components[componentType] || components[componentType];
        if (!components[21]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[21] = componentType;
      }
      elms[21] = components[21].call(null, { props: props[21] }, elms[20], component);
      if (elms[21][Symbol.for("slots")][0]) {
        parent = elms[21][Symbol.for("slots")][0];
        slotComponent = elms[21];
        inSlot = true;
      } else {
        parent = elms[21][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[1];
      elementConfigs[22] = {};
      elms[22] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[22]["x"] = 0;
      elementConfigs[22]["y"] = 40;
      elms[22].populate(elementConfigs[22]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[23] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[22];
      elementConfigs[23] = {};
      elms[23] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[23]["image"] = component.image;
      elementConfigs[23]["x"] = "-2";
      elementConfigs[23]["w"] = 47;
      elementConfigs[23]["h"] = 25;
      elementConfigs[23]["map"] = component.sprite;
      elementConfigs[23]["frame"] = "min";
      skips2[23] = [];
      if (typeof cmps[23] !== "undefined") {
        for (let key in cmps[23][Symbol.for("config")].props) {
          delete elementConfigs[23][cmps[23][Symbol.for("config")].props[key]];
          skips2[23].push(cmps[23][Symbol.for("config")].props[key]);
        }
      }
      elms[23].populate(elementConfigs[23]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[23];
      props[24] = {};
      props[24]["image"] = component.image;
      props[24]["x"] = "-2";
      props[24]["w"] = 47;
      props[24]["h"] = 25;
      props[24]["map"] = component.sprite;
      props[24]["frame"] = "min";
      componentType = props[24]["is"] || "Sprite";
      components[24];
      if (typeof componentType === "string") {
        components[24] = context.components && context.components[componentType] || components[componentType];
        if (!components[24]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[24] = componentType;
      }
      elms[24] = components[24].call(null, { props: props[24] }, elms[23], component);
      if (elms[24][Symbol.for("slots")][0]) {
        parent = elms[24][Symbol.for("slots")][0];
        slotComponent = elms[24];
        inSlot = true;
      } else {
        parent = elms[24][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[22];
      elementConfigs[25] = {};
      elms[25] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[25]["x"] = 58;
      elementConfigs[25]["y"] = 2;
      elms[25].populate(elementConfigs[25]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[26] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      elementConfigs[26] = {};
      elms[26] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[26]["image"] = component.image;
      elementConfigs[26]["x"] = 0;
      elementConfigs[26]["h"] = 20;
      elementConfigs[26]["w"] = 20;
      elementConfigs[26]["map"] = component.sprite;
      elementConfigs[26]["frame"] = component.minFps[0];
      skips2[26] = [];
      if (typeof cmps[26] !== "undefined") {
        for (let key in cmps[26][Symbol.for("config")].props) {
          delete elementConfigs[26][cmps[26][Symbol.for("config")].props[key]];
          skips2[26].push(cmps[26][Symbol.for("config")].props[key]);
        }
      }
      elms[26].populate(elementConfigs[26]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[26];
      props[27] = {};
      props[27]["image"] = component.image;
      props[27]["x"] = 0;
      props[27]["h"] = 20;
      props[27]["w"] = 20;
      props[27]["map"] = component.sprite;
      propData = component.minFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[27]["frame"] = propData;
      componentType = props[27]["is"] || "Sprite";
      components[27];
      if (typeof componentType === "string") {
        components[27] = context.components && context.components[componentType] || components[componentType];
        if (!components[27]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[27] = componentType;
      }
      elms[27] = components[27].call(null, { props: props[27] }, elms[26], component);
      if (elms[27][Symbol.for("slots")][0]) {
        parent = elms[27][Symbol.for("slots")][0];
        slotComponent = elms[27];
        inSlot = true;
      } else {
        parent = elms[27][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[28] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      elementConfigs[28] = {};
      elms[28] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[28]["image"] = component.image;
      elementConfigs[28]["x"] = 18;
      elementConfigs[28]["h"] = 20;
      elementConfigs[28]["w"] = 20;
      elementConfigs[28]["map"] = component.sprite;
      elementConfigs[28]["frame"] = component.minFps[1];
      skips2[28] = [];
      if (typeof cmps[28] !== "undefined") {
        for (let key in cmps[28][Symbol.for("config")].props) {
          delete elementConfigs[28][cmps[28][Symbol.for("config")].props[key]];
          skips2[28].push(cmps[28][Symbol.for("config")].props[key]);
        }
      }
      elms[28].populate(elementConfigs[28]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[28];
      props[29] = {};
      props[29]["image"] = component.image;
      props[29]["x"] = 18;
      props[29]["h"] = 20;
      props[29]["w"] = 20;
      props[29]["map"] = component.sprite;
      propData = component.minFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[29]["frame"] = propData;
      componentType = props[29]["is"] || "Sprite";
      components[29];
      if (typeof componentType === "string") {
        components[29] = context.components && context.components[componentType] || components[componentType];
        if (!components[29]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[29] = componentType;
      }
      elms[29] = components[29].call(null, { props: props[29] }, elms[28], component);
      if (elms[29][Symbol.for("slots")][0]) {
        parent = elms[29][Symbol.for("slots")][0];
        slotComponent = elms[29];
        inSlot = true;
      } else {
        parent = elms[29][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[30] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      elementConfigs[30] = {};
      elms[30] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[30]["image"] = component.image;
      elementConfigs[30]["x"] = 36;
      elementConfigs[30]["h"] = 20;
      elementConfigs[30]["w"] = 20;
      elementConfigs[30]["map"] = component.sprite;
      elementConfigs[30]["frame"] = component.minFps[2];
      skips2[30] = [];
      if (typeof cmps[30] !== "undefined") {
        for (let key in cmps[30][Symbol.for("config")].props) {
          delete elementConfigs[30][cmps[30][Symbol.for("config")].props[key]];
          skips2[30].push(cmps[30][Symbol.for("config")].props[key]);
        }
      }
      elms[30].populate(elementConfigs[30]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[30];
      props[31] = {};
      props[31]["image"] = component.image;
      props[31]["x"] = 36;
      props[31]["h"] = 20;
      props[31]["w"] = 20;
      props[31]["map"] = component.sprite;
      propData = component.minFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[31]["frame"] = propData;
      componentType = props[31]["is"] || "Sprite";
      components[31];
      if (typeof componentType === "string") {
        components[31] = context.components && context.components[componentType] || components[componentType];
        if (!components[31]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[31] = componentType;
      }
      elms[31] = components[31].call(null, { props: props[31] }, elms[30], component);
      if (elms[31][Symbol.for("slots")][0]) {
        parent = elms[31][Symbol.for("slots")][0];
        slotComponent = elms[31];
        inSlot = true;
      } else {
        parent = elms[31][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[1];
      elementConfigs[32] = {};
      elms[32] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[32]["x"] = 150;
      elementConfigs[32]["y"] = 40;
      elms[32].populate(elementConfigs[32]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[33] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[32];
      elementConfigs[33] = {};
      elms[33] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[33]["image"] = component.image;
      elementConfigs[33]["w"] = 53;
      elementConfigs[33]["h"] = 25;
      elementConfigs[33]["map"] = component.sprite;
      elementConfigs[33]["frame"] = "max";
      skips2[33] = [];
      if (typeof cmps[33] !== "undefined") {
        for (let key in cmps[33][Symbol.for("config")].props) {
          delete elementConfigs[33][cmps[33][Symbol.for("config")].props[key]];
          skips2[33].push(cmps[33][Symbol.for("config")].props[key]);
        }
      }
      elms[33].populate(elementConfigs[33]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[33];
      props[34] = {};
      props[34]["image"] = component.image;
      props[34]["w"] = 53;
      props[34]["h"] = 25;
      props[34]["map"] = component.sprite;
      props[34]["frame"] = "max";
      componentType = props[34]["is"] || "Sprite";
      components[34];
      if (typeof componentType === "string") {
        components[34] = context.components && context.components[componentType] || components[componentType];
        if (!components[34]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[34] = componentType;
      }
      elms[34] = components[34].call(null, { props: props[34] }, elms[33], component);
      if (elms[34][Symbol.for("slots")][0]) {
        parent = elms[34][Symbol.for("slots")][0];
        slotComponent = elms[34];
        inSlot = true;
      } else {
        parent = elms[34][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      parent = elms[32];
      elementConfigs[35] = {};
      elms[35] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[35]["x"] = 63;
      elementConfigs[35]["y"] = 2;
      elms[35].populate(elementConfigs[35]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      cmps[36] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      elementConfigs[36] = {};
      elms[36] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[36]["image"] = component.image;
      elementConfigs[36]["x"] = 0;
      elementConfigs[36]["h"] = 20;
      elementConfigs[36]["w"] = 20;
      elementConfigs[36]["map"] = component.sprite;
      elementConfigs[36]["frame"] = component.maxFps[0];
      skips2[36] = [];
      if (typeof cmps[36] !== "undefined") {
        for (let key in cmps[36][Symbol.for("config")].props) {
          delete elementConfigs[36][cmps[36][Symbol.for("config")].props[key]];
          skips2[36].push(cmps[36][Symbol.for("config")].props[key]);
        }
      }
      elms[36].populate(elementConfigs[36]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[36];
      props[37] = {};
      props[37]["image"] = component.image;
      props[37]["x"] = 0;
      props[37]["h"] = 20;
      props[37]["w"] = 20;
      props[37]["map"] = component.sprite;
      propData = component.maxFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[37]["frame"] = propData;
      componentType = props[37]["is"] || "Sprite";
      components[37];
      if (typeof componentType === "string") {
        components[37] = context.components && context.components[componentType] || components[componentType];
        if (!components[37]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[37] = componentType;
      }
      elms[37] = components[37].call(null, { props: props[37] }, elms[36], component);
      if (elms[37][Symbol.for("slots")][0]) {
        parent = elms[37][Symbol.for("slots")][0];
        slotComponent = elms[37];
        inSlot = true;
      } else {
        parent = elms[37][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[38] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      elementConfigs[38] = {};
      elms[38] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[38]["image"] = component.image;
      elementConfigs[38]["x"] = 18;
      elementConfigs[38]["h"] = 20;
      elementConfigs[38]["w"] = 20;
      elementConfigs[38]["map"] = component.sprite;
      elementConfigs[38]["frame"] = component.maxFps[1];
      skips2[38] = [];
      if (typeof cmps[38] !== "undefined") {
        for (let key in cmps[38][Symbol.for("config")].props) {
          delete elementConfigs[38][cmps[38][Symbol.for("config")].props[key]];
          skips2[38].push(cmps[38][Symbol.for("config")].props[key]);
        }
      }
      elms[38].populate(elementConfigs[38]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[38];
      props[39] = {};
      props[39]["image"] = component.image;
      props[39]["x"] = 18;
      props[39]["h"] = 20;
      props[39]["w"] = 20;
      props[39]["map"] = component.sprite;
      propData = component.maxFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[39]["frame"] = propData;
      componentType = props[39]["is"] || "Sprite";
      components[39];
      if (typeof componentType === "string") {
        components[39] = context.components && context.components[componentType] || components[componentType];
        if (!components[39]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[39] = componentType;
      }
      elms[39] = components[39].call(null, { props: props[39] }, elms[38], component);
      if (elms[39][Symbol.for("slots")][0]) {
        parent = elms[39][Symbol.for("slots")][0];
        slotComponent = elms[39];
        inSlot = true;
      } else {
        parent = elms[39][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      cmps[40] = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      elementConfigs[40] = {};
      elms[40] = this.element(
        { parent: parent || "root" },
        inSlot === true ? slotComponent : component
      );
      elementConfigs[40]["image"] = component.image;
      elementConfigs[40]["x"] = 36;
      elementConfigs[40]["h"] = 20;
      elementConfigs[40]["w"] = 20;
      elementConfigs[40]["map"] = component.sprite;
      elementConfigs[40]["frame"] = component.maxFps[2];
      skips2[40] = [];
      if (typeof cmps[40] !== "undefined") {
        for (let key in cmps[40][Symbol.for("config")].props) {
          delete elementConfigs[40][cmps[40][Symbol.for("config")].props[key]];
          skips2[40].push(cmps[40][Symbol.for("config")].props[key]);
        }
      }
      elms[40].populate(elementConfigs[40]);
      if (inSlot === true) {
        slotChildCounter -= 1;
      }
      parent = elms[40];
      props[41] = {};
      props[41]["image"] = component.image;
      props[41]["x"] = 36;
      props[41]["h"] = 20;
      props[41]["w"] = 20;
      props[41]["map"] = component.sprite;
      propData = component.maxFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props[41]["frame"] = propData;
      componentType = props[41]["is"] || "Sprite";
      components[41];
      if (typeof componentType === "string") {
        components[41] = context.components && context.components[componentType] || components[componentType];
        if (!components[41]) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        components[41] = componentType;
      }
      elms[41] = components[41].call(null, { props: props[41] }, elms[40], component);
      if (elms[41][Symbol.for("slots")][0]) {
        parent = elms[41][Symbol.for("slots")][0];
        slotComponent = elms[41];
        inSlot = true;
      } else {
        parent = elms[41][Symbol.for("children")][0];
      }
      if (inSlot === true && slotChildCounter === 0) {
        inSlot = false;
      }
      return {
        elms,
        cleanup: () => {
          rootComponent = null;
          propData = null;
          slotComponent = null;
          parent = null;
          cmps[3] = null;
          props[4] = null;
          components[4] = null;
          cmps[6] = null;
          props[7] = null;
          components[7] = null;
          cmps[8] = null;
          props[9] = null;
          components[9] = null;
          cmps[10] = null;
          props[11] = null;
          components[11] = null;
          cmps[13] = null;
          props[14] = null;
          components[14] = null;
          cmps[16] = null;
          props[17] = null;
          components[17] = null;
          cmps[18] = null;
          props[19] = null;
          components[19] = null;
          cmps[20] = null;
          props[21] = null;
          components[21] = null;
          cmps[23] = null;
          props[24] = null;
          components[24] = null;
          cmps[26] = null;
          props[27] = null;
          components[27] = null;
          cmps[28] = null;
          props[29] = null;
          components[29] = null;
          cmps[30] = null;
          props[31] = null;
          components[31] = null;
          cmps[33] = null;
          props[34] = null;
          components[34] = null;
          cmps[36] = null;
          props[37] = null;
          components[37] = null;
          cmps[38] = null;
          props[39] = null;
          components[39] = null;
          cmps[40] = null;
          props[41] = null;
          components[41] = null;
          component = null;
          cmps.length = 0;
          elms.length = 0;
          components.length = 0;
          elementConfigs.length = 0;
          forloops.length = 0;
          props.length = 0;
          skips2.length = 0;
        }
      };
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[6] === "undefined" || skips[6].indexOf("frame") === -1)
          elms[6].set("frame", component.fps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[7][Symbol.for("props")]["frame"] = component.fps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[8] === "undefined" || skips[8].indexOf("frame") === -1)
          elms[8].set("frame", component.fps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[9][Symbol.for("props")]["frame"] = component.fps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[10] === "undefined" || skips[10].indexOf("frame") === -1)
          elms[10].set("frame", component.fps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[11][Symbol.for("props")]["frame"] = component.fps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[16] === "undefined" || skips[16].indexOf("frame") === -1)
          elms[16].set("frame", component.avgFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[17][Symbol.for("props")]["frame"] = component.avgFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[18] === "undefined" || skips[18].indexOf("frame") === -1)
          elms[18].set("frame", component.avgFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[19][Symbol.for("props")]["frame"] = component.avgFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[20] === "undefined" || skips[20].indexOf("frame") === -1)
          elms[20].set("frame", component.avgFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[21][Symbol.for("props")]["frame"] = component.avgFps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[26] === "undefined" || skips[26].indexOf("frame") === -1)
          elms[26].set("frame", component.minFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[27][Symbol.for("props")]["frame"] = component.minFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[28] === "undefined" || skips[28].indexOf("frame") === -1)
          elms[28].set("frame", component.minFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[29][Symbol.for("props")]["frame"] = component.minFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[30] === "undefined" || skips[30].indexOf("frame") === -1)
          elms[30].set("frame", component.minFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[31][Symbol.for("props")]["frame"] = component.minFps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[36] === "undefined" || skips[36].indexOf("frame") === -1)
          elms[36].set("frame", component.maxFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[37][Symbol.for("props")]["frame"] = component.maxFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[38] === "undefined" || skips[38].indexOf("frame") === -1)
          elms[38].set("frame", component.maxFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[39][Symbol.for("props")]["frame"] = component.maxFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skips === "undefined" || typeof skips[40] === "undefined" || skips[40].indexOf("frame") === -1)
          elms[40].set("frame", component.maxFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[41][Symbol.for("props")]["frame"] = component.maxFps[2];
      }
    ],
    context: {}
  },
  state() {
    return {
      image: fps_sprite_base64_default,
      sprite: {
        defaults: {
          y: 1,
          w: 20,
          h: 20
        },
        frames: {
          "-": { x: -1e3 },
          0: { x: 1 },
          1: { x: 23 },
          2: { x: 45 },
          3: { x: 67 },
          4: { x: 89 },
          5: { x: 111 },
          6: { x: 133 },
          7: { x: 155 },
          8: { x: 177 },
          9: { x: 199 },
          avg: { x: 221, w: 48, h: 25 },
          fps: { x: 271, w: 43, h: 25 },
          max: { x: 316, w: 53, h: 25 },
          min: { x: 371, w: 47, h: 25 }
        }
      },
      fps: "---",
      avgFps: "---",
      minFps: "---",
      maxFps: "---"
    };
  },
  hooks: {
    ready() {
      let minFps = 1e4;
      let maxFps = 0;
      let avgFps = 0;
      let totalFps = 0;
      let fpsUpdateCounter = 0;
    }
  }
});

// node_modules/@lightningjs/blits/src/components/index.js
var components_default = () => ({
  Circle: Circle_default(),
  RouterView: RouterView_default(),
  Sprite: Sprite_default(),
  FPScounter: FPScounter_default()
});

// node_modules/@lightningjs/blits/src/plugins/log.js
var log_default2 = {
  name: "log",
  plugin() {
    return log_default("App");
  }
};

// node_modules/@lightningjs/blits/src/plugin.js
var plugins = {
  // log plugin added by default
  log: log_default2
};
var registerPlugin = (plugin, nameOrOptions = "", options = {}) => {
  let name = void 0;
  if (typeof nameOrOptions === "object") {
    options = nameOrOptions;
  } else {
    name = nameOrOptions;
  }
  if (typeof plugin === "function") {
    if (name === void 0 || name === "") {
      throw Error("Error registering plugin: name is required for plugin");
    }
    plugins[name] = { plugin, options };
  } else if (plugin.plugin) {
    registerPlugin(plugin.plugin, name || plugin.name, options);
  }
};
var plugin_default = registerPlugin;

// node_modules/@lightningjs/blits/src/component.js
var globalComponents;
var required = (name) => {
  throw new Error(`Parameter ${name} is required`);
};
var Component = (name = required("name"), config = required("config")) => {
  let base = void 0;
  const component = function(opts, parentEl, parentComponent, rootComponent) {
    this.componentId = createHumanReadableId(name);
    this[symbols_default.effects] = [];
    this.lifecycle = Object.assign(Object.create(lifecycle_default), {
      component: this,
      previous: null,
      current: null
    });
    this.parent = parentComponent;
    this.rootParent = rootComponent;
    this[symbols_default.holder] = parentEl;
    this[symbols_default.id] = createInternalId();
    this[symbols_default.props] = reactive(opts.props || {}, settings_default.get("reactivityMode"));
    this[symbols_default.timeouts] = [];
    this[symbols_default.intervals] = [];
    this[symbols_default.originalState] = config.state && typeof config.state === "function" && config.state.apply(this) || {};
    this[symbols_default.originalState]["hasFocus"] = false;
    this[symbols_default.state] = reactive(this[symbols_default.originalState], settings_default.get("reactivityMode"));
    this.lifecycle.state = "init";
    const { elms, cleanup } = config.code.render.apply(stage, [
      parentEl,
      this,
      config,
      globalComponents,
      effect,
      getRaw,
      Log
    ]) || { elms: [], cleanup: () => {
    } };
    this[symbols_default.children] = elms;
    this[symbols_default.cleanup] = cleanup;
    this[symbols_default.wrapper] = this[symbols_default.children][0];
    this[symbols_default.slots] = this[symbols_default.children].filter((child) => child[symbols_default.isSlot]);
    this[symbols_default.rendererEventListeners] = [];
    if (config.hooks) {
      setTimeout(() => {
        if (config.hooks.frameTick) {
          const cb = (r, data) => emit("frameTick", this[symbols_default.identifier], this, [data]);
          this[symbols_default.rendererEventListeners].push({ event: "frameTick", cb });
          renderer2.on("frameTick", cb);
        }
        if (config.hooks.idle) {
          const cb = () => {
            emit("idle", this[symbols_default.identifier], this);
          };
          this[symbols_default.rendererEventListeners].push({ event: "idle", cb });
          renderer2.on("idle", cb);
        }
        if (config.hooks.fpsUpdate) {
          const cb = (r, data) => {
            emit("fpsUpdate", this[symbols_default.identifier], this, [data.fps]);
          };
          this[symbols_default.rendererEventListeners].push({ event: "fpsUpdate", cb });
          renderer2.on("fpsUpdate", cb);
        }
      });
      if (config.hooks.attach) {
        this[symbols_default.wrapper].node.on("inBounds", () => {
          this.lifecycle.state = "attach";
        });
      }
      if (config.hooks.detach) {
        this[symbols_default.wrapper].node.on("outOfBounds", (node, { previous }) => {
          if (previous > 0) this.lifecycle.state = "detach";
        });
      }
      if (config.hooks.enter) {
        this[symbols_default.wrapper].node.on("inViewport", () => {
          this.lifecycle.state = "enter";
        });
      }
      if (config.hooks.exit) {
        this[symbols_default.wrapper].node.on("outOfBounds", () => {
          this.lifecycle.state = "exit";
        });
      }
    }
    const effects = config.code.effects;
    for (let i = 0; i < effects.length; i++) {
      const eff = () => {
        effects[i](this, this[symbols_default.children], config, globalComponents, rootComponent, effect);
      };
      this[symbols_default.effects].push(eff);
      effect(eff);
    }
    if (this[symbols_default.watchers]) {
      const watcherkeys = Object.keys(this[symbols_default.watchers]);
      const watcherkeysLength = watcherkeys.length;
      for (let i = 0; i < watcherkeysLength; i++) {
        let target = this;
        let key = watcherkeys[i];
        const watchKey = key;
        if (key.indexOf(".") > -1) {
          const keys = key.split(".");
          key = keys.pop();
          for (let i2 = 0; i2 < keys.length; i2++) {
            target = target[keys[i2]];
          }
        }
        let old = this[key];
        const eff = (force = false) => {
          const newValue = target[key];
          if (old !== newValue || force === true) {
            this[symbols_default.watchers][watchKey].apply(this, [newValue, old]);
            old = newValue;
          }
        };
        this[symbols_default.effects].push(eff);
        effect(eff);
      }
    }
    setTimeout(() => this.lifecycle.state = "ready");
    return this;
  };
  const factory = (options = {}, parentEl, parentComponent, rootComponent) => {
    if (base_default[symbols_default["launched"]] === false) {
      const pluginKeys = Object.keys(plugins);
      const pluginKeysLength = pluginKeys.length;
      const pluginInstances = {};
      for (let i = 0; i < pluginKeysLength; i++) {
        const pluginName = pluginKeys[i];
        const prefixedPluginName = `$${pluginName}`;
        if (prefixedPluginName in base_default) {
          Log.warn(
            `"${pluginName}" (this.${prefixedPluginName}) already exists as a property or plugin on the Base Component. You may be overwriting built-in functionality. Proceed with care!`
          );
        }
        const plugin = plugins[pluginName];
        pluginInstances[prefixedPluginName] = {
          // instantiate the plugin, passing in provided options
          value: Object.defineProperties(plugin.plugin(plugin.options), shared),
          writable: false,
          enumerable: true,
          configurable: true
        };
      }
      Object.defineProperties(base_default, pluginInstances);
      for (const plugin in pluginInstances) {
        Object.defineProperties(base_default[plugin], pluginInstances);
        delete base_default[plugin][plugin];
      }
      globalComponents = components_default();
      base_default[symbols_default["launched"]] = true;
    }
    if (base === void 0) {
      Log.debug(`Setting up ${name} component`);
      base = setup_default(Object.create(base_default), config);
    }
    if (config.code === void 0) {
      Log.debug(`Generating code for ${name} component`);
      config.code = generator_default.call(config, parser_default(config.template, name));
    }
    return component.call(Object.create(base), options, parentEl, parentComponent, rootComponent);
  };
  factory[Symbol.for("config")] = config;
  factory[symbols_default.isComponent] = true;
  return factory;
};
var component_default = Component;

// node_modules/@lightningjs/blits/index.js
var blits_default = {
  Component: component_default,
  Application: application_default,
  Launch: launch_default2,
  Plugin: plugin_default
};
export {
  blits_default as default
};
//# sourceMappingURL=@lightningjs_blits.js.map
