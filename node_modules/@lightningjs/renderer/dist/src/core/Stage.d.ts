import { AnimationManager } from './animations/AnimationManager.js';
import { CoreNode, type CoreNodeProps } from './CoreNode.js';
import { CoreTextureManager } from './CoreTextureManager.js';
import { TrFontManager } from './text-rendering/TrFontManager.js';
import { CoreShaderManager, type ShaderMap } from './CoreShaderManager.js';
import { TextRenderer, type TextRendererMap, type TrProps } from './text-rendering/renderers/TextRenderer.js';
import { EventEmitter } from '../common/EventEmitter.js';
import { ContextSpy } from './lib/ContextSpy.js';
import type { FpsUpdatePayload, FrameTickPayload } from '../common/CommonTypes.js';
import { TextureMemoryManager, type TextureMemoryManagerSettings } from './TextureMemoryManager.js';
import { CoreRenderer } from './renderers/CoreRenderer.js';
import type { WebGlCoreRenderer } from './renderers/webgl/WebGlCoreRenderer.js';
import type { CanvasCoreRenderer } from './renderers/canvas/CanvasCoreRenderer.js';
import type { BaseShaderController } from '../main-api/ShaderController.js';
import { CoreTextNode, type CoreTextNodeProps } from './CoreTextNode.js';
import type { SdfTextRenderer } from './text-rendering/renderers/SdfTextRenderer/SdfTextRenderer.js';
import type { CanvasTextRenderer } from './text-rendering/renderers/CanvasTextRenderer.js';
import { type Bound } from './lib/utils.js';
import type { Texture } from './textures/Texture.js';
export interface StageOptions {
    appWidth: number;
    appHeight: number;
    textureMemory: TextureMemoryManagerSettings;
    boundsMargin: number | [number, number, number, number];
    deviceLogicalPixelRatio: number;
    devicePhysicalPixelRatio: number;
    canvas: HTMLCanvasElement | OffscreenCanvas;
    clearColor: number;
    fpsUpdateInterval: number;
    targetFPS: number;
    enableContextSpy: boolean;
    forceWebGL2: boolean;
    numImageWorkers: number;
    renderEngine: typeof WebGlCoreRenderer | typeof CanvasCoreRenderer;
    eventBus: EventEmitter;
    quadBufferSize: number;
    fontEngines: (typeof CanvasTextRenderer | typeof SdfTextRenderer)[];
    inspector: boolean;
    strictBounds: boolean;
    textureProcessingTimeLimit: number;
    createImageBitmapSupport: 'auto' | 'basic' | 'options' | 'full';
    maxRetryCount: number;
}
export type StageFpsUpdateHandler = (stage: Stage, fpsData: FpsUpdatePayload) => void;
export type StageFrameTickHandler = (stage: Stage, frameTickData: FrameTickPayload) => void;
export interface Point {
    x: number;
    y: number;
}
export declare class Stage {
    readonly options: StageOptions;
    readonly animationManager: AnimationManager;
    readonly txManager: CoreTextureManager;
    readonly txMemManager: TextureMemoryManager;
    readonly fontManager: TrFontManager;
    readonly textRenderers: Partial<TextRendererMap>;
    readonly shManager: CoreShaderManager;
    readonly renderer: CoreRenderer;
    readonly root: CoreNode;
    readonly interactiveNodes: Set<CoreNode>;
    boundsMargin: [number, number, number, number];
    readonly defShaderCtr: BaseShaderController;
    readonly strictBound: Bound;
    readonly preloadBound: Bound;
    readonly strictBounds: boolean;
    readonly defaultTexture: Texture | null;
    /**
     * Target frame time in milliseconds (calculated from targetFPS)
     *
     * @remarks
     * This is pre-calculated to avoid recalculating on every frame.
     * - 0 means no throttling (use display refresh rate)
     * - >0 means throttle to this frame time (1000 / targetFPS)
     */
    targetFrameTime: number;
    /**
     * Renderer Event Bus for the Stage to emit events onto
     *
     * @remarks
     * In reality this is just the RendererMain instance, which is an EventEmitter.
     * this allows us to directly emit events from the Stage to RendererMain
     * without having to set up forwarding handlers.
     */
    readonly eventBus: EventEmitter;
    deltaTime: number;
    lastFrameTime: number;
    currentFrameTime: number;
    private fpsNumFrames;
    private fpsElapsedTime;
    private numQuadsRendered;
    private renderRequested;
    private frameEventQueue;
    private fontResolveMap;
    contextSpy: ContextSpy | null;
    /**
     * Stage constructor
     */
    constructor(options: StageOptions);
    setClearColor(color: number): void;
    /**
     * Update the target frame time based on the current targetFPS setting
     *
     * @remarks
     * This should be called whenever the targetFPS option is changed
     * to ensure targetFrameTime stays in sync.
     * targetFPS of 0 means no throttling (targetFrameTime = 0)
     * targetFPS > 0 means throttle to 1000/targetFPS milliseconds
     */
    updateTargetFrameTime(): void;
    updateFrameTime(): void;
    /**
     * Create default PixelTexture
     */
    createDefaultTexture(): void;
    /**
     * Update animations
     */
    updateAnimations(): void;
    /**
     * Check if the scene has updates
     */
    hasSceneUpdates(): boolean;
    /**
     * Start a new frame draw
     */
    drawFrame(): void;
    /**
     * Queue an event to be emitted after the current/next frame is rendered
     *
     * @remarks
     * When we are operating in the context of the render loop, we may want to
     * emit events that are related to the current frame. However, we generally do
     * NOT want to emit events directly in the middle of the render loop, since
     * this could enable event handlers to modify the scene graph and cause
     * unexpected behavior. Instead, we queue up events to be emitted and then
     * flush the queue after the frame has been rendered.
     *
     * @param name
     * @param data
     */
    queueFrameEvent(name: string, data: unknown): void;
    /**
     * Emit all queued frame events
     *
     * @remarks
     * This method should be called after the frame has been rendered to emit
     * all events that were queued during the frame.
     *
     * See {@link queueFrameEvent} for more information.
     */
    flushFrameEvents(): void;
    calculateFps(): void;
    calculateQuads(): void;
    addQuads(node: CoreNode): void;
    /**
     * Request a render pass without forcing an update
     */
    requestRender(): void;
    /**
     * Find all nodes at a given point
     * @param data
     */
    findNodesAtPoint(data: Point): CoreNode[];
    /**
     * Find the top node at a given point
     * @param data
     * @returns
     */
    getNodeFromPosition(data: Point): CoreNode | null;
    /**
     * Given a font name, and possible renderer override, return the best compatible text renderer.
     *
     * @remarks
     * Will try to return a canvas renderer if no other suitable renderer can be resolved.
     *
     * @param fontFamily
     * @param textRendererOverride
     * @returns
     */
    resolveTextRenderer(trProps: TrProps, textRendererOverride?: keyof TextRendererMap | null): TextRenderer | null;
    /**
     * Create a shader controller instance
     *
     * @param type
     * @param props
     * @returns
     */
    createShaderCtr(type: keyof ShaderMap, props: Record<string, unknown>): BaseShaderController;
    createNode(props: Partial<CoreNodeProps>): CoreNode;
    createTextNode(props: Partial<CoreTextNodeProps>): CoreTextNode;
    setBoundsMargin(value: number | [number, number, number, number]): void;
    /**
     * Resolves the default property values for a Node
     *
     * @remarks
     * This method is used internally by the RendererMain to resolve the default
     * property values for a Node. It is exposed publicly so that it can be used
     * by Core Driver implementations.
     *
     * @param props
     * @returns
     */
    protected resolveNodeDefaults(props: Partial<CoreNodeProps>): CoreNodeProps;
    /**
     * Cleanup Unused Textures
     *
     * @remarks
     * This method is used to cleanup unused textures that are no longer in use.
     */
    cleanup(): void;
}
